# Get to Know QSpace

Author: [Seung-Sup Lee](https://www.theorie.physik.uni-muenchen.de/lsvondelft/members/sci_mem/seung_sup-lee/index.html)

**QSpace** is a powerful tensor network library developed by [Andreas Weichselbaum](https://homepages.physik.uni-muenchen.de/~Andreas.Weichselbaum/), a long-term colleague of our group. This library enables the generation and manipulation of tensors that respect general Abelian and non-Abelian symmetries. It consists of many MATLAB functions (<span style="font-family: monospace; font-size:.85em">.m</span>), as well as MEX functions (<span style="font-family: monospace; font-size:.85em">.mexa64</span> or <span style="font-family: monospace; font-size:.85em">.mexamaci64</span>) that are binary files written in C++. These MEX functions are used for computationally demanding jobs, such as contraction and eigendecomposition. Thus using the QSpace library can be more efficient, even without exploiting symmetries, than the bare MATLAB code!

The goal of this tutorial is to provide the practical knowledge on using the QSpace library and understanding QSpace objects. For the details of physical and mathematical concepts (e.g., IROP, IREP), please refer to [A. Weichselbaum, Ann. Phys. *327*, 2972 (2012)](https://www.sciencedirect.com/science/article/pii/S0003491612001121?via%3Dihub) and [A. Weichselbaum, Phys. Rev. Research **2**, 023385 (2020)](https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.2.023385).

## Clebsch-Gordan coefficient data

The key idea of QSpace is to decompose the tensor into two parts, Clebsch-Gordan coefficients and reduced matrix elements, and to treat them separately. The reduced matrix elements may change depending on the system parameters, while the Clebsch-Gordan coefficients are generic. For example, two spin-1/2's should be always combined anti-symmetrically to make the spin singlet, independent of system parameters. So, once the coefficients are generated, they can be recycled for the next calculations.

In this regard, the QSpace library generates Clebsch-Gordan coefficient data on the fly, e.g., when tensors are manipulated. The Clebsch-Gordan coefficients are tensors by themselves, and stored in a disk drive. The path to the directory in which the data is stored is saved as a MATLAB environment variable (**not** a shell variable) <span style="font-family: monospace; font-size:.85em">RC_STORE</span>. To see the path, type in the MATLAB Command Window:

```matlab
getenv('RC_STORE')
```


<span style="font-family: monospace; font-size:.85em">ans =<br>
'/Users/S.Lee/data/RCStore' </span>

<span style="font-family: monospace; font-size:.85em">startup.m</span>which we provided automatically sets the path and creates the corresponding directory, if not exists.

The Clebsch-Gordan data generated on the fly are indexed depending on their order of appearance. Therefore, it is possible that the same Clebsch-Gordan coefficients are indexed differently, or vice versa. So manipulating (e.g., contracting) one QSpace object generated from the calculation on one machine and another QSpace objected generated from the other calculation on the other machine can lead to the inconsistency of the Clebsch-Gordan coefficients. Therefore, it is advised to generate large enough set of the Clebsch-Gordan data and use the data set for different calculations. However, for the tutorial here, this is not important: The Clebsch-Gordan coefficients relevant to this tutorial can be generated from scratch with very small computational cost.

## Generate local operators

The first step of using QSpace is to identify which symmetries in the system are to be exploited. Then we generate the tensors that respect such symmetries. The tensors for a local space (e.g., one lattice site) are generated by <span style="font-family: monospace; font-size:.85em">getLocalSpace</span>. For example, we obtain the operators that act on a **spin-1/2** site and respect SU(2) spin symmetry:

```matlab
clear
[S,I] = getLocalSpace('Spin', 1/2);
S  % spin operator
```

<span style="font-family: monospace; font-size:.85em">S =<br>
&nbsp;&nbsp;&nbsp;Q:  1x [1 1 1] having 'SU2',&nbsp;&nbsp;&nbsp;operator, &nbsp;&nbsp;&nbsp;{ , * , * }<br>
  data:  3-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 x 1 => 2 x 2 x 3<br>
  <br>
&nbsp;&nbsp;&nbsp;1.  1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2x2x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ; 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.225</span>
```matlab
I  % struct that contains various information
```


<span style="font-family: monospace; font-size:.85em">I = struct with fields:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Sloc: 0.5000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOP: [1x1 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sym: 'SpinS'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U: [2x2 double]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is: [1x1 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E: [1x1 QSpace]</span>

```matlab
I.E  % Identity operator
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [1 1] having 'SU2',&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}</span>

Meaning of the displayed information will be explained in the next section.

On the other hand, the operators for one **spinful fermionic site**, which respect U(1) charge and SU(2) spin symmetries, are generated by:

```matlab
[F,Z,S,I] = getLocalSpace('FermionS', 'Acharge','SU2spin','NC', 1);
```

Here <span style="font-family: monospace; font-size:.85em">'FermionS'</span> means **s**pinful **f**ermion, <span style="font-family: monospace; font-size:.85em">'Acharge,SU2spin'</span> means U(1) charge (A from **A**belian) and SU(2) spin symmetries, and <span style="font-family: monospace; font-size:.85em">'NC',1'</span> means that there is only one channel (NC from **n**umber of **c**hannels).

```matlab
F % particle annihilation operator
```
<span style="font-family: monospace; font-size:.85em">F = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator&nbsp;&nbsp;&nbsp;{ , * , * }<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; 1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414</span>

```matlab
Z % fermionic sign operator
```
<span style="font-family: monospace; font-size:.85em">Z = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;(1.414)
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br></span>

```matlab
S % spin operator
```
<span style="font-family: monospace; font-size:.85em">S = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp; operator, &nbsp;&nbsp;{  , * , * }<br>
&nbsp;data: 3-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 x 1 => 2 x 2 x 3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ; 0 2  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.225<br></span>

```matlab
I.E % identity operator
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;(1.414)<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br></span>


<span style="font-family: monospace; font-size:.85em">F</span> and <span style="font-family: monospace; font-size:.85em">S</span> are rank-3 tensors, since they change charge and spin quantum numbers. On the other hand, <span style="font-family: monospace; font-size:.85em">Z</span>and <span style="font-family: monospace; font-size:.85em">I.E</span> are rank-2 tensors, since they do not change quantum numbers; that is, they are scalars in terms of the Clebsch-Gordan coefficients.

<span style="font-family: monospace; font-size:.85em">getLocalSpace</span> can deal with general situations. For details, type in the MATLAB command window: <span style="font-family: monospace; font-size:.85em">'help getLocalSpace'</span>.

## Differences from the TN tutorial materials

Careful readers might have realized that the syntax of <span style="font-family: monospace; font-size:.85em">getLocalSpace</span> here is similar to that of <span style="font-family: monospace; font-size:.85em">TN/Tensor/getLocalSpace</span> which has been used for the previous tutorials. Actually, the TN tutorial materials are designed to be consistent with the syntax convention of the QSpace library. Here by TN, I mean the tutorial materials that we have used so far during the course, whose computational routines are pure MATLAB .m files.

There are, however, a few differences between the conventions of TN and QSpace that need to be kept in mind. 

**1.** The last output <span style="font-family: monospace; font-size:.85em">I</span> of <span style="font-family: monospace; font-size:.85em">getLocalSpace</span> in the TN material is the identity operator, while <span style="font-family: monospace; font-size:.85em">I</span> from the QSpace function is the struct variable that contains the identity operator.

**2. The leg order convention is different.** For the rank-2 tensors (e.g., identity <span style="font-family: monospace; font-size:.85em">I</span> and fermion sign <span style="font-family: monospace; font-size:.85em">Z</span>), the convention is the same as in the TN material.

<p align="center">
  <img src="../images/image_0.png" alt="Alt Text" width = "5.5%">
</p>



The numbers attached to the legs are the order of legs. The first (bottom) and second (top) legs are to be contracted with bra and ket states, respectively. On the other hand, the QSpace convention for the rank-3 tensors (e.g., fermion annihilation <span style="font-family: monospace; font-size:.85em">F</span> and spin <span style="font-family: monospace; font-size:.85em">S</span>) generated by <span style="font-family: monospace; font-size:.85em">getLocalSpace</span> is different:



<p align="center">
  <img src="../images/image_1.png" alt="Alt Text" width = "10%">
</p>





Here the first and second legs have the same roles as for the rank-2 tensors, while the third leg indicates the nature of operator (e.g., spin-raising, annihilating particle of a specific spin at a specific channel). In the TN convention, the top leg is at the third place and the operator leg is at the second place.

While the TN convention is better compatible with covariant formulation of tensors, the QSpace convention has practical advantage. Typically, the bottom and top legs of tensors can involve large dimensions. For example, consider a situation when we compute correlator of two operators acting on different sites in a one-dimensional system. We should contract the bra and ket tensors and the local operators iteratively, all the way from one site to the other. At each iteration, the dimensions of the bottom and top legs are bond dimensions, while the operator leg has small dimensions (e.g., 1 for a single spin-$z$ operator and 3 for a full spin operator). Practically, it is better to place the legs of the largest dimensions to the front; then in most cases the tensors are matrices, not multi-dimensional arrays.

**3. The leg directions are incorporated in QSpace objects**, while the leg directions are rather bookkeeping in the TN materials. The tensors in the TN materials are just matrices or multi-dimensional arrays that cannot bring the information of leg directions. On the other hand, since the legs of QSpace objects are associated with quantum numbers, the directions of legs (inward or outward) are crucial.

## Understand QSpace objects

Let me explain how to interpret the displayed information, with the example of identity operator <span style="font-family: monospace; font-size:.85em">I.E</span> and particle annihilation operator `F`.
```matlab
I.E
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;{1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br></span>


The identity operator <span style="font-family: monospace; font-size:.85em">I.E</span> shows that there are three symmetry sectors: <span style="font-family: monospace; font-size:.85em">[-1 0]</span> is for empty state (no charge, no spin), <span style="font-family: monospace; font-size:.85em">[0 1]</span> is for singly occupied doublets (one charge, total spin 1/2; doublet means for two states $S_z =\pm 1/2$), and <span style="font-family: monospace; font-size:.85em">[1 0]</span> is for doubly occupied state (two charges, total spin 0; the doubly occupied state for a single orbital should be spin singlet, due to Pauli exclusion principle).

```matlab
F
```
<span style="font-family: monospace; font-size:.85em">F = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator&nbsp;&nbsp;&nbsp;{ , * , * }<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 1; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 1 0; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>


From top left to bottom right:

   -  <span style="font-family: monospace; font-size:.85em">Q: 2x [2 2 2]</span> : first <span style="font-family: monospace; font-size:.85em">2x</span> means that there are two symmetry sectors. <span style="font-family: monospace; font-size:.85em">[2 2 2]</span> means that there are three legs (so three 2's) and each leg has two quantum numbers (so 2 each). 
   -  <span style="font-family: monospace; font-size:.85em">having 'A,SU2'</span> : two quantum numbers are for U(1) (Abelian, so <span style="font-family: monospace; font-size:.85em">A</span>) and SU(2) symmetries, respectively. 
   -  <span style="font-family: monospace; font-size:.85em">operator</span>: FF is an operator with three legs. 
   - <span style="font-family: monospace; font-size:.85em">{, * , * }</span> : **itag (index tag)** for each leg. The itag indcates the name and the direction of legs. Here the names are not given (since it is just generated from <span style="font-family: monospace; font-size:.85em">getLocalSpace</span>), while indicating the directions. Empty for the first leg means inward, and <span style="font-family: monospace; font-size:.85em">*</span> for the second and third legs means outward. See the next sections for the detail of itags. 
   -  <span style="font-family: monospace; font-size:.85em">data: 3-D double (240 bytes)</span>: the data sector (i.e. reduced matrix elements) are three-dimensional array (since <span style="font-family: monospace; font-size:.85em">FF</span> is rank-3), and occupies 240 bytes. 
   -  <span style="font-family: monospace; font-size:.85em">2 x 2 x 1</span> : Hilbert space dimension, in terms of symmetry multiplets. It means that there are 2, 2, and 1 multiplets for the first, second, and third legs, respectively. 
   -  <span style="font-family: monospace; font-size:.85em">3 x 3 x 2</span> : Hilbert space dimension, in terms of bare states (not multiplets). It means that there are 3, 3, and 2 states for the first, second, and third legs, respectively. 
   -  <span style="font-family: monospace; font-size:.85em">1. 1x1x1 | 1x2x2</span>: The first symmetry sector (so <span style="font-family: monospace; font-size:.85em">1.</span>) has the reduced matrix elements as <span style="font-family: monospace; font-size:.85em">1x1x1</span> array in the multiplet basis. And a single multiplet representing the sector has multiplet dimension <span style="font-family: monospace; font-size:.85em">1x2x2</span>, that is, the multiplet corresponds to one state for the first leg and two states for the second and third legs, respectively. 
   -  <span style="font-family: monospace; font-size:.85em">[ -1 0 ; 0 1; -1 1 ]</span> : Quantum numbers for each symmetry sector. Each chunk separated by <span style="font-family: monospace; font-size:.85em">;</span> indicates the quantum number for each leg. As we used <span style="font-family: monospace; font-size:.85em">'Acharge,SU2spin'</span> option for <span style="font-family: monospace; font-size:.85em">getLocalSpace</span>, the first number for each chunk is the charge quantum number (number of charges with respect to half filling) and the second number is the spin quantum number (total spin multiplied by 2). So we see that, for this first symmetry sector, the first leg space has no charge (charge quantum number -1, since half filling has one charge), and no spin (spin quantum number 0). And the second leg space has one charge (charge quantum number 0) and total spin 1/2 (spin quantum number 1). Finally the quantum number [-1 1] of the third chunk shows how the operator <span style="font-family: monospace; font-size:.85em">FF</span> changes quantum number; it decreases charge quantum number by 1 (since it is an annihilation operator) and it is indeed a spinor of total spin 1/2 (spin quantum number is the total spin multiplied by 2) 
   -  <span style="font-family: monospace; font-size:.85em">-1.414</span> : It is the reduced matrix element for the first symmetry sector. 

## Access data in QSpace objects

The information of QSpace objects can be accessed in a similar way as for struct variables. The quantum numbers of <span style="font-family: monospace; font-size:.85em">F</span> are accessed by:
```matlab
F.Q % cell array of quantum numbers
```

<span style="font-family: monospace; font-size:.85em">ans = 1x3 cell <br>
<table>
  <tr>
    <th style="background-color: lightgray; color: gray; border: 1px solid gray;"></th>
   <th style="background-color: lightgray; color: gray; border: 1px solid gray;">1</th>
    <th style="background-color: lightgray; color: gray; border: 1px solid gray;">2</th>
    <th style="background-color: lightgray; color: gray; border: 1px solid gray;">3</th>
  </tr>
  <tr>
    <td style="background-color: lightgray; color: gray; border: 1px solid gray;">1</td>
    <td style="border: 1px solid gray;">[-1,0;0,1]</td>
    <td style="border: 1px solid gray;">[0,1;1,0]</td>
    <td style="border: 1px solid gray;">[-1,1;-1...]</td>
  </tr>
</table>
</span>



```matlab
F.Q{1} % first leg
```
<span style="font-family: monospace; font-size:.85em">ans = 2x2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
</span>

```matlab
F.Q{2} % second leg
```
<span style="font-family: monospace; font-size:.85em">ans = 2x2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
</span>
```matlab
F.Q{3} % third leg
```
<span style="font-family: monospace; font-size:.85em">ans = 2x2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
</span>



A <span style="font-family: monospace; font-size:.85em">m</span>-th row of <span style="font-family: monospace; font-size:.85em">F.Q{n}</span> indicates the quantum number of the <span style="font-family: monospace; font-size:.85em">m</span>-th symmetry sector for the <span style="font-family: monospace; font-size:.85em">n</span>-th leg space.

The reduced matrix elements are accessed by:
```matlab
F.data % cell array of reduced matrix element data
```

<span style="font-family: monospace; font-size:.85em">ans = 2x1 cell <br>
<table>
  <tr>
    <th style="background-color: lightgray; color: gray; border: 1px solid gray;"></th>
    <th style="background-color: lightgray; color: gray; border: 1px solid gray;">1</th>

  </tr>
  <tr>
    <td style="background-color: lightgray; color: gray; border: 1px solid gray;">1</td>
    <td style="border: 1px solid gray;">-1.4142</td>
  </tr>
  <tr>
    <td style="background-color: lightgray; color: gray; border: 1px solid gray;">2</td>
    <td style="border: 1px solid gray;">-1.4142</td>
  </tr>
</table>
</span>




```matlab
celldisp(F.data) % display the contents of a cell array
```
Of course, we can change the values of the data sector. For example,
```matlab
F2 = F;
F2.data{1} = 10;
F2
```

<span style="font-family: monospace; font-size:.85em">F2 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator&nbsp;&nbsp;&nbsp;{ , * , * }<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 1; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 1 0; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>



Also we can set and edit the **itags (index tags)**. The itags are saved as the cell array <span style="font-family: monospace; font-size:.85em">.info.itags</span>. Each cell element is a char array, which should be consistent with the direction of each leg. When the itag of a leg ends with <span style="font-family: monospace; font-size:.85em">*</span>, it means that the leg is outward. Otherwise, the leg is inward. Since the original direction was in-out-out, the first itag should not include <span style="font-family: monospace; font-size:.85em">*</span> and the second and third itags should end with <span style="font-family: monospace; font-size:.85em">*</span>.

```matlab
F2.info.itags = {'s00','s00','op*'}
```
<span style="font-family: monospace; font-size:.85em">F2 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator&nbsp;&nbsp;&nbsp;{ s00, s00* , op* }<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 1; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 1 0; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>


Here the name of the space, <span style="font-family: monospace; font-size:.85em">s00</span>, for the first and second legs means that the legs act on the space of the local site <span style="font-family: monospace; font-size:.85em">s00</span>. And the name <span style="font-family: monospace; font-size:.85em">op</span> for the third leg means that it indicates the nature of the operator, not acting on the physical space.

One can try to set the itags to be **in**consistent with the original itags. Then the QSpace library detects the inconsistency in the data and gives error message.

```matlab
try
    F2.info.itags = = {'s00','s00'','op*'};
    F2
catch e
    getReport(e);
end
```
<span style="font-family: monospace; font-size:.85em">F2 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2]&nbsp;&nbsp; having 'A,SU2',&nbsp;&nbsp;&nbsp;operator&nbsp;&nbsp;&nbsp;{ s00, s00 , op }<br>
./clebsch.cc:3605&nbsp;&nbsp; 15:29:54&nbsp;ERR init() got CGR QSet mismatch
./clebsch.cc:3605&nbsp;&nbsp;15:29:54&nbsp;ERR&nbsp;U(1) (-1,0,-1) <> U(1) 
</span>




The itags are really useful when we treat many tensors at the same time. For example, when many tensors are contracted sequentially (as in TN<span style="font-family: monospace; font-size:.85em">/Tensor/updateLeft</span>), tracking down the leg order at each contraction step is quite tedious job, and is often the source of bug, if one makes a mistake in counting the leg order. By using itags, however, the QSpace library performs the sanity check for the compatibility of legs, and enables the contraction multiple tensors/legs with simple syntax!

We emphasize that one can directly edit **only the reduced matrix elements** (<span style="font-family: monospace; font-size:.85em">.data</span>) **and itags** (<span style="font-family: monospace; font-size:.85em">.info.itags</span>) of QSpace objects. Tinkering any other part of QSpace object may break the consistency of data; and the QSpace library detects such consistency, as you see from the above example of wrong itags.

## Basic operations

QSpace library provides an efficient way of manipulating the tensors, in a similar way as the standard numerical arrays of MATLAB.

First, one can generate the array of empty QSpace objects, similarly as <span style="font-family: monospace; font-size:.85em">zeros</span>.
```matlab
M = QSpace
```
<span style="font-family: monospace; font-size:.85em">M = (empty QSpace)
</span>
```matlab
M = QSpace(3,1)
```
<span style="font-family: monospace; font-size:.85em">M = (empty QSpace)<br>
...<br>
M(3) = (empty QSpace)
</span>
```matlab
size(M)
```
<span style="font-family: monospace; font-size:.85em">ans = 1x2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1
</span>

And we can add and subtract QSpace objects.
```matlab
Z
```
<span style="font-family: monospace; font-size:.85em">Z = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.<br></span>
```matlab
I.E
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;{1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<br></span>

```matlab
Z - I.E % minus
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-2.&nbsp;&nbsp;{1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.<br></span>


Multiply a number to QSpace object.
```matlab
Z*3 % multiply number
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;{ , * }<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ;&nbsp; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3.&nbsp;&nbsp;{1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 1 0 ;&nbsp; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.<br></span>


Take complex conjugation.
```matlab
F
```

<span style="font-family: monospace; font-size:.85em">F = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{ , *, *  }<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 0 1 ; &nbsp;1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414.<br></span>

```matlab
conj(F) % complex conjugation
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{ *, ,  }<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 0 1 ; 1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414.<br></span>

```matlab
F1 = F;
F1.data{1} = 1i;
conj(F1)
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{ *, ,  }&nbsp;&nbsp;&nbsp;complex<br>
&nbsp;data: 3-D double (232 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1i<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp; 0 1 ; 1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>

We see that the complex conjugation of QSpace object flips all the leg directions (inward vs. outward) and takes the complex conjugate to the reduced matrix elements (numerical arrays in <span style="font-family: monospace; font-size:.85em">.data{..}</span>).

The permutation of the legs can be done by <span style="font-family: monospace; font-size:.85em">permute</span>, which is the wrap-up routine for the binary MEX function <span style="font-family: monospace; font-size:.85em">permuteQS</span>.

```matlab
permute(F,[2 1 3]) % permute top and bottom legs 
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{ * , ,* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; -1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>

```matlab
permute(F,'213') % equivalent expression to the above 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{ * , ,* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; -1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>


Also the complex conjugation can be done together with permutation, by setting the option <span style="font-family: monospace; font-size:.85em">'conj'</span> in the syntax of <span style="font-family: monospace; font-size:.85em">permute</span>. Then the Hermitian conjugate, which is the combination of the complex conjugate and transpose, to the particle annihilation operator <span style="font-family: monospace; font-size:.85em">F</span> is obtained by:

```matlab
permute(F, [2 1 3],'conj') % creation operator 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{  , *, }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; -1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>

```matlab
permute(F,'213*') % equivalent expression to the above 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{  , *, }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; -1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>

That is, it becomes the particle creation operator. The tensor network diagram for this is:

<p align="center">
  <img src="../images/image_2.png" alt="Alt Text" width = "10%">
</p>



The Hermitian conjugation for rank-2 operator is:

```matlab
permute(I.E,[2 1],'conj') 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.&nbsp;&nbsp;{-1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.<br></span>


We see that the identity operator is Hermtian:

```matlab
I.E - permute(I.E,[2 1],'conj') 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;{-1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.<br></span>

Interestingly, the wrap-up function has the same name as the MATLAB bulit-in <span style="font-family: monospace; font-size:.85em">permute</span>. Will it be a problem? Answer is no. MATLAB finds and executes a proper routine depending on the type of input variables. When it detects QSpace objects as input, it calls the routine <span style="font-family: monospace; font-size:.85em">QSpace/Class/@QSpace/permute</span> which is the wrap-up of the MEX function <span style="font-family: monospace; font-size:.85em">QSpace/bin/permuteQS</span> .

```matlab
which permute(F) 
```
<span style="font-family: monospace; font-size:.85em">/Users/S.Lee/Documents/MATLAB/QSpace_v3/Class/@QSpace/permute.m &nbsp; % QSpace method</span>

On the other hand, if we give a numeric array, then MATLAB calls the built-in function.

```matlab
M = [1,2;3,4];
which permute(F) 
```
<span style="font-family: monospace; font-size:.85em">built-in (/Applications/MATLAB_R220a.app/toolbox/matlab/elmat/@double/permute) &nbsp; % double method</span>

```matlab
permute(M,[2 1]) % transpose 
```
<span style="font-family: monospace; font-size:.85em">ans =  2 x 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4
</span>

To see the documentations for MEX functions (which are binary files stored in <span style="font-family: monospace; font-size:.85em">QSpace/bin</span>), type in the MATLAB Command Window:

<span style="font-family: monospace; font-size:.85em">>>Name_of_MEX_function -?</span>


For example, for permuteQS, type:

```matlab
permuteQS   -? 
```

<span style="font-family: monospace; font-size:.85em">Usage: A = **permuteQS**(A, P [,'conj'])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;permute input QSpace using given permutation P.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Optional trailing 'conj' also applies (complex) conjugation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(note that this also affects real QSpaces in that qdir and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itags are altered!).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For convenience, P[,'conj'] may also be represented as<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single string, e.e. [2 1],'conj' is equivalent to '2,1;*'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or '21*' where the convention on string notation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;follows that of contraction indices [ctrIdx]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NB! [06/02/2019] the provided permutation can be shorter<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;than the rank of the QSpace; in this case it only affects the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leading range of indices, i.e., acts like an identity<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on the remainder of indices.<br>
<br>
AW (C) Aug 2006 ; May 2010 ; Oct 2014
</span>

## Select subspace

We can select part of symmetry sectors, by using <span style="font-family: monospace; font-size:.85em">getsub</span>.
```matlab
I.E
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{-1.414}<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br></span>

```matlab
getsub(I.E,2)  % select the second sector 
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{-1.414}</span>
```matlab
getsub(I.E,[1 3])  % select the first and third sectors 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>


To choose the sectors of specific quantum numbers, we can combine <span style="font-family: monospace; font-size:.85em">getsub</span>, <span style="font-family: monospace; font-size:.85em">find</span>, and <span style="font-family: monospace; font-size:.85em">ismember</span> (the latter two are MATLAB built-ins.)
```matlab
getsub(I.E,find(ismember(I.E.Q{1},[0 1],'rows'))) % choose [0 1] sector 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}</span>


It can be done also with <span style="font-family: monospace; font-size:.85em">all</span> and <span style="font-family: monospace; font-size:.85em">bsxfun</span>.
```matlab
getsub(I.E,find(all(bsxfun(@eq,I.E.Q{1},[0 1]),2))) % the same 
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}</span>



## Contraction

The contraction of tensors can be done by <span style="font-family: monospace; font-size:.85em">contract</span> (which is the wrap-up of MEX function <span style="font-family: monospace; font-size:.85em">contractQS</span>). By exploiting symmetries, the contraction of QSpace objects is done for every symmetry sectors. **Only the sectors of two tensors, whose quantum numbers are identical, are to be contracted.** And the QSpace library automatically and seamlessly treats the contraction of the Clebsch-Gordan coefficients; we users need to only care about reduced matrix elements.

For example, the particle number operator $\hat{n} =\sum_{\sigma } {\hat{f} }_{\sigma }^{\dagger } {\hat{f} }_{\sigma }$ can be obtained by:

```matlab
NF = contract(F, '1,3;*',F, '1,3') 
```
<span style="font-family: monospace; font-size:.85em">NF = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 => 3 x 3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.</span>


We see that the sector of quantum number <span style="font-family: monospace; font-size:.85em">[0 1]</span>has one particle (see <span style="font-family: monospace; font-size:.85em">.data{1}</span> is 1) and the sector of <span style="font-family: monospace; font-size:.85em">[1 0]</span> has two (see <span style="font-family: monospace; font-size:.85em">.data{2}</span> is 2).

In the usage of <span style="font-family: monospace; font-size:.85em">contract</span>, * at the end of the second input <span style="font-family: monospace; font-size:.85em">'1,3;*'</span>means that the first input <span style="font-family: monospace; font-size:.85em">F</span> is complex conjugated before contraction. And <span style="font-family: monospace; font-size:.85em">'1,3'</span> in the second and fourth inputs mean that the first legs (<span style="font-family: monospace; font-size:.85em">'1'</span> and <span style="font-family: monospace; font-size:.85em">'1'</span> each) and the third legs (<span style="font-family: monospace; font-size:.85em">'3'</span> and <span style="font-family: monospace; font-size:.85em">'3'</span>each) are contracted, respectively. The tensor network diagram for this is:

<p align="center">
  <img src="../images/image_3.png" alt="Alt Text" width = "30%">
</p>

Here <span style="font-family: monospace; font-size:.85em">F</span>* means the complex conjugate to <span style="font-family: monospace; font-size:.85em">F</span>.

By using itags, the contraction can be made simpler. For example, the number operator can be obtained by:
```matlab
F1 = F;
F1.info.itags = { 's00', 's00*', 'op*'};
NF = contract(F1,'!2*',F1) 
```
<span style="font-family: monospace; font-size:.85em">NF = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00, s00* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 => 3 x 3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.</span>


In the usage of <span style="font-family: monospace; font-size:.85em">contract</span> here, <span style="font-family: monospace; font-size:.85em">*</span> at the end of the second input <span style="font-family: monospace; font-size:.85em">'!2*'</span>means that the first input <span style="font-family: monospace; font-size:.85em">F</span> is complex conjugated. And <span style="font-family: monospace; font-size:.85em">!2</span> in the second input means that all the legs of the first input except the first leg (<span style="font-family: monospace; font-size:.85em">'!1'</span>) are contracted to the legs of the third input, as long as their itags match. **Only the pair of outward leg (e.g., with itag **<span style="font-family: monospace; font-size:.85em">'s00'</span>**) and inward leg (e.g., with itag ****<span style="font-family: monospace; font-size:.85em">'s00'</span>****) of the same name can be contracted.** Here, the first legs and the third legs have compatible itags, so they are contracted.

Also, the <span style="font-family: monospace; font-size:.85em">contract</span> function supports multiple contractions in a single line syntax. For example, the squared number operator $\sum_{\sigma \sigma^{\prime } } {\hat{f} }_{\sigma }^{\dagger } {\hat{f} }_{\sigma } {\hat{f} }_{\sigma^{\prime } }^{\dagger } {\hat{f} }_{\sigma^{\prime } }$ can be obtained by:

```matlab
N2 = contract(F1, '!2*',{F1, '!1',{F1,  '!2*',F1}});
```

<span style="font-family: monospace; font-size:.85em">N2 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00, s00* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 => 3 x 3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.</span>


In such syntax, the contraction inside the inner-most parenthesis <span style="font-family: monospace; font-size:.85em">{ }</span> is performed first, and then the contraction for the next inner-most parenthesis is done, and so on. In the above example, the parenthesis are given so that the contraction is performed over two right-most tensors, and contract the left ones iteratively. For details, type:

<span style="font-family: monospace; font-size:.85em">>> contractQS -?</span>


## Rank-2 tensors

Rank-2 tensors are of the simplest type. (**Quick exercise**: Why not rank-1?) They are scalar in terms of Clebsch-Gordan coefficients and there is no (outer) multiplicity of symmetry sectors. And their reduced matrix elements form matrices.

So the QSpace library enables to treat rank-2 QSpace objects, in a way that usual matrices are treated by MATLAB built-in functions.

```matlab
Z.'  % transpose
```


<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ *,  }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>

```matlab
Z'  % Hermitian conjugate
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ *,  }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>

```matlab
Z' - Z  % Z is Hermitian
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ *,  }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.</span>

```matlab
Z * I.E  % matrix multiplication as contraction
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ *,  }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>



As in the case of <span style="font-family: monospace; font-size:.85em">permute</span> explained above, MATLAB can execute different functions depending on the type of inputs. That is, there are several QSpace functions that override the MATLAB built-in functions.

This simplification also works for some rank-3 tensors (whose <span style="font-family: monospace; font-size:.85em">.info.otype</span> is set as <span style="font-family: monospace; font-size:.85em">'operator''</span>).

```matlab
F  % Hermitian conjugate, the result is particle creation operators
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;{  , *,  }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; -1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414</span>

However, it is advisable to use <span style="font-family: monospace; font-size:.85em">permute</span> and  <span style="font-family: monospace; font-size:.85em">contract</span> in general, to avoid any mistake.

## Vacuum space

The left end and the right end of the matrix product states (MPS) are dummy legs of dimension 1. These dummy legs are introduced to represent all the constituent tensors (so-called A and B tensors) as being rank-3. Thus the dummy legs point to the space which has nothing, i.e., vacuum. The vacuum space carries no quantum number at all, and it is different from the empty state which has specific quantum number. The vacuum space for given set of symmetries is obtained by using <span style="font-family: monospace; font-size:.85em">getvac</span>:

```matlab
getvac(I.E)
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 1 x 1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 0 ; 0 0  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>

## Generate identity operators and isometries

We can obtain identity operators and isometries by using <span style="font-family: monospace; font-size:.85em">getIdentity</span>(which is the wrap-up of MEX function <span style="font-family: monospace; font-size:.85em">getIdentityQS</span>). There are three contexts of using <span style="font-family: monospace; font-size:.85em">getIdentity</span>.

**1. Obtain the identity operator for a given leg space.**

For example, the following provides the identity operator for the Hilbert space of the second leg of <span style="font-family: monospace; font-size:.85em">F</span>.
```matlab
FE2 = getIdentity(F,2)
```

<span style="font-family: monospace; font-size:.85em">FE2 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 => 3 x 3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 0 ; 1 0  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>

Note that FE2 is different from the identity operator <span style="font-family: monospace; font-size:.85em">I.E</span> that is for the whole Hilbert space of a spinful fermionic site, since <span style="font-family: monospace; font-size:.85em">FE2</span> does not contain the subspace in which there is no particle (with quantum number <span style="font-family: monospace; font-size:.85em">[-1 0]</span>).

```matlab
I.E - FE2(F,2)
```


<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (336 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 => 4 x 4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-2.22e-16&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.</span>

**2. Generate the isometry that combines the spaces of two legs.**

Let's create the isometry (so-called A tensors) which combines two local spaces (each of which spans for a spinful fermionic site) to span the product space. In this case, to distinguish different local spaces, it is advised to use itags.

```matlab
E1 = I.E;
E1.info.itags = { 's00', 's00*'};
E2 = I.E;
E2.info.itags = { 's01', 's01*'};
A = getIdentity(E1,2,E2,2) 
```

<span style="font-family: monospace; font-size:.85em">A = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 10x [2 2 1] having 'A,SU2',&nbsp;&nbsp;&nbsp;A-matrix,&nbsp;&nbsp;&nbsp;{ s00, s01, * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (1200 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 x 10 => 4 x 4 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; -1 0 ; -1 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; &nbsp;1 0 ; &nbsp;0 0 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 1x1x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ; &nbsp;0 0 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; -1 0 ; &nbsp;0 0 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;7. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 1 ; &nbsp;0 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.732<br>&nbsp;&nbsp;&nbsp;&nbsp;8. 1x1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;1 0 ; &nbsp;1 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;9. 1x1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;0 1 ; &nbsp;1 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;10. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 0 ; &nbsp;2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>
</span>

The corresponding diagram is:

<p align="center">
  <img src="../images/image_4.png" alt="Alt Text" width = "20%">
</p>

This isometry is left-normalized. (**Quick exercise**: check this!) Such isometries are the building blocks of the MPS.

In the lecture course, the convention for ordering the legs of isometries is left-bottom-right, as <span style="font-family: monospace; font-size:.85em">A</span> is so here. However, many functions and programs in and based on the QSpace library use different convention: left-right-bottom. The same reason, explained in the previous section on the convention differences, applies here as well. Typically the left and right legs have the largest dimensions, while the bottom leg acts on low-dimensional local space. So placing the left and right legs before the bottom leg is more practical.

<span style="font-family: monospace; font-size:.85em">getIdentity</span> also supports (i) setting the itag for a newly generated leg spanning the product space and (ii) permuting legs in a single line.


```matlab
A = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);
```

<span style="font-family: monospace; font-size:.85em">A = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 10x [2 2 1] having 'A,SU2',&nbsp;&nbsp;&nbsp;A-matrix,&nbsp;&nbsp;&nbsp;{ s00, A01, s01 }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (1200 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 x 3 x 10 => 4 x 4 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -2 0 ; -1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x2x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 1 ; &nbsp;0 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x2x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; -1 1 ; -1 0 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x3x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; &nbsp;0 0 ; &nbsp;1 0 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 1x3x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 0 ; &nbsp;0 1 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x3x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;0 0 ; -1 0 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;7. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x3x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 2 ; &nbsp;0 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.732<br>&nbsp;&nbsp;&nbsp;&nbsp;8. 1x2x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;1 1 ; &nbsp;1 0 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;9. 1x2x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;1 1 ; &nbsp;0 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;10. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;2 0 ; &nbsp;1 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>
</span>

Here the 5th input is the itag, and the 6th input is the permutation indices.

  

**3. Generate a **$1j$** symbol to invert the direction of the legs.**

As we have learned from the lecture, it is crucial to flip the leg directions to bring the MPS into different canonical forms (see the material for Tutorial T02a). While inverting leg directions was of mere bookkeeping purpose in the TN materials, it should be performed explicitly for the QSpace objects.

For example, let's invert the third leg of particle annihilation operator.

```matlab
F1 = F;
F1.info.itags = { 's00', 's00*', 'op*'};
F1
```

<span style="font-family: monospace; font-size:.85em">F1 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;operator,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00, s00*, op* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 &nbsp;1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; 1 &nbsp;0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414</span>

```matlab
I0 = getIdentity(F1,2, '-0')
```

<span style="font-family: monospace; font-size:.85em">I0 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ op, op }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 1 ; 1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}</span>



The generated operator <span style="font-family: monospace; font-size:.85em">I'</span> is rank-2, and has all-in legs. By looking at the quantum numbers associated with the third leg of <span style="font-family: monospace; font-size:.85em">F1</span>, we see that the first leg of <span style="font-family: monospace; font-size:.85em">I0</span> corresponds the third leg of <span style="font-family: monospace; font-size:.85em">F1</span>. The tensor network diagram for <span style="font-family: monospace; font-size:.85em">I0</span> is:

<p align="center">
  <img src="../images/image_5.png" alt="Alt Text" width = "12%">
</p>

Here the left and right legs in solid lines are the first and second legs, respectively.

In this diagram, we see an implicit leg drawn in dashed line, which does **not** appear in the display information above. This implicit leg carries **all zero quantum numbers** since the sum of the quantum numbers of incoming legs should be the same as the sum of those of outgoing legs (i.e., Kirchoff's law for quantum numbers). Note that the second quantum number is spin quantum number (multiplied by 2) associated with the SU(2) symmetry, and the spin quantum number for the implicit leg is zero (which means spin singlet). In other words, the Hilbert space for this implicit leg is vacuum; that's why the leg does not show up explicitly in the numerical object.

In the space of explicit legs, the $1j$ symbol behaves as unitary operation. So the tensor network state on which $1j$ symbol is acted can **differ** from the original state. One exception is that the explicit leg to be flipped acts on one-dimensional Hilbert space, where the unitary operation reduces to a single prefactor. Therefore, in general, it is required to consider the pair of $1j$ symbol and its conjugate. When a $1j$ symbol is acted, then its conjugate should be introduced at some point. This notion of pair can be understood intuitively by considering implicit legs that need to be contracted at last:

<p align="center">
  <img src="../images/image_6.png" alt="Alt Text" width = "30%">
</p>

Let's return to the example of inverting the third leg of <span style="font-family: monospace; font-size:.85em">F1</span>. We invert the leg by contracting the $1j$ symbol.

```matlab
F1I = contract(F1, '!1',I0, '!2')
```

<span style="font-family: monospace; font-size:.85em">F1I = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00, s00*, op }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 x 2 x 1 => 3 x 3 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; 0 &nbsp;1 ; 1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.414<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; 1 &nbsp;0 ; 1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414</span>

The resulting <span style="font-family: monospace; font-size:.85em">F1I</span> is also an annihilation operator, but it has the inward third leg.

For details, type: <span style="font-family: monospace; font-size:.85em">getIdentityQS -?</span>

## Automatic truncation of all-zero sectors

The <span style="font-family: monospace; font-size:.85em">contract</span> (and some other functions) of the QSpace library **may** remove the sectors whose reduced matrix elements (elements of <span style="font-family: monospace; font-size:.85em">.data{..}</span>) are all zeros. For example, consider the following case.
```matlab
[F,Z,S,I] = getLocalSpace( 'FermionS', 'Acharge', 'SU2spin', 'NC',1);
M1 = I.E; M1.info.itags = { 's00', 's00*'};
M2 = I.E; M2.info.itags = { 's01', 's01*'};
A = getIdentity(M1,2,M2,2, 'A01*',[1 3 2]);
contract(A, '!2*',{M1, '!1',{M2, '!1',A}})
```

<span style="font-family: monospace; font-size:.85em">A = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 6x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (784 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 x 10 => 16 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 3x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;72 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; &nbsp;0 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 0 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 0 ; &nbsp;0 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.</span>

This is the normal contraction of the identity tensors. The result acts on 16-dimensional space of two spinful fermionic sites.

What happens if we replace one sector of <span style="font-family: monospace; font-size:.85em">A</span> with all-zero reduced matrix elements?

```matlab
A.data{1} = zeros(size(A.data{1}));
contract(A, '!2*',{M1, '!1',{M2, '!1',A}});
```
<span style="font-family: monospace; font-size:.85em">A = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 5x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (672 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9 x 9 => 15 x 15<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -2 0 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 3x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; -1 1 ]&nbsp;&nbsp;72 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 0 ; &nbsp;0 0 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 1 ; &nbsp;0 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;</span>

Then we have the sector <span style="font-family: monospace; font-size:.85em">[-2 0]</span> is missing, and the result acts on 15-dimensional space.

It is an intended feature rather than a bug. When contract tensors over the tensor network, the all-zero sectors in the constituent tensors do not contribute to the result. So the truncation of such all-zero sectors yields better computational efficiency.

However, when we consider the Hamiltonian in effective basis, the Hamiltonian may have the sectors of all zero matrix elements, and such sectors should be kept. All the energy eigenvalues, whether zero or finite, have meaning! For this, we should enforce to keep all-zero sectors. One trick is to add the identity operator, multiplied by very small number smaller than double precision (e.g., $10^{-30}$), to the Hamiltonian. Such small number should not change the physical results, but prevents unwanted truncation.

## Eigendecomposition

Let's construct the hopping term $\sum_{\sigma } {\hat{f} }_{2\sigma }^{\dagger } {\hat{f} }_{1\sigma } +{\hat{f} }_{1\sigma }^{\dagger } {\hat{f} }_{2\sigma }$ acting on two spinful fermionic sites.

```matlab
% for site s00
F1 = F; F1.info.itags = { 's00', 's00*', 'op*'};
E1 = I.E; E1.info.itags = { 's00', 's00*'};
% for site s01
F2 = F; F2.info.itags = { 's01', 's01*', 'op*'};
E2 = I.E; E2.info.itags = { 's01', 's01*'};
Z2 = Z; Z2.info.itags = { 's01', 's01*'};
A = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);

H = contract(A, '!2*',{F1, '!1',{F2, '!2*',{Z2, '!1',A}}}) + ...
    contract(A, '!2*',{F1, '!2*',{Z2, '!1',{F2, '!1',A}}}) + ...
    getIdentity(A,2) * 1e-40
```

The first line of defining H means $\sum_{\sigma } {\hat{f} }_{2\sigma }^{\dagger } {\hat{f} }_{1\sigma }$, and the second line means its Hermitian conjugate. And in the third line, we added the identity multiplied by a small number, to let `H` have all the sectors (that amount to 16 dimensional space).


```matlab
celldisp(H.data)
```

<span style="font-family: monospace; font-size:.85em">ans{1} = <br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{2} = <br>
&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
&nbsp;&nbsp;&nbsp;1.0000&nbsp;&nbsp;&nbsp;&nbsp;0.0000
<br>
<br>
ans{3} = <br>
&nbsp;&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;-1.4142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;-1.4142&nbsp;&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;-1.4142<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;-1.4142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0000
<br>
<br>
ans{4} = <br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{5} = <br>
&nbsp;&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;-1.0000<br>
&nbsp;&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;0.0000
<br>
<br>
ans{6} = <br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
</span>

The eigenvalues and eigenvectors of <span style="font-family: monospace; font-size:.85em">H</span> can be obtained by <span style="font-family: monospace; font-size:.85em">eig</span> which is the wrap-up of <span style="font-family: monospace; font-size:.85em">eigQS</span>.

```matlab
[V,D] = eig(H)
```

<span style="font-family: monospace; font-size:.85em">V = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 6x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (784 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 x 10 => 16 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -2 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 1 ; -1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 3x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 0 ; &nbsp;0 0 ]&nbsp;&nbsp;72 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 2 ; &nbsp;0 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 1 ; &nbsp;1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;2 0 ; &nbsp;2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>
<br>
D = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 6x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (704 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6 x 10 => 10 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -2 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 1 ; -1 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 1x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 0 ; &nbsp;0 0 ]&nbsp;&nbsp;24 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 2 ; &nbsp;0 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 1 ; &nbsp;1 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;2 0 ; &nbsp;2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40<br>
<br>
</span>
<span style="font-family: monospace; font-size:.85em">F</span> and <span style="font-family: monospace; font-size:.85em">D</span> are QSpace objects. Each data of <span style="font-family: monospace; font-size:.85em">V</span> is the unitary matrix whose columns are eigenvectors:
```matlab
celldisp(V.data)
```

<span style="font-family: monospace; font-size:.85em">ans{1} = <br>
&nbsp;&nbsp;&nbsp;1<br>
<br>
<br>
ans{2} = <br>
&nbsp;&nbsp;-0.7071&nbsp;&nbsp;&nbsp;&nbsp;0.7071<br>
&nbsp;&nbsp;&nbsp;0.7071&nbsp;&nbsp;&nbsp;&nbsp;0.7071
<br>
<br>
ans{3} = <br>
&nbsp;&nbsp;&nbsp;-0.5000&nbsp;&nbsp;&nbsp;-0.7071&nbsp;&nbsp;&nbsp;&nbsp;-0.5000<br>
&nbsp;&nbsp;&nbsp;-0.7071&nbsp;&nbsp;&nbsp;-0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.7071<br>&nbsp;&nbsp;&nbsp;-0.5000&nbsp;&nbsp;&nbsp;&nbsp;0.7071&nbsp;&nbsp;&nbsp;&nbsp;-0.5000
<br>
<br>
ans{4} = <br>
&nbsp;&nbsp;&nbsp;1<br>
<br>
<br>
ans{5} = <br>
&nbsp;&nbsp;&nbsp;-0.7071&nbsp;&nbsp;&nbsp;-0.7071<br>
&nbsp;&nbsp;&nbsp;-0.7071&nbsp;&nbsp;&nbsp;-0.7071
<br>
<br>
ans{6} = <br>
&nbsp;&nbsp;&nbsp;1<br>
</span>

We can check the unitarity of <span style="font-family: monospace; font-size:.85em">V </span>by

```matlab
V2 = contract(V, '!2*',V);
isequal(V2,getIdentity(A,2))
```

<span style="font-family: monospace; font-size:.85em">ans =  logical<br>
&nbsp;&nbsp;&nbsp;0
</span>

Each data of <span style="font-family: monospace; font-size:.85em">D</span> is the row vector of eigenvalues:

```matlab
celldisp(D.data)
```
<span style="font-family: monospace; font-size:.85em">ans{1} =<br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{2} = <br>
&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;-1.0000<br>
<br>
<br>
ans{3} = <br>
&nbsp;&nbsp;-2.0000&nbsp;&nbsp;&nbsp;&nbsp;-0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000<br>
<br>
<br>
ans{4} =<br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{5} = <br>
&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;-1.0000<br>
<br>
<br>
ans{6} =<br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
</span>

(**Quick exercise**: Explain the eigenvalues.)

To make <span style="font-family: monospace; font-size:.85em">D</span> as an operator representing a diagonal matrix,

```matlab
D2 = diag(D)
```


<span style="font-family: monospace; font-size:.85em">V = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 6x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (784 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 x 10 => 16 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -2 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 1 ; -1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 3x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 0 ; &nbsp;0 0 ]&nbsp;&nbsp;72 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 2 ; &nbsp;0 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 1 ; &nbsp;1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;2 0 ; &nbsp;2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40<br>
<br>
</span>


```matlab
celldisp(D2.data)
```

<span style="font-family: monospace; font-size:.85em">ans{1} = <br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{2} = <br>
&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1.0000
<br>
<br>
ans{3} = <br>
&nbsp;&nbsp;&nbsp;-2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;-0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000
<br>
<br>
ans{4} = <br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{5} = <br>
&nbsp;&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;-1.0000
<br>
<br>
ans{6} = <br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
</span>


One may also directly use the original MEX function <span style="font-family: monospace; font-size:.85em">eigQS</span>.
```matlab
[E,Ieig] = eigQS(H);
```



Note that the syntax is a bit different from the wrap-up <span style="font-family: monospace; font-size:.85em">eig</span>. <span style="font-family: monospace; font-size:.85em">E</span> is two-column matrix whose first column is the energy eigenvalues (sorted in ascending order) and second column indicates the multiplet dimensions (i.e., degeneracy due to non-Abelian symmetry) associated with the eigenvalues. When only the Abelian symmetries are used, <span style="font-family: monospace; font-size:.85em">E</span> becomes a column vector, without having the second column for the multiplet dimensions.

```matlab
E
```

<span style="font-family: monospace; font-size:.85em">ans = 10x2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
</span>

And <span style="font-family: monospace; font-size:.85em">Inrg</span> is the struct that contains more result of the eigendecomposition, including the eigenvectors (<span style="font-family: monospace; font-size:.85em">.AK</span> and <span style="font-family: monospace; font-size:.85em">.AT</span>) and eigenvalues (<span style="font-family: monospace; font-size:.85em">.EK</span> and <span style="font-family: monospace; font-size:.85em">.ET</span>).
```matlab
Ieig
```
<span style="font-family: monospace; font-size:.85em">ans = struct with fields: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AK: [1x1 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AD: [1x1 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EK: [1x1 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ED: [1x1 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DB: [6x2 struct]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NK: 10<br>
&nbsp;&nbsp;&nbsp;Etrunc: 0<br>
</span>

Becasue of the MATLAB policy, the direct result of MEX functions should be of MATLAB built-in types, while the QSpace is the user-defined data type. Here <span style="font-family: monospace; font-size:.85em">.AK</span>, <span style="font-family: monospace; font-size:.85em">.AT</span>, <span style="font-family: monospace; font-size:.85em">.EK</span>, and <span style="font-family: monospace; font-size:.85em">.ET</span> are struct variables that are compatible with QSpace. So we wrap them up as QSpace objects:

```matlab
Ieig.EK = QSpace(Ieig.EK);
Ieig.AK = QSpace(Ieig.AK);
Ieig.EK
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 6x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (784 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 x 10 => 16 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -2 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 1 ; -1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 3x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 0 ; &nbsp;0 0 ]&nbsp;&nbsp;72 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 2 ; &nbsp;0 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 1 ; &nbsp;1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;2 0 ; &nbsp;2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e-40<br>
<br>
</span>
```matlab
Ieig.AK
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 6x [2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ A01, A01* }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (784 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10 x 10 => 16 x 16<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -2 0 ; -2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ -1 1 ; -1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;3. 3x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 0 ; &nbsp;0 0 ]&nbsp;&nbsp;72 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;4. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;3x3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;0 2 ; &nbsp;0 2 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.732}<br>&nbsp;&nbsp;&nbsp;&nbsp;5. 2x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;1 1 ; &nbsp;1 1 ]&nbsp;&nbsp;32 B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1.414}<br>&nbsp;&nbsp;&nbsp;&nbsp;6. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1x1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ &nbsp;2 0 ; &nbsp;2 0 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br>
<br>
</span>

We can set several options for <span style="font-family: monospace; font-size:.85em">eigQS</span>, such as <span style="font-family: monospace; font-size:.85em">Nkeep</span> (number of **multiplets** to be kept) and <span style="font-family: monospace; font-size:.85em">Etrunc</span> (threshold energy such that the energy eigenvalues below the value are to be kept). For details, type: <span style="font-family: monospace; font-size:.85em">eigQS -?</span>

## Singular value decomposition

We can perform the singular value decomposition (SVD) of QSpace objects, by using MEX function <span style="font-family: monospace; font-size:.85em">svdQS</span>. The first input to <span style="font-family: monospace; font-size:.85em">svdQS</span>is a QSpace object whose legs are **all in**. Indeed, this notion of decomposing all-in tensor is consistent with the diagrammatic expresssion of the Schmidt decomposition.

And the second input is the leg indices. The corresponding legs are to be the legs of the third output <span style="font-family: monospace; font-size:.85em">Vd</span> for right singular vectors. When non-Abelian symmetry is used, it is allowed to choose only one or $r-1$ indices, where $r$ is the rank of the first input. To "split off" different number of legs (to be associated with <span style="font-family: monospace; font-size:.85em">Vd</span>), we need to fuse the legs by using the isometry generated by <span style="font-family: monospace; font-size:.85em">getIdentity</span>; then perform the SVD; then split the legs by appling the conjugate of the iseometry used to fuse the legs.

For example, consider an isometry:

```matlab
[S,I] = getLocalSpace( 'Spin',1/2);
E1 = I.E; E1.info.itags = { 's00', 's00*'};
E2 = I.E; E2.info.itags = { 's01', 's01*'};
A = getIdentity(E1,2,E2,2,'A01*',[1 3 2]);
```


We need to flip the second leg to perform the SVD.

```matlab
I0 = getIdentity(A,2, '-0');
AI = contract(A, '!1',I0, '!2*',[1 3 2])
```


Then use the <span style="font-family: monospace; font-size:.85em">svdQS</span>.
```matlab
[U,S,Vd] = svdQS(AI,1);
```


As mentioned above, the direct outputs from MEX functions are in the form of struct variables, not as QSpace objects. So we need to wrap them up.
```matlab
U = QSpace(U);
```
<span style="font-family: monospace; font-size:.85em">U = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 2x [1 1 1] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00*, A01, s01 }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (224 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 2 x 1 => 2 x 4 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 0 ; 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.7071<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x3x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 2 ; 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.225<br></span>

```matlab
S = QSpace(S)
```
<span style="font-family: monospace; font-size:.85em">S = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [1 1] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00, s00 }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414&nbsp;&nbsp;{1.414}</span>

```matlab
Vd = QSpace(Vd)
```
<span style="font-family: monospace; font-size:.85em">Vd = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [1 1] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ s00*, s00 }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 2-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 => 2 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;&nbsp;{1.414}</span>



The first leg (incoming) of <span style="font-family: monospace; font-size:.85em">AI</span> is associated with the second leg (incoming) of <span style="font-family: monospace; font-size:.85em">Vd</span>. And the singular value tensor <span style="font-family: monospace; font-size:.85em">S</span> is all-in.

## Normalization convention

The QSpace library has different conventions of normalizing the Clebsch-Gordan coefficients for rank-2 tensors (such as <span style="font-family: monospace; font-size:.85em">Z</span> and <span style="font-family: monospace; font-size:.85em">I.E</span>) and for higher-rank tensors (such as <span style="font-family: monospace; font-size:.85em">F</span> and <span style="font-family: monospace; font-size:.85em">S</span>).

For rank-2 tensors, the Clebsch-Gordan coefficients are normalized so that the reduced matrix elements have immediately relevant values. The elements of the tensor <span style="font-family: monospace; font-size:.85em">D</span> (obtained after <span style="font-family: monospace; font-size:.85em">eig</span>) for the energy eigenvalues are indeed energy eigenvalues.
```matlab
celldisp(D.data)
```

<span style="font-family: monospace; font-size:.85em">ans{1} =<br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{2} = <br>
&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
<br>
<br>
ans{3} = <br>
&nbsp;&nbsp;-2.0000&nbsp;&nbsp;&nbsp;&nbsp;-0.0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0000<br>
<br>
<br>
ans{4} =<br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
<br>
<br>
ans{5} = <br>
&nbsp;&nbsp;-1.0000&nbsp;&nbsp;&nbsp;&nbsp;1.0000<br>
<br>
<br>
ans{6} =<br>
&nbsp;&nbsp;&nbsp;1.0000e-40<br>
</span>
Also each cell <span style="font-family: monospace; font-size:.85em">.data{..}</span> of identity operator <span style="font-family: monospace; font-size:.85em">I.E</span> contains the identity matrices themselves.
```matlab
celldisp(I.E.data)
```

<span style="font-family: monospace; font-size:.85em">ans{1} =<br>
&nbsp;&nbsp;&nbsp;1.0000<br>
</span>

On the other hand, for higher-rank tensors, the Clebsch-Gordan coefficents are normalized so that the contraction of a tensor and its Hermitian conjugate becomes unity, when the reduced matrix elements are unity. For example, consider a rank-3 tensor which is the subspace projection of <span style="font-family: monospace; font-size:.85em">F</span>,
```matlab
O1 = getsub(F,2)
```

<span style="font-family: monospace; font-size:.85em">O1 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 1x [2 2 2] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , *,  * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 3-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 x 1 => 2 x 1 x 2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x1x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 0 1 ; 1 0 ; -1 1 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.414<br></span>

```matlab
O1.data{1} = 1; % make the reduced matrix to be trivial 1
```


The contraction of <span style="font-family: monospace; font-size:.85em">O1</span> and its Hermitian conjugate, with all the legs contracted, is equal to the squared norm of the Clebsch-Gordan coefficents, since the reduced matrix is set as trivial 1.

```matlab
contract(O1, '1,2,3',O1, '1,2,3;*')
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: [] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 0-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;[  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<br></span>

On the other hand, due to the different normalization convention of rank-2 tensors, the contraction of two identity operators, with all the legs contracted, becomes the Hilbert space dimension.
```matlab
contract(I.E, '1,2',I.E, '1,2;*')
```
<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: [] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 0-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;[  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<br></span>


## Outer multiplicity

When non-Abelian symmetry is used, it is possible that there are multiple sectors with the same quantum numbers, while different sectors are indeed associated with different (orthogonal) Clebsch-Gordan coefficients. It is called **outer multiplicity**. One simple example is:


```matlab
[S,I] = getLocalSpace( 'Spin',1/2);
A1 = getIdentity(I.E,2,I.E,2);
A2 = getIdentity(A1,3,I.E,2);
A12 = contract(A1, '3',A2, '1')
```

<span style="font-family: monospace; font-size:.85em">A12 = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: 3x [1 1 1 1] having 'SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ , , , * }&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 4-D double (352 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 x 1 x 1 x 3 => 2 x 2 x 2 x 8<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1x1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ; 1 ; 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. 1x1x1x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x2x2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ; 1 ; 1 ]&nbsp;&nbsp;16 B&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. 1x1x1x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;2x2x2x4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 1 ; 1 ; 1 ; 3 ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<br>
</span>
The first and second sectors have the same quantum numbers! But, of course, they are orthogonal. Consider their parts:

```matlab
A12a = getsub(A12,1);
A12a.data{1} = 1;
A12b = getsub(A12,2);
A12b.data{1} = 1;
```


Here we replaced the reduced matrix elements (<span style="font-family: monospace; font-size:.85em">.data{..}</span>) with ones, to focus on the Clebsch-Gordan coefficients. Then their overlap, i.e., contraction between <span style="font-family: monospace; font-size:.85em">A12a</span> and the conjugate of <span style="font-family: monospace; font-size:.85em">A12b</span> vanishes.

```matlab
contract(A12a,'1234',A12b, '1234*');
```
<span style="font-family: monospace; font-size:.85em">ans = (empty QSpace)
</span>

On the other hand, three incoming legs (from the first to the third) look identical, so it seems that the tensor remains the same after permuting the incoming legs. But it's not! The overlap with <span style="font-family: monospace; font-size:.85em">A12a</span> and the permutation of the first and third legs of <span style="font-family: monospace; font-size:.85em">A12a</span> is **not unity**. It means that the Clebsch-Gordan coefficients can change by permuting legs.

```matlab
contract(A12a,'1234',A12b, '3214*'); % note the 4th input
```

<span style="font-family: monospace; font-size:.85em">ans = <br>
&nbsp;&nbsp;&nbsp;&nbsp;Q: [] having 'A,SU2',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;data: 0-D double (112 bytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. 1x1&nbsp;&nbsp;&nbsp;[  ]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5<br></span>

Why? Let's draw the tensor network diagram for the first and second sectors of <span style="font-family: monospace; font-size:.85em">A12</span>.

<p align="center">
  <img src="../images/image_7.png" alt="Alt Text" width = "40%">
</p>
Attached to the legs are spin quantum numbers. Fusing two $S=1/2$ (two incoming legs of <span style="font-family: monospace; font-size:.85em">A1</span>) lead to two values of spin $S=0\oplus 1$ (outgoing leg of <span style="font-family: monospace; font-size:.85em">A1</span>). These two values can result in $S=1/2$ (outgoing leg of <span style="font-family: monospace; font-size:.85em">A2</span>) by being fused with one $S=1/2$ (bottom incoming leg of <span style="font-family: monospace; font-size:.85em">A2</span>). The outer multiplicity of <span style="font-family: monospace; font-size:.85em">A12</span> reflects this two different ways of having four legs of $S=1/2$. In this diagram, it is clear to see that the left leg of <span style="font-family: monospace; font-size:.85em">A1</span> and the bottom leg of <span style="font-family: monospace; font-size:.85em">A2</span> are not equivalent.

&nbsp;
