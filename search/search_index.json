{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is QSpace?","text":"<p>QSpace is an advanced open-source tensor library specifically designed to handle both Abelian and non-Abelian symmetries. Embedded in C++ and interfaced with Matlab, QSpace facilitates quantum symmetry spaces in tensor network states. Its capabilities allow users to exploit a variety of symmetries, including the U(1) and special unitary groups, making it versatile for different operations across symmetries. QSpace's design emphasizes a bottom-up approach, starting from the defining representation and utilizing Clebsch-Gordan coefficient tensors. This approach makes QSpace a powerful tool for developing tensor network algorithms, providing a user-friendly environment while handling complex symmetry details.</p>"},{"location":"Linux/","title":"Installation on Linux","text":""},{"location":"Linux/#sec:linux_ml","title":"Install MATLAB","text":"<p>QSpace is a library running on MATLAB, so one needs a MATLAB installation. For the current QSpace distribution (v4.0), we recommend to use MATLAB R2020b or later, because of MEX compilers. Older MATLAB versions might work, but no guarantee.</p>"},{"location":"Linux/#sec:linux_gmp_mpfr","title":"Install <code>gmp</code> and <code>mpfr</code>","text":"<p>QSpace uses <code>gmp</code> and <code>mpfr</code>, multiprecision arithmetics libraries, in generating and manipulating the Clebsch-Gordan coefficient tensors. However, a standard installation of Linux may not have <code>gmp</code> and <code>mpfr</code> installed.</p>"},{"location":"Linux/#sec:linux_gmp","title":"Install <code>gmp</code>","text":"<p>If you are not sure whether <code>gmp</code> is installed in your device, type in the terminal:</p> <pre><code>dpkg -s libgmp-dev\n</code></pre> <p>If the command works, showing the installed version of <code>gmp</code>, then you can skip the rest of this subsection and move forward to Install <code>mpfr</code>.</p> <p>When the terminal says <code>package 'libgmp-dev' is not installed</code>, then you can install <code>gmp</code> by typing the following command.</p> <pre><code>sudo apt-get install libgmp-dev\n</code></pre>"},{"location":"Linux/#sec:linux_mpfr","title":"Install <code>mpfr</code>","text":"<p>If you are not sure whether <code>mpfr</code> is installed in your device, type in the terminal:</p> <pre><code>dpkg -s libmpfr-dev\n</code></pre> <p>If the command works, showing the installed version of <code>mpfr</code>, then you can skip the rest of this subsection and move forward to Retrieve QSpace files.</p> <p>When the terminal says <code>package 'libmpfr-dev' is not installed</code>, then you can install <code>mpfr</code> by typing the following command.</p> <pre><code>sudo apt-get install libmpfr-dev\n</code></pre>"},{"location":"Linux/#sec:linux_qs","title":"Retrieve QSpace files","text":"<p>There is a separate Git repository for the QSpace codes for Linux. If you know how to use Git, then you can proceed with cloning the repository. If you don't know, then visit the repository webpage and click Clone, which will lead you a dialogue window showing the command:</p> <pre><code>git clone https://bitbucket.org/qspace4u/qspace-v4-pub.git\n</code></pre> <p>Then go to a directory under which the copied Git repository data will be stored. Move to the directory, and run the command above in your terminal. Then the repository will be cloned to a sub-directory under your current working directory.</p>"},{"location":"Linux/#mex-compile-source-codes","title":"MEX-compile source codes","text":"<p>The QSpace distribution for Linux does not include MEX binaries, contrary to that for macOS, so one needs to compile C++ source codes. For this one needs to install <code>gcc</code> or, if your system uses a module system, load a <code>gcc</code> module. One can check which versions of <code>gcc</code> are supported by a specific MATLAB version here.</p> <p>If you are not sure whether <code>gcc</code> is installed in your device, type in the terminal:</p> <pre><code>gcc \u2013version\n</code></pre> <p>If the command works, showing the installed version of <code>gcc</code>, then move forward to the next paragraph. If the command does not show the installed version of <code>gcc</code>, then you can install <code>gcc</code> by typing the following command.</p> <pre><code>sudo apt install gcc\n</code></pre> <p>If the <code>gcc</code> version installed in your device is not supported by MATLAB, you have to install the supported version of <code>gcc</code>. As an example, If the <code>gcc</code> of version 11 is installed and MATLAB supports only the <code>gcc</code> of version 9, you can install <code>gcc</code> of version 9 by typing following commands.</p> <pre><code>sudo apt install build-essential\nsudo apt-get install -y gcc-9\ncd /usr/bin\nsudo rm gcc\nsudo ln -s gcc-9 gcc\n</code></pre> <p>To check the current version of <code>gcc</code>, type in the terminal:</p> <pre><code>gcc \u2013version\n</code></pre> <p>If you want to roll back to the <code>gcc</code> of version 11, type in the terminal:</p> <pre><code>cd /usr/bin\nsudo rm gcc\nsudo ln -s gcc-11 gcc\n</code></pre> <p>To check the current version of <code>gcc</code>, type in the terminal:</p> <pre><code>gcc \u2013version\n</code></pre> <p>Our QSpaceTutorial package offers a simple way to compile the source codes. First, open a MATLAB session. Then run the function <code>Util/compile.m</code>. That's it!</p> <p>The remaining step before using the <code>QSpace</code> library is to set environment variables and paths; see Set environment variables and paths.</p>"},{"location":"Linux/#sec:startup","title":"Set environment variables and paths","text":""},{"location":"Linux/#set-rc_store","title":"Set <code>RC_STORE</code>","text":"<p><code>RC_STORE</code> is the only environment variable that needs to be set by users, to execute the QSpace functions (both <code>.m</code> and <code>MEX</code>). This variable specifies the paths to place the database of Clebsch--Gordan coefficient tensor (CGT) data, which is generated and read on the fly during calculations. Those CGT data can be reused for different calculations, which provides a great computational advantage.</p> <p><code>RC_STORE</code> can be defined by multiple paths glued with <code>:</code>, e.g., <code>path1:path2:path3</code>. When there are \\(n\\) paths, then the functions look up CGT data from the first path, then the second, and so on. If the CGT data of interest are not created yet, then QSpace generates and store them in the last path. When \\(n &gt; 1\\), the paths except for the last are read-only.</p> <p>Since CGTs are used to define the symmetry multiplet basis to represent physical tensors, it is important to have consistent CGT database. Especially, when running on a computing cluster, the database consistency among different jobs is essential. Therefore, a recommended choice of <code>RC_STORE</code> for clusters is <code>path1:path2</code>, where <code>path1</code> is the path for the \"global\" database to be looked up by all cluster jobs and <code>path2</code> is a job-dependent path that refers to the \"local\" increment specific to a job. If the global database is large enough, the local increment will remain small. On the other hand, for laptops and desktops, such distinction might be an overkill; one can simply set <code>RC_STORE</code> as a single path.</p>"},{"location":"Linux/#modify-startupm","title":"Modify <code>startup.m</code>","text":"<p><code>startup.m</code> is a script that is first executed upon starting up a MATLAB session, so that important environment variables and paths are set before use. This <code>QSpaceTutorial</code> as well as <code>MuNRG</code> have own <code>startup.m</code> that should be modified by users regarding those environment variables. Mostly such variables are for paths that depend on computing systems. Please follow the instruction in <code>startup.m</code> to set the environment variables properly.</p>"},{"location":"Linux/#troubleshooting","title":"Troubleshooting","text":"<p>In the following, some known issues regarding QSpace and their workarounds are given.</p>"},{"location":"Linux/#make-command-not-found","title":"make: command not found","text":"<p>When you try to compile QSpace, MATLAB might show the following error message.</p> <pre><code>/bin/bash: line 1: make: command not found\n</code></pre> <p>This error occurs if Linux does not have <code>make</code>, a tool which controls the generation of executables from source files, installed.</p> <p>To resolve this error, install <code>make</code> by typing the following command.</p> <pre><code>sudo apt install make\n</code></pre>"},{"location":"Linux/#invalid-mex-file-glibcxx-not-found","title":"Invalid MEX file, GLIBCXX not found","text":"<p>When you try to use QSpace, MATLAB might complain that the MEX files are not valid and show the following error message.</p> <pre><code>Invalid MEX-file\n\u2018/home/Document/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64\u2019:\n/usr/local/MATLAB/R2022a/bin/glnxa64/../../sys/os/glnxa64/libstdc++.so.6: version\n\u2018GLIBCXX_3.4.29\u2019 not found (required by\n/home/Document/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64)\n</code></pre> <p>To resolve this error, try following commands in the terminal.</p> <pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test`\nsudo apt-get update\nsudo apt-get install gcc-4.9\nsudo apt-get upgrade libstdc++6\n</code></pre> <p>Then, recomplie the sourse code by running the function <code>Util/compile.m</code> again.</p> <p>If MATLAB still complains, then copy and paste the file <code>libstdc++.so.6</code> at the directory <code>/usr/local/MATLAB/R2022a/sys/os/glnxa64</code> by using the following a single command.</p> <pre><code>sudo cp /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/local/MATLAB/R2022a/sys/os/glnxa64/\n</code></pre> <p>Note that the directory depends on your MATLAB version, e.g., if you are using MATLAB R2021b, then type the following single command instead.</p> <pre><code>sudo cp /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/local/MATLAB/R2021b/sys/os/glnxa64/\n</code></pre> <p>Then, recomplie the sourse code by running the function <code>Util/compile.m</code> again.</p> <p> </p>"},{"location":"contribg/","title":"How to Contribute","text":""},{"location":"contribg/#introduction","title":"Introduction","text":"<p>When contributing to our this documentation, it's crucial to adhere to a structured Git branching strategy. This ensures that the codebase remains stable and manageable, allowing for efficient development and release processes.</p>"},{"location":"contribg/#branching-strategy","title":"Branching Strategy","text":"<p>We use three types of branches in our workflow:</p> <ol> <li>Main Branch: Reserved for production releases.</li> <li>Develop Branch: Used for integrating new contents and fixes.</li> <li>Contributor-Specific Branch (e.g., <code>&lt;name&gt;</code>): For individual contributors to create new contents or fixes.</li> </ol>"},{"location":"contribg/#why-this-strategy","title":"Why This Strategy?","text":"<ul> <li>Stability: By restricting direct pushes to the <code>main</code> branch, we ensure that only thoroughly reviewed contents get deployed.</li> <li>Continuous Integration: The <code>develop</code> branch serves as an integration point, allowing for regular testing and early detection of conflicts.</li> <li>Ownership and Isolation: Contributor-specific branches allow contributors to work independently on their tasks without interfering with others' work.</li> </ul>"},{"location":"contribg/#workflow-steps-and-git-commands","title":"Workflow Steps and Git Commands","text":""},{"location":"contribg/#1-setup-your-workspace","title":"1. Setup Your Workspace","text":"<p>Before you start, ensure you have the latest version of the <code>develop</code> branch.</p> <pre><code>git checkout develop\ngit pull origin develop\n</code></pre>"},{"location":"contribg/#2-create-your-contributor-specific-branch","title":"2. Create Your Contributor-Specific Branch","text":"<p>Create a new branch for your work. Replace <code>&lt;name&gt;</code> with your branch name.</p> <pre><code>git checkout -b &lt;name&gt;\n</code></pre>"},{"location":"contribg/#3-implement-your-changes","title":"3. Implement Your Changes","text":"<p>Make your changes, commit them to your branch. Replace <code>&lt;commit-message&gt;</code> with a meaningful description of your changes.</p> <pre><code># Add files to the staging area\ngit add .\n\n# Commit changes\ngit commit -m \"&lt;commit-message&gt;\"\n</code></pre>"},{"location":"contribg/#4-keep-your-branch-updated","title":"4. Keep Your Branch Updated","text":"<p>Regularly update your branch with changes from the <code>develop</code> branch to avoid conflicts later.</p> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout &lt;name&gt;\ngit merge develop\n</code></pre> <p>Resolve any conflicts that arise from the merge.</p>"},{"location":"contribg/#5-finalizing-your-contribution","title":"5. Finalizing Your Contribution","text":"<p>Once your contents or fixes are complete:</p> <ul> <li>Pull the latest <code>develop</code> branch.</li> <li>Merge it into your branch.</li> <li>Solve any conflicts.</li> </ul> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout &lt;name&gt;\ngit merge develop\n</code></pre>"},{"location":"contribg/#6-merge-back-to-develop","title":"6. Merge Back to Develop","text":"<p>After resolving conflicts and ensuring the local website works as expected, merge your branch back to <code>develop</code>.</p> <pre><code>git checkout develop\ngit merge &lt;name&gt;\n</code></pre>"},{"location":"contribg/#7-push-to-develop","title":"7. Push to Develop","text":"<p>Push your changes to the remote <code>develop</code> branch. Your code will be reviewed before merging.</p> <pre><code>git push origin develop\n</code></pre>"},{"location":"contribg/#8-code-review-and-testing","title":"8. Code Review and Testing","text":"<p>Once pushed, your code will undergo review and testing by peers and CI tools.</p> <p>Note</p> <p>The <code>main</code> branch is off-limits for direct contributions. It is exclusively managed by the administrator for stable releases.</p> <p>This workflow, while structured, ensures that our codebase remains clean, stable, and manageable. By following these guidelines, you contribute not only code but also to the overall health and quality of the project.</p> <p> </p>"},{"location":"installation/","title":"Installation","text":"<p>[TODO]</p>"},{"location":"iterdiag/","title":"Iterative Diagonalization","text":"<p>[TODO]</p>"},{"location":"macOS/","title":"Installation on macOS","text":""},{"location":"macOS/#sec:mac_ml","title":"Install MATLAB","text":"<p>QSpace is a library running on MATLAB, so we need a MATLAB installation. For the current QSpace distribution (v4.0), we recommend to use MATLAB R2020b or later, since the provided binaries are compiled with R2020b. Older MATLAB versions might work, but no guarantee.</p>"},{"location":"macOS/#sec:mac_gmp","title":"Install <code>gmp</code>","text":"<p>QSpace uses <code>gmp</code>, a multiprecision arithmetics library, in generating and manipulating the Clebsch-Gordan coefficient tensors. However, a standard installation of macOS may not have <code>gmp</code> installed. If you are not sure whether it's installed in your device, type in the terminal:</p> <pre><code>brew info gmp\n</code></pre> <p>If the command works, showing the installed version of <code>gmp</code>, then you can skip the rest of this subsection and move forward to Retrieve QSpace files.</p> <p>When the command above fails, there are two possibilities.</p> <ul> <li> <p>If the terminal says <code>command not found: brew</code>, then <code>homebrew</code> is     missing. You can install <code>homebrew</code> by typing the following as a     single command in the terminal.</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Then take the next step to install <code>gmp</code>.</p> </li> <li> <p>If the terminal says \"Error: No available formula or cask\", then     <code>homebrew</code> is installed, while <code>gmp</code> is not. You can simply install     <code>gmp</code> by the terminal command</p> <pre><code>brew install gmp\n</code></pre> <p>For more information, refer to here.</p> </li> </ul>"},{"location":"macOS/#sec:mac_qs","title":"Retrieve QSpace files","text":"<p>There is a separate Git repository for the QSpace codes for macOS. If you know how to use Git, then you can proceed with cloning the repository. If you don't know, then visit the repository webpage and click \"Clone\", which will lead you a dialogue window showing the command:</p> <pre><code>git clone https://bitbucket.org/qspace4u/qspace-v4-osx12-monterey.git\n</code></pre> <p>Then go to a directory under which the copied Git repository data will be stored. Move to the directory, and run the command above in your terminal. Then the repository will be cloned to a sub-directory under your current working directory.</p> <p>The QSpace distribution for macOS already includes pre-compiled MEX binaries (<code>.mexmaci64</code>), so the current QSpace installation is almost ready to use. (Since the MEX-compilation in macOS is a bit more involved compared to Linux, Andreas W.\u00a0kindly provides the binaries together.) The remaining step is to set environment variables and paths; see Set environment variables and paths.</p>"},{"location":"macOS/#sec:startup","title":"Set environment variables and paths","text":""},{"location":"macOS/#set-rc_store","title":"Set <code>RC_STORE</code>","text":"<p><code>RC_STORE</code> is the only environment variable that needs to be set by users, to execute the QSpace functions (both <code>.m</code> and <code>MEX</code>). This variable specifies the paths to place the database of Clebsch--Gordan coefficient tensor (CGT) data, which is generated and read on the fly during calculations. Those CGT data can be reused for different calculations, which provides a great computational advantage.</p> <p><code>RC_STORE</code> can be defined by multiple paths glued with <code>:</code>, e.g., <code>path1:path2:path3</code>. When there are \\(n\\) paths, then the functions look up CGT data from the first path, then the second, and so on. If the CGT data of interest are not created yet, then QSpace generates and store them in the last path. When \\(n &gt; 1\\), the paths except for the last are read-only.</p> <p>Since CGTs are used to define the symmetry multiplet basis to represent physical tensors, it is important to have consistent CGT database. Especially, when running on a computing cluster, the database consistency among different jobs is essential. Therefore, a recommended choice of <code>RC_STORE</code> for clusters is <code>path1:path2</code>, where <code>path1</code> is the path for the \"global\" database to be looked up by all cluster jobs and <code>path2</code> is a job-dependent path that refers to the \"local\" increment specific to a job. If the global database is large enough, the local increment will remain small. On the other hand, for laptops and desktops, such distinction might be an overkill; one can simply set <code>RC_STORE</code> as a single path.</p>"},{"location":"macOS/#modify-startupm","title":"Modify <code>startup.m</code>","text":"<p><code>startup.m</code> is a script that is first executed upon starting up a MATLAB session, so that important environment variables and paths are set before use. This <code>QSpaceTutorial</code> as well as <code>MuNRG</code> have own <code>startup.m</code> that should be modified by users regarding those environment variables. Mostly such variables are for paths that depend on computing systems. Please follow the instruction in <code>startup.m</code> to set the environment variables properly.</p>"},{"location":"macOS/#troubleshooting","title":"Troubleshooting","text":"<p>In the following, some known issues regarding QSpace and their workarounds are given.</p>"},{"location":"macOS/#mex-files-cannot-be-opened-because-the-developer-cannot-be-verified","title":"MEX files cannot be opened because the developer cannot be verified","text":"<p>When you try to use QSpace, some higher version of macOS might complain that the developer of the MEX function binaries not verified, so it cannot run them. One can solve this issue as follows. First, type the command</p> <pre><code>sudo xattr -r -d com.apple.quarantine ~/Documents/MATLAB/QSpace_v4.0\nsudo find ~/Documents/MATLAB/QSpace_v4.0 -name \\`$\\ast$`.mexmaci64 -exec spctl \u2013add {} \\;\n</code></pre> <p>Note that the last command line is a single line so make the command as a single line if it is divided. For more information, refer to here.</p>"},{"location":"macOS/#invalid-mex-file-library-not-loaded","title":"Invalid MEX file, Library not loaded","text":"<p>If your Mac uses the Apple silicon chip, such as the M1 or M2 chips, MATLAB might complain that the MEX files are not valid and show the following error message.</p> <pre><code>Invalid MEX-file\n\u2018~/Documents/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64\u2019:\ndlopen(~/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64, 0x0006): Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib\nReferenced from: ~/Documents/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64\nReason: tried: \u2019/usr/local/opt/gmp/lib/libgmp.10.dylib\u2019 (mach-o file, but is an incompatible architecture (have \u2019arm64\u2019, need \u2019x86_64\u2019)), \u2019/usr/local/lib/libgmp.10.dylib\u2019 (mach-o file, but is an incompatible architecture (have \u2019arm64\u2019, need \u2019x86_64\u2019)), \u2019/usr/lib/libgmp.10.dylib\u2019 (no such file)`\n</code></pre> <p>It happens because the Apple silicon chips are ARM64 CPUs while the <code>MEX</code> file is compiled for a x86-64 CPU.</p> <p>To resolve this error, download the <code>gmp.zip</code> here and move the folder <code>gmp</code> to <code>~/Documents</code>. Then, type the following command.</p> <pre><code>ln -s ~/Documents/gmp /usr/local/opt/\n</code></pre> <p>This command generates a symbolic link to <code>gmp</code>. To remove the link, type the following command.</p> <pre><code>rm /usr/local/opt/gmp\n</code></pre> <p>If macOS complains that <code>libgmp.10.dylib</code> is not verified, then try the following commands on the terminal:</p> <pre><code>sudo xattr -r -d com.apple.quarantine /usr/local/opt/gmp/lib/\nsudo find /usr/local/opt/gmp/lib/ -name \\`$\\ast$`.dylib -exec spctl \u2013add {} \\;\n</code></pre> <p>If macOS still complains, go to <code>System Settings...</code> \\(\\rightarrow\\) <code>Security &amp; Privacy</code> \\(\\rightarrow\\) click 'Open Anyway' for <code>libgmp.10.dylib</code>.</p> <p> </p>"},{"location":"mdref/","title":"Markdown Syntax Guide","text":"<p>Welcome to the world of Markdown! Markdown is a simple way to format text that can be easily converted to HTML. It's widely used in writing for the web, documentation, and much more. This guide will help you understand the basics of Markdown formatting.</p>"},{"location":"mdref/#headings","title":"HeadingsHeading","text":"<p>Headings are used to structure your document. Markdown supports six levels of headings, which are created with <code>#</code> symbols:</p> MarkdownRendered Result <pre><code># h1 Heading\n## h2 Heading\n### h3 Heading\n#### h4 Heading\n</code></pre> <p>Heading Heading Heading</p> <p>Just add the number of <code>#</code> symbols corresponding to the level of heading you want.</p>"},{"location":"mdref/#horizontal-rules","title":"Horizontal Rules","text":"<p>To create a thematic break or a horizontal rule, use three or more dashes, e.g. <code>---</code> renders as:</p> <p>This is typically used to signify a major topic change in your document.</p>"},{"location":"mdref/#emphasis","title":"Emphasis","text":"<p>To emphasize text, you can use bold or italic formatting:</p> <p>Bold: Wrap your text with two asterisks or underscores.</p> MarkdownRendered Result <pre><code>**This is bold text**\n__This is also bold__\n</code></pre> <p>This is bold text This is also bold</p> <p>Italic: Wrap your text with one asterisk or underscore.</p> MarkdownRendered Result <pre><code>*This is italic text*\n_This is also italic_\n</code></pre> <p>This is italic text This is also italic</p>"},{"location":"mdref/#blockquotes","title":"Blockquotes","text":"<p>Blockquotes are used for quoting text from another source. Use the <code>&gt;</code> symbol:</p> MarkdownRendered Result <pre><code>&gt; Blockquotes can also be nested...\n&gt;&gt; ...by using additional greater-than signs right next to each other...\n&gt; &gt; &gt; ...or with spaces between arrows.\n</code></pre> <p>Blockquotes can also be nested...</p> <p>...by using additional greater-than signs right next to each other...</p> <p>...or with spaces between arrows.</p>"},{"location":"mdref/#lists","title":"Lists","text":"<p>Lists are a great way to organize information.</p> <p>Unordered Lists: Start a line with <code>+</code>, <code>-</code>, or <code>*</code>:</p> MarkdownRendered Result <pre><code>+ Item 1\n+ Item 2\n- Subitem 2.1\n- Subitem 2.2\n</code></pre> <ul> <li>Item 1</li> <li>Item 2</li> <li>Subitem 2.1</li> <li>Subitem 2.2</li> </ul> <p>Ordered Lists: Use numbers followed by a period:</p> MarkdownRendered Result <pre><code>1. First item\n2. Second item\n3. Third item\n</code></pre> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol> <p>You can also use the same number to let Markdown handle the numbering:</p> MarkdownRendered Result <pre><code>1. Item\n1. Item\n1. Item\n</code></pre> <ol> <li>Item</li> <li>Item</li> <li>Item</li> </ol>"},{"location":"mdref/#code","title":"Code","text":"<p>There are several ways to represent code in Markdown.</p> <ul> <li>Inline Code: For small bits of code, use backticks:</li> </ul> <p>This is an inline <code>code</code> example.</p> <ul> <li>Indented Code: Indent your code by four spaces or a tab for block code:</li> </ul> <pre><code>    This is a block of code.\n</code></pre> <ul> <li>Fenced Code Blocks: Use triple backticks and optionally specify the language for syntax highlighting:</li> </ul> <pre><code>import tensorflow as tf\n</code></pre>"},{"location":"mdref/#equations","title":"Equations","text":"<p>MathJax allows you to display mathematical notation in Markdown documents. With MathJax, you can write complex mathematical expressions using LaTeX syntax. To use MathJax in your document, you have two main options: inline math and display math.</p> <ul> <li>Inline Math: For inline mathematical expressions, enclose your LaTeX code within single dollar signs <code>$</code>. This method is used when you want to include math expressions within a line of text.</li> </ul> MarkdownRendered Result <pre><code>$E = mc^2$\n</code></pre> <p>\\(E = mc^2\\)</p> <ul> <li>Display Math: For larger expressions or equations that you want to display on their own line, use double dollar signs <code>$$</code> to enclose your LaTeX code. This centers the math expression and puts it on a new line.</li> </ul> MarkdownRendered Result <pre><code>$$\n\\begin{align*}\na^2 + b^2 &amp;= c^2 \\\\\ne^{i\\pi} + 1 &amp;= 0\n\\end{align*}\n$$\n</code></pre> \\[ \\begin{align*} a^2 + b^2 &amp;= c^2 \\\\ e^{i\\pi} + 1 &amp;= 0 \\end{align*} \\] <p>Remember, for complex LaTeX expressions, ensure that your syntax is correct as MathJax will render exactly what is written within the delimiters.</p>"},{"location":"mdref/#tables","title":"Tables","text":"<p>Create tables using dashes <code>-</code> for headers and pipes <code>|</code> for columns:</p> MarkdownRendered Result <pre><code>| Header 1 | Header 2 |\n| -------- | -------- |\n| Row 1    | Data     |\n| Row 2    | Data     |\n</code></pre> Header 1 Header 2 Row 1 Data Row 2 Data <p>To align columns, use colons <code>:</code> in the header row:</p> MarkdownRendered Result <pre><code>| Left Aligned | Right Aligned | Center Aligned |\n| :----------- | ------------: | :------------: |\n| left         |         right |     center     |\n</code></pre> Left Aligned Right Aligned Center Aligned left right center"},{"location":"mdref/#links-and-images","title":"Links and Images","text":"<ul> <li>Links: To create a link, wrap the link text in brackets <code>[ ]</code>, followed by the URL in parentheses <code>( )</code>:</li> </ul> MarkdownRendered Result <pre><code>This is a link to the [Google Website](https://www.google.com)\n</code></pre> <p>This is a link to the Google Website</p> <p>For a link with a title, add the title in quotes after the URL:</p> MarkdownRendered Result <pre><code>This is a link to the [Google Website](https://www.google.com \"Google Homepage\")\n</code></pre> <p>This is a link to the Google Website</p> <ul> <li>Images: Similar to links, but start with an exclamation mark <code>!</code>:</li> </ul> MarkdownRendered Result <pre><code>&lt;figure markdown&gt;\n  ![Alt text](../assets/QSpace.png){ width=\"300\" }\n&lt;/figure&gt;\n</code></pre> <p> </p>"},{"location":"mdref/#extended-syntax-and-functionalities","title":"Extended Syntax and Functionalities","text":"<p>In our documentation, we leverage Markdown extensions to enrich the standard Markdown syntax. These extensions are invaluable for adding advanced formatting and interactive elements that are not possible with basic Markdown. They are particularly useful in creating comprehensive and user-friendly documentation, allowing for more engaging and organized content.</p> <p>For example, extensions enable the inclusion of tabbed content, detailed footnotes, custom admonition blocks, and enhanced code blocks with syntax highlighting. To explore the full range of possibilities these extensions offer, and for detailed syntax reference, please visit MkDocs Material Extensions Reference.</p> <p> </p>"},{"location":"mkdocsg/","title":"Comprehensive MkDocs Guide","text":""},{"location":"mkdocsg/#introduction-to-mkdocs","title":"Introduction to MkDocs","text":""},{"location":"mkdocsg/#what-is-mkdocs","title":"What is MkDocs?","text":"<p>MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file.</p>"},{"location":"mkdocsg/#key-features","title":"Key Features","text":"<ul> <li>Ease of Use: MkDocs is straightforward to set up. All you need is your documentation in Markdown format. No database is required.</li> <li>Theme Support: MkDocs comes with a built-in theme. Additional themes can be installed via <code>pip</code>. This site is built with the Material for MkDocs theme.</li> <li>Host Anywhere: MkDocs builds completely static HTML sites that you can host on GitHub pages, Amazon S3, or anywhere else you choose.</li> <li>Markdown Centric: Focus on your project's documentation and not on the tooling to make your documentation work. Additional features can be incorporated via extensions.</li> </ul>"},{"location":"mkdocsg/#mkdocs-directory-structure","title":"MkDocs Directory Structure","text":"<p>When you create a new project, MkDocs will automatically create the a directory structure and files. If you pull this repository, the directory structure is already set up, which looks like this:</p> Directory Structure<pre><code>project_name/\n\u2502\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md    # The main documentation page.\n\u2502   \u2514\u2500\u2500 ...         # Other markdown pages for your documentation.\n\u2502\n\u2514\u2500\u2500 mkdocs.yml      # The MkDocs configuration file.\n</code></pre> <ul> <li><code>docs/</code>: This directory contains all your documentation in Markdown format.</li> <li><code>mkdocs.yml</code>: This is the configuration file for your MkDocs site.</li> </ul> <p>Note</p> <p>It is possible to have subdirectories within the <code>docs/</code> directory. This is useful for organizing the documentation into sections. However, please inform the administrator if you plan to do this.</p>"},{"location":"mkdocsg/#mkdocs-yaml-configuration","title":"MkDocs YAML Configuration","text":"<p>The <code>mkdocs.yml</code> file is where you configure your documentation site. YAML, which stands for \"YAML Ain't Markup Language,\" is a human-readable data serialization format. YAML files typically end with the .yml or .yaml extension and use indentation to represent data hierarchies, making it visually clear and straightforward. This format is often preferred for writing configuration files, like those used in MkDocs.</p>"},{"location":"mkdocsg/#basic-configuration","title":"Basic Configuration:","text":"<ul> <li>site_name: Title of your documentation site.</li> <li>nav: Structure of your site's navigation.</li> </ul>"},{"location":"mkdocsg/#example-mkdocsyml","title":"Example <code>mkdocs.yml</code>:","text":"mkdocs.yml<pre><code>site_name: QSpace Documentation\nnav:\n    - Home: index.md\n    - About: about.md\n    - User Guide:\n        - Writing Docs: user-guide/writing.md\n        - Styling Docs: user-guide/styling.md\n</code></pre> <p>Warning</p> <p>You will see many more configuration options in the <code>mkdocs.yml</code> file in this repository. Please do not touch any of the settings other than the ones mentioned above. If you have any questions, please contact the administrator.</p>"},{"location":"mkdocsg/#installing-building-and-using-mkdocs","title":"Installing, Building, and Using MkDocs","text":"<p>Before you start building the project, you will need to create a Python virtual environment. A Python environment is a self-contained directory that holds a specific version of Python and a collection of Python packages. Think of it as an isolated workspace for Python projects, ensuring that each project has its own dependencies and settings, separate from other projects. This isolation prevents conflicts between project requirements and allows for more organized and manageable development. The most common tool for creating Python environments is venv, which is included in the Python Standard Library.</p>"},{"location":"mkdocsg/#create-a-python-virtual-environment","title":"Create a Python Virtual Environment:","text":"<pre><code>python -m venv venv\n</code></pre> <ul> <li><code>python -m venv</code>: This command tells Python to create a new virtual environment.</li> <li><code>venv</code>: This is the name of the virtual environment folder. You can name it anything, but <code>venv</code> is a common convention. The administrator highly recommends using this name for convenience in version control. If you strongly prefers another name, please ensure that this directory is excluded in your <code>.gitignore</code> file, and you should not commit your <code>.gitignore</code> file to the repository.</li> </ul> <p>Note</p> <p>This project has been tested for Python 3.10.11. The command to use may differ depending on the version and platform you are working with. In general, Python 3.10 and above should work without any issues.</p>"},{"location":"mkdocsg/#activatedeactivate-the-virtual-environment","title":"Activate/Deactivate the Virtual Environment:","text":"<p>The Python virtual environment can be activated using the following commands:</p> Linux/MacOSWindows <pre><code>source venv/bin/activate\n</code></pre> <ul> <li><code>source</code>: This command changes the current shell\u2019s environment to the one provided.</li> <li><code>venv/bin/activate</code>: This is the path to the activation script of the virtual environment. Running this script activates the virtual environment.</li> </ul> <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <ul> <li><code>.\\venv\\Scripts\\activate</code>: This command activates the virtual environment on Windows. The path differs slightly from Linux/MacOS.</li> </ul> <p>The Python virtual environment can be deactivated using the following command (same for both Linux/MacOS and Windows):</p> <pre><code>deactivate\n</code></pre> <p>Warning</p> <p>You must activate the virtual environment every time you start working with this project. Otherwise, you will be using the system Python environment, which may cause conflicts with the packages you install. Also, please remember to deactivate the virtual environment when you are done working with this project.</p>"},{"location":"mkdocsg/#install-mkdocs-and-dependencies","title":"Install MkDocs and Dependencies:","text":"<p>The required packages and relevant dependencies (together with the required version) are listed in the <code>requirements.txt</code> file. To install these packages, run the following command:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <ul> <li><code>pip install -r</code>: This command is used to install packages listed in <code>requirements.txt</code> from the Python Package Index (PyPI).</li> <li><code>requirements.txt</code>: This file includes all the packages and dependencies for the project. Please do not modify this file before consulting the administrator.</li> </ul>"},{"location":"mkdocsg/#start-the-mkdocs-server","title":"Start the MkDocs Server:","text":"<p>MkDocs allows you to preview your documentation as you work on it, by running the website locally on your computer. Every time you make changes to your documentation, you can see the changes in real time in your browser. To start the MkDocs server, run the following command:</p> <pre><code>mkdocs serve\n</code></pre> <ul> <li> <p><code>mkdocs serve</code>: This command starts a local server for your MkDocs site. It allows you to see your changes in real time as you work on your documentation.</p> </li> <li> <p>After running this command, MkDocs will start a web server accessible at <code>http://localhost:8000</code>. You can open this address in your web browser to see your documentation.</p> </li> </ul>"},{"location":"mkdocsg/#building-your-site","title":"Building Your Site:","text":"<pre><code>mkdocs build\n</code></pre> <ul> <li> <p><code>mkdocs build</code>: This command generates the static HTML files for your documentation. After running this command, you'll find these files in a folder named <code>site</code> within your project directory.</p> </li> <li> <p>The generated <code>site</code> directory can be hosted on any web server, GitHub Pages, or other hosting services for static sites.</p> </li> </ul> <p>By following these steps, you should be able to set up and use MkDocs in your local computers. If you have any questions, please contact the administrator Changkai Zhang at changkai.zhang@physik.lmu.de.</p> <p> </p>"},{"location":"examples/DMRG/DMRGHubbard2D/","title":"2D Hubbard Model","text":"<p>Complete source code can be downloaded from DMRG.</p> <pre><code>clear;\n\n%%% begin input parameters %%%\n\nt = 1; % nn-hopping amplitude\nt_ = -0.2; % nnn-hopping amplitude\nU = 8; % onsite repulsion\n\nwidth = 5; % width of cylinder\nheight = 4; % height of cylinder\nfPBC = true; % periodic boundary conditions along y\n\nsym = 'SU2'; % U(1)_{charge} x SU(2)_{spin}\n%sym = 'U1'; % U(1)_{charge} x U(1)_{spin}\n\nD = 2000; % MPS bond dimension\nw = ham.get_num_mpo_states( sym, height, fPBC, t_ );\nD_prime = floor(D/w);\nD_hat = D;\nD_tilde = floor(D/10);\n\nnum_sweeps = 1000; % number of sweeps\nnum_davidson = 3; % number of davidson steps\neps_davidson = 1e-10; % threshold for termination of davidson\nnum_zero = 1e-10; % numerical zero\n\n% pick type of optimization\n%opt_enum = 1; % twosite\nopt_enum = 2; % shrewd cbe \n\n%%% end input paramters %%%\n\nN = width*height;\nif strcmp(sym,'U1')\n    [F,Z,S,I] = getLocalSpace('FermionS','Acharge,Aspin');\nelse\n    [F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin');\nend\nlocal_space = {F,Z,S,I};\n\n% initialize tensor network\nnetwork = Network;\nnetwork.mps = ham.get_prod_state(N,sym);\nnetwork.mpo = ham.get_mpo( t, t_, U, sym, width, height, fPBC );\nnetwork.model_iden = I.E;\nnetwork.D = D;\nnetwork.D_prime = D_prime;\nnetwork.D_hat = D_hat;\nnetwork.D_tilde = D_tilde;\nnetwork.num_davidson = num_davidson;\nnetwork.eps_davidson = eps_davidson;\nnetwork.num_zero = num_zero;\nnetwork.num_zero = num_zero;\nnetwork.opt_enum = opt_enum;\nnetwork.timetracker = TimeTracker;\n\nfprintf(\"DMRG ground state calculation for the Hubbard model on a cylinder\\n\\n\");\n\nif strcmp(sym,'U1')\n    fprintf(\"Acharge,Aspin\\n\");\nelse\n    fprintf(\"Acharge,SU2spin\\n\");\nend\nif fPBC==1\n    fprintf(\"periodic boundary conditions in y\\n\");\nelse\n    fprintf(\"open boundary conditions in y\\n\");\nend\nfprintf(\"t: %.16f\\n\",t);\nfprintf(\"t_: %.16f\\n\",t_);\nfprintf(\"U: %.16f\\n\",U);\nfprintf(\"width: %i\\n\",width);\nfprintf(\"height: %i\\n\",height);\n\nfprintf(\"D: %i\\n\",D);\nfprintf(\"D_prime: %i\\n\",D_prime);\nfprintf(\"D_hat: %i\\n\",D_hat);\nfprintf(\"D_tilde: %i\\n\",D_tilde);\nfprintf(\"num_sweeps: %i\\n\",num_sweeps);\nfprintf(\"num_davidson: %.16f\\n\",num_davidson);\nfprintf(\"eps_davidson: %.16f\\n\",eps_davidson);\nfprintf(\"num_zero: %i\\n\",num_zero);\n\nif opt_enum==1\n    fprintf(\"twosite opt\\n\");\nend\nif opt_enum==2\n    fprintf(\"shrewd cbe opt\\n\");\nend\nfprintf(\"\\n\\n\");\n\n% contract from right to left in the beginning\nfor i=(N:-1:3)\n    network.env_contract(i,i+1);\nend\n\nif opt_enum==1\n    % sweep and optimize twosite\n    for i=(1:num_sweeps)\n        network.twosite_sweep(i);\n        network.print_time();\n        pid = sprintf('%i',feature('getpid'));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmRSS']);\n        fprintf(\"RSS: %i MB\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmHWM']);\n        fprintf(\"Peak RSS: %i MB\\n\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n    end\nelse\n    % sweep and optimize cbe-onesite\n    for i=(1:num_sweeps)\n        network.cbe_sweep(i);\n        network.print_time();\n        pid = sprintf('%i',feature('getpid'));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmRSS']);\n        fprintf(\"RSS: %i MB\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmHWM']);\n        fprintf(\"Peak RSS: %i MB\\n\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n    end\nend\n</code></pre>"},{"location":"examples/NRG/Ex_1CK/","title":"Ex 1CK","text":"<pre><code>% NRG calculation of spin-1/2 1-channel Kondo\n\nclear\n\nnum_threads_SL(10); % to use multiple cores\n\n% Hamiltonian parameter\nNC = 1;\nJ = 0.2;\nT = 1e-8;\n\n% NRG parameter\nLambda = 2;\nN = ceil(-2*log(T/10)/log(Lambda))+5;\nnz = 2;\nNkeep = 500;\n\n% % % % U(1) charge * SU(2) spin\n% Define operators\n[FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge,SU2spin','NC',NC);\n[Fs,Zs,Ss,Is] = setItag('s00','op',FF,ZF,SF,IF.E);\n[ZL,SL,IL] = setItag('L00','op',ZF,SF,IF.E);\n\n% project onto half-filled, spin-1/2 subspace\nIL = getsub(IL,find(IL.Q{1}(:,1) == 0));\nZ_L00 = getsub(ZL,find(ZL.Q{1}(:,1) == 0));\nA0 = getIdentity(IL,2,Is,2,'K00*',[1 3 2]);\n\nHSS = (2*J)*contract(SL,'!2*',Ss,[2 1 3 4]); % S*S interaction\nOp = [(contract(Fs,'!1',HSS,[3 4 1 5 2]) - contract(HSS,'!13',Fs)); SL];\ncflag = [1;-1]; % brackets in the correlation functions are fermionic (+1) or bosonic (-1)\nzflag = [1;0]; % operators are fermionic (1) or not (0)\n\nH0 = contract(A0,'!2*',{HSS,'!13',A0}) + 1e-40*getIdentity(A0,2); % impurity Hamiltonian\n\nff = doZLD([-1 1],[1 1],Lambda,N,nz,'Nfit',round(-2*log(1e-8)/log(Lambda)));\n\nAdisc = cell(1,1,nz,numel(Op));\nAcont = cell(1,numel(Op));\nAw0 = zeros(1,numel(Op),nz); % static susceptibilities\n\nfor itz = (1:nz)\n    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz}(2:end),FF,ZF,'Nkeep',Nkeep);\n    if itz == nz\n        [Es,Qs] = plotE(nrgdata);\n    end\n\n    nrgdata = getRhoFDM(nrgdata,T,'-v');\n    [odisc,Adiscz,sigmak,Aw0(1,:,itz)] = getAdisc(nrgdata,Op(:),Op(:),ZF,'Z_L00',Z_L00,'cflag',cflag,'zflag',zflag);\n    if numel(Op) &gt; 1\n        Adisc(:,:,itz,:) = Adiscz;\n    else\n        Adisc(:,:,itz,:) = {Adiscz};\n    end\nend\n\nfor ito = (1:numel(Op))\n    [ocont,Acont{1,ito}] = getAcont(odisc,mean(cell2mat(Adisc(:,:,:,ito)),3),sigmak,T/5,'alphaz',1/nz);\nend\n\n\nfigure;\nplot(ocont(ocont&gt;0),Acont{1}(ocont&gt;0)*(pi^2/2/2)); % /2 due to the sum over spin\nset(gca,'XScale','log');\ngrid on;\nxlabel('\\omega');\nylabel('T(\\omega)');\ntitle('Spin-1/2 + 1-channel: U(1) charge * SU(2) spin');\n\nfigure;\nplot(ocont(ocont&gt;0),Acont{2}(ocont&gt;0));\nset(gca,'XScale','log','YScale','log');\ngrid on;\nxlabel('\\omega');\nylabel('(-1/\\pi) Im \\chi (\\omega)');\n</code></pre>"},{"location":"examples/NRG/Ex_NonDiag/","title":"Ex NonDiag","text":"<pre><code>% Example: NRG calculation of an impurity model of spinless fermions in two\n% channels. Partcles can hop between the channels, leading to the\n% off-diagonal elements of the quadratic term at the impurity and of the\n% hybridization function.\n\nclear\n\nnum_threads_SL(10);\n\n% % Hamiltonian parameter\n% U = 0;\nU = 1;\n% epsd = eye(2)*(-U/2); % epsd is now matrix; it can have finite non-diagonal elements\nepsd = [-0.2,0.05*1i;-0.05*1i,-0.1]; % like this; it can also have complex elements\nGamma = 0.1;\nT = 1e-6;\n\n% NRG parameter\nLambda = 2;\nN = max(ceil(-2*log(T)/log(Lambda))+7,20);\nnz = 2;\nNkeep = 1000;\nETRUNC = inf(1,10);\nEtrunc = 9;\n% nrgdata = go('data/NRG/NRG');\n\n% % interleaved NRG (iNRG):\n% 'inrg' can be given as a row vector or a matrix; see the description of\n% an optional input 'inrg' to the 'doZLD' routine.\ninrg = [1,2];\n% inrg = [1,2;2,1]; % each row: a permutation of the iNRG sub-channels; to be averaged over different permutations\n% % ... or standard NRG (sNRG):\n% inrg = [];\n% % % % \n\n% frequency grid parametrizing the hybiridzation function. The function is\n% considered to vanish outside of the range [min(ozin), max(ozin)]. \nozin = [-1 1];\n\n% % matrix-valued hybridization functions evaluated on the 'ozin' grid\n% RhoV2in = (Gamma/pi)*repmat(reshape([1,0;0,1],[1 2 2]),[2 1 1]); % diagonal terms only\n% RhoV2in = (Gamma/pi)*permute(cat(3,[1,-1;-1,1],[1,1;1,1]),[3 1 2]); % with non-diagonal terms\nRhoV2in = (Gamma/pi)*permute(cat(3,[1,-1i;1i,1],[1,1;1,1]),[3 1 2]); % with complex non-diagonal terms\n\n% logarithmic discretization\nif ~isempty(inrg) % iNRG mode\n    [ff,gg,dff,dgg] = doZLD(ozin,RhoV2in,Lambda,N,nz,'inrg',inrg,'-zbound');\nelse % sNRG mode\n    [ff,gg,dff,dgg] = doZLD(ozin,RhoV2in,Lambda,N,nz);\nend\n\n% define operators for the impurity and (for sNRG) the chain sites. There\n% is only the total charge conservation (U(1) symmetry). For convenience,\n% we invoke the 'getLocalSpace' for spinful fermions without U(1) spin\n% symmetry, which is equivalent to the current problem up to relabelling\n% channel to spin.\n[FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge','NC',1);\n[FF,ZF,SF,EF] = setItag('s00','op',FF(:),ZF,SF(:),IF.E); % make FF as a column, for proper concatenation in defining the operator inputs to getAdisc\nNF = quadOp(FF,FF,[]); % particle number operator\n\n % operators for acting only on the Hilbert space involving single flavors;\n % to be used as the operators for the bath in the iNRG mode\n[Fp,Zp] = singleFZ(FF,ZF);\n\n% local quadratic term\nHepsd = QSpace;\nfor it1 = (1:numel(FF))\n    for it2 = (1:numel(FF))\n        Hepsd = Hepsd + epsd(it1,it2)*contract(FF(it1),'!2*',FF(it2));\n    end\nend\n\n% interaction term\nHU = (U/2)*sum(NF)*(sum(NF)-EF);\n\nA0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\nH0 = contract(A0,'!2*',{HU+Hepsd,'!1',A0}) + 1e-40*getIdentity(A0,2); % in the K00 basis\nFHU = QSpace(size(FF));\nfor ito = (1:numel(FF))\n    FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito)); % [FF,HU]\nend\n\n% indices for the first operator arguments of correlators\nOid1 = (1:numel(FF)).'+zeros(1,numel(FF));\nOid1 = Oid1(:);\n\n% indices for the second operator arguments of correlators\nOid2 = zeros(numel(FF),1)+(1:numel(FF));\nOid2 = Oid2(:);\n\nAdiscs = cell(numel(Oid1)*3,numel(ff)); % *3 is for three different correlators to compute the self-energy\nAdisc2sum = zeros(numel(FF),numel(FF),numel(ff)); % Hartree term in the self-energy, needed for Kugler's trick\nAconts = cell(numel(Oid1),3);\n\nfor itz = (1:numel(ff)) % for different z shifts and different iNRG permutations\n    % NOTE: Operator for the on-site energy term given to NRG_SL (say FL)\n    % is empty [], since the on-site terms will be generated from the\n    % annihilation operators FF or Fp when the Wilson chain parameters have\n    % non-diagonal terms.\n\n    if ~isempty(inrg) % iNRG mode\n        % iNRG sub-channel configuration for the current permutation\n        inrg_tmp = inrg(mod(itz-1,size(inrg,1))+1,:);\n\n        % NOTE: Input array of Z operators for NRG_SL should have one-to-one\n        % correspondence to the iNRG sub-channels (NOT to particle flavors). That\n        % is, Z(n) corresponds to the n-th sub-channel that contains ALL the\n        % particle flavors j such that inrg_tmp(j) == n. If a sub-channel contains\n        % more than one flavor, one may use 'chainSpace' routine to generate the Z\n        % operator for the sub-channel.\n        Zp2 = QSpace(1,max(inrg_tmp));\n        for ito = (1:max(inrg_tmp))\n            oktmp = (inrg_tmp == ito);\n            if sum(oktmp) == 1\n                Zp2(ito) = Zp(inrg_tmp == ito);\n            elseif sum(oktmp) &gt; 1\n                [~,Zp2(ito)] = chainSpace(Fp(oktmp),(1:sum(oktmp)),Zp(oktmp));\n            else\n                error(['ERR: no Z operator for iNRG sub-channel #',sprintf('%i',ito)]);\n            end\n        end\n\n        % % writing raw data onto a disk\n%         NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},Fp,Zp2,gg{itz},[], ...\n%             'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz}, ...\n%             'F0',FF,'iflag',inrg_tmp);\n\n        % % ... or memory-only mode\n        nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},Fp,Zp2,gg{itz},[], ...\n            'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz}, ...\n            'F0',FF,'iflag',inrg_tmp);\n\n\n        % NOTE: 'F0' for the particle operators at the impurity, 'iflag'\n        % denotes the permutation for the iNRG sub-channels.\n    else % sNRG mode\n%         nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},[], ...\n%             'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz});\n        NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},[], ...\n            'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz});\n    end\n\n    % % writing raw data onto a disk\n%     getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n\n    % % ... or memory-only mode\n    nrgdata = getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n\n    [odisc,Adiscs(:,itz),sigmak] = getAdisc(nrgdata, ...\n        [FF(Oid1);FHU(Oid1);FHU(Oid1)], ...\n        [FF(Oid2);FF(Oid2) ;FHU(Oid2)], ...\n        ZF);\n\n    Adisc2sum(:,:,itz) = reshape(cellfun(@(x) sum(x(:)), Adiscs(numel(Oid1)+(1:numel(Oid1)),itz)), numel(FF)*[1 1]);\nend\n\nfor ita = (1:size(Adiscs,1))\n    [ocont,Aconts{ita}] = getAcont(odisc,mean(cell2mat(reshape(Adiscs(ita,:),[1 1 size(Adiscs,2)])),3),sigmak,T/5,'alphaz',1/nz,'-v');\nend\n\nAconts = cell2mat(reshape(Aconts,[1 numel(FF)*[1 1] 3]));\nAdisc2sum = mean(Adisc2sum,3);\n\n% % R. Bulla's \"self-energy trick\"\n[SE1,Aimp1] = SEtrick(ocont,Aconts(:,:,:,1),Aconts(:,:,:,2),'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd);\n\n% % F. B. Kugler's symmetric estimator\n[SE2,Aimp2] = SEtrick(ocont,Aconts(:,:,:,1),Aconts(:,:,:,2),Adisc2sum,Aconts(:,:,:,3),'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd);\n\n\n%% draw figure\n\n% % color set (5 default + 2 new)\nclrs = {[0 .447 .741],[.85 .325 .098],[.773 .565 .061], ...\n        [.494 .184 .556],[.466 .674 .188],[.301 .745 .933], ...\n        [.635 .078 .184]};\n\nlegs = cell(0,1);\nfigure;\nhold on;\ncnt = 1;\nfor it1 = (1:numel(FF))\n    for it2 = (1:numel(FF))\n        plot(ocont,real(Aconts(:,it1,it2,1))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','--');\n        legs{end+1} = ['bare (',sprintf('%i,%i',[it1 it2]),'), real'];\n\n        plot(ocont,real(Aimp1(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-.');\n        legs{end+1} = ['Bulla (',sprintf('%i,%i',[it1 it2]),'), real'];\n\n        plot(ocont,real(Aimp2(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-');\n        legs{end+1} = ['Kugler (',sprintf('%i,%i',[it1 it2]),'), real'];\n\n        cnt = cnt+1;\n\n        plot(ocont,imag(Aconts(:,it1,it2,1))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','--');\n        legs{end+1} = ['bare (',sprintf('%i,%i',[it1 it2]),'), imag'];\n\n        plot(ocont,imag(Aimp1(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-.');\n        legs{end+1} = ['Bulla (',sprintf('%i,%i',[it1 it2]),'), imag'];\n\n        plot(ocont,imag(Aimp2(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-');\n        legs{end+1} = ['Kugler (',sprintf('%i,%i',[it1 it2]),'), imag'];\n\n        cnt = cnt+1;\n    end\nend\nhold off;\nlegend(legs(:));\nxlim([-1 1]);\nxlabel('\\omega');\nylabel('\\pi \\Gamma A (\\omega)');\n</code></pre>"},{"location":"examples/NRG/Ex_SIAM/","title":"Ex SIAM","text":"<pre><code>% Example: NRG calculation of SIAM\n\nclear\n\nnum_threads_SL(8); % set this in the beginning; otherwise an error message occurs due to missing multithreading environment\n\n% % System paramters\n% Impurity Hamiltonian parameters\nU = 0.2; % interaction strength\nepsd = -U/2; % on-site level\nB = 0; % Zeeman field at the impurity, along the z direction\n\nT = 1e-7; % system temperature\n\n% Hybridization function parametrized by the frequency grid 'ozin' and the\n% function value 'RhoV2in' evaluated at 'ozin'. Here consider a simple\n% box-shaped case.\nD = 1; % half-bandwidth\nGamma = 0.03; % hybridization strength\nozin = [-D;D];\nRhoV2in = (Gamma/pi)*[1;1]; % values outside of the 'ozin' grid are assumed to be zero\n\n% NRG parameter\nLambda = 2;\nN = max(ceil(-2*log(T/500)/log(Lambda)),20);\nnz = 2;\nNkeep = 500;\nEtrunc = 9;\nETRUNC = inf(1,20);\n\nisHDD = false; % true: write/read temporary raw data to/from the disk, false: raw data stay in the memory\nif isHDD\n    nrgdata = go('data/NRG/NRG'); % location to save the results in hard disk drive\nend\n\n[ff,gg,dff,dgg] = doZLD(ozin,RhoV2in,Lambda,N,nz,'Nfit',round(-2*log(1e-8)/log(Lambda)));\n\n% Symmetries to use\nsymstr = {'Acharge,Aspin'; ...   % U(1) charge * U(1) spin\n          'Acharge,SU2spin'; ... % U(1) charge * SU(2) spin\n          'SU2charge,Aspin'; ... % SU(2) charge * U(1) spin\n          'SU2charge,SU2spin'};  % SU(2) charge * SU(2) spin\n\nfor its = (1:numel(symstr))\n    if (contains(symstr{its},'Aspin') || (B == 0)) &amp;&amp; ... % finite Zeeman term is only compatible with U(1) spin\n            (contains(symstr{its},'Acharge') || (U == -2*epsd)) % SU(2) charge is only compatible with half filling\n        % Define operators\n        [FF,ZF,SF,IF] = getLocalSpace('FermionS',symstr{its},'NC',1);\n        [FF,ZF,SF,EF] = setItag('s00','op',FF(:),ZF,SF(:),IF.E);\n\n        NF = quadOp(FF,FF,[]); % particle number operators\n\n        if contains(symstr{its},'Acharge')\n            HU = (U/2)*sum(NF)*(sum(NF)-EF); % interaction term\n            Hepsd = sum(NF)*epsd; % on-site level term\n        else\n            % in case of SU(2) charge, Hepsd is \"absorbed\" into HU, since\n            % they cannot be distinguished\n            HU = (-U/2)*getsub(EF,find(EF.Q{1}(:,1) == 0)); % half-filled sector has energy -U/2\n            Hepsd = QSpace;\n        end\n        if contains(symstr{its},'Aspin')\n            HB = -B*SF(3); % Zeeman term\n        else\n            HB = QSpace;\n        end\n        FHU = QSpace(size(FF));\n        for ito = (1:numel(FF))\n            FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito)); % commutator [FF,HU], to be used for the self-energy trick\n        end\n\n        A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]); % isometry\n        H0 = contract(A0,'!2*',{HU+Hepsd+HB,'!1',A0}) + 1e-40*getIdentity(A0,2); % add \"infinitesimal\" term to keep all symmetry sectors\n\n        % Impurity spectral functions for spin-up electrons\n        Adiscs = cell(3,nz); % discrete data\n        % 1st row: bare correlator &lt; FF || FF' &gt;, 2nd row: auxiliary correlator &lt;\n        % FHU || FF' &gt;, 3rd row: auxiliary correlator &lt; FHU || FHU' &gt;\n        Aconts = cell(1,size(Adiscs,1)); % continuous (i.e., broadened) spectral function\n\n        for itz = (1:nz) % for different z shifts\n            if isHDD\n                % HDD mode: write temporary raw data to the disk, to be read later\n                if contains(symstr{its},'SU2charge')\n                    NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2);\n                    % gg and dgg are not relevant if SU(2) charge symmetry\n                    % is used; also note 'zflag',2\n                else\n                    NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},NF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'dgg',dgg{itz});\n                end\n            else    \n                % memory-only mode\n                if contains(symstr{its},'SU2charge')\n                    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2);\n                    % gg and dgg are not relevant if SU(2) charge symmetry\n                    % is used; also note 'zflag',2\n                else\n                    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},NF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'dgg',dgg{itz});\n                end\n            end\n\n            % Plot finite-size spectrum (or energy flow diagram, as another name)\n            if itz == nz\n                plotE(nrgdata,'title',symstr{its});\n            end\n\n            if isHDD\n                getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n            else\n                nrgdata = getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n            end\n            % NOTE: In the conventional NRG calculations (corresponding to\n            % \"'Rdiag',false\"), the reduced density matrices ('RhoK') are not\n            % diagonal in the basis of the kept states ('AK'). The option\n            % \"'Rdiag',true\" redefines the kept states to make the reduced density\n            % matrix diagonal, which improves the overall accuracy.\n\n            [odisc,Adiscs(:,itz),sigmak] = getAdisc(nrgdata,[FF(1);FHU(1);FHU(1)],[FF(1);FF(1);FHU(1)],ZF);\n        end\n\n        for ita = (1:size(Adiscs,1))\n            [ocont,Aconts{ita}] = getAcont(odisc,mean(cell2mat(reshape(Adiscs(ita,:),[1 1 nz])),3),sigmak,T/5,'alphaz',1/nz);\n        end\n\n        Adisc2sum = mean(cellfun(@(x) sum(x(:)), Adiscs(2,:)));\n\n        % Obtain improved estimates of the impurity spectral function, by using the\n        % equations of motion (EoM)\n        if contains(symstr{its},'Acharge')\n            [SE1,Aimp1] = SEtrick(ocont,Aconts{1},Aconts{2}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd+(-B/2)); % level shift of -B/2 for spin-up due to Zeeman\n            % \"Bulla's self-energy trick\", which uses asymmetric EoM\n            [SE2,Aimp2] = SEtrick(ocont,Aconts{1},Aconts{2},Adisc2sum,Aconts{3}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd+(-B/2)); % level shift of -B/2 for spin-up due to Zeeman\n            % Kugler's method, which uses symmetric EoM\n        else\n            % in case of SU(2) charge symmetry, Hepsd is absorbed into HU,\n            % so replace the 'epsd' contribution with 0\n            [SE1,Aimp1] = SEtrick(ocont,Aconts{1},Aconts{2}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',0+(-B/2));\n            [SE2,Aimp2] = SEtrick(ocont,Aconts{1},Aconts{2},Adisc2sum,Aconts{3}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',0+(-B/2));\n        end\n\n        figure;\n        hold on;\n        plot(ocont(ocont&gt;0),Aconts{1}(ocont&gt;0));\n        % multiply pi*Gamma so that the multiplied height at zero frequency is 1,\n        % which is consistent with the Friedel sum rule for half-filled impurity\n        plot(ocont(ocont&gt;0),Aimp1(ocont&gt;0));\n        plot(ocont(ocont&gt;0),Aimp2(ocont&gt;0));\n        plot(ocont(ocont&gt;0),zeros(sum(ocont&gt;0),1)+ ...\n            (sin(pi*mean(cellfun(@(x) sum(sum(x,2)./(exp(odisc/T)+1)), Adiscs(1,:))))^2)/(pi*Gamma), ...\n            'Color','k','LineStyle','--'); % Friedel sum rule: sin^2 (\\pi n_{d,\\sigma}) / (\\pi \\Gamma)\n        legend({'bare','Bulla','Kugler','sum rule'});\n        set(gca,'XScale','log','XLim',[T/10,10]);\n        xlabel('$\\omega$','Interpreter','latex');\n        ylabel('$\\pi \\Gamma \\cdot A_{\\uparrow} (\\omega)$','Interpreter','latex');\n        title(symstr{its});\n        hold off;\n    end\nend\n\n\n\n\n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz}); % HDD mode\n% %     nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz}); % use this line for RAM mode\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','U(1) charge * U(1) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v'); % HDD mode\n% %     nrgdata = getRhoFDM(nrgdata,T,'-v'); % use this line for RAM mode\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF(1);FHU(1)],[FF(1);FF(1)],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% % z-averaging discrete data\n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [SE,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],epsd);\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0) Acont2(ocont&gt;0) ... \n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega) for spin up');\n% title('U(1) charge * U(1) spin');\n% % % % %\n% \n% % % % % U(1) charge * SU(2) spin\n% % Define operators\n% [FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n% [FF,ZF,SF,EF] = setItag('s00','op',FF,ZF,SF,IF.E);\n% \n% % impurity Hamiltonian\n% NF = contract(FF,'!2*',FF);\n% HU = (U/2)*NF*(NF-1);\n% H0 = HU + epsd*NF + EF*1e-33; % no Zeeman term by construction\n% A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\n% FHU = contract(FF,'!1',HU,[1 3 2])-contract(HU,'!1',FF); % [FF,HU]\n% H0 = contract(A0,'!2*',{H0,'!1',A0});\n% \n% Adisc1 = cell(1,nz);\n% Adisc2 = cell(1,nz);\n% \n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz});\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','U(1) charge * SU(2) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v');\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF;FHU],[FF;FF],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [~,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],epsd);\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0)/2 Acont2(ocont&gt;0)/2 ... % /2 due to the sum over spins\n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega)');\n% title('U(1) charge * SU(2) spin');\n% % % % %\n% \n% %%\n% \n% % % % % SU(2) charge * U(1) spin\n% % Define operators\n% [FF,ZF,SF,IF] = getLocalSpace('FermionS','SU2charge,Aspin','NC',1);\n% [FF,ZF,SF,EF] = setItag('s00','op',FF,ZF,SF,IF.E);\n% \n% % impurity Hamiltonian\n% HU = getsub(EF,find(EF.Q{1}(:,1) == 0))*(-U/2); % subspace of half filling * (-U/2)\n% H0 = HU + B*SF(3) + EF*1e-33;\n% A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\n% H0 = contract(A0,'!2*',{H0,'!1',A0});\n% FHU = QSpace;\n% for ito = (1:numel(FF))\n%     FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito)); % [FF,HU]\n% end\n% \n% Adisc1 = cell(1,nz);\n% Adisc2 = cell(1,nz);\n% \n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2); % Note option zflag\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','SU(2) charge * U(1) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v');\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF(1);FHU(1)],[FF(1);FF(1)],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [~,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],0); % Note option edshift\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0)/2 Acont2(ocont&gt;0)/2 ... % /2 due to the sum over particle-hole symmetry\n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega) for spin-up');\n% title('SU(2) charge * U(1) spin');\n% % % % %\n% \n% %%\n% % % % % SU(2) charge * SU(2) spin\n% % Define operators\n% [FF,ZF,SF,IF] = getLocalSpace('FermionS','SU2charge,SU2spin','NC',1);\n% [FF,ZF,SF,EF] = setItag('s00','op',FF,ZF,SF,IF.E);\n% \n% % impurity Hamiltonian\n% HU = getsub(EF,find(EF.Q{1}(:,1) == 0))*(-U/2); % subspace of half filling * (-U/2)\n% H0 = HU + EF*1e-33; % no Zeeman term by construction\n% A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\n% FHU = contract(FF,'!1',HU,[1 3 2])-contract(HU,'!1',FF); % [FF,HU]\n% H0 = contract(A0,'!2*',{H0,'!1',A0});\n% \n% Adisc1 = cell(1,nz);\n% Adisc2 = cell(1,nz);\n% \n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2); % Note option zflag\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','SU(2) charge * SU(2) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v');\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF;FHU],[FF;FF],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [~,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],0); % Note option edshift\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0)/4 Acont2(ocont&gt;0)/4 ... % /4 due to the sum over spins and over particle-hole\n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega)');\n% title('SU(2) charge * SU(2) spin');\n% % % %\n</code></pre>"},{"location":"examples/NRG/Ex_SIAM_iNRG/","title":"Ex SIAM iNRG","text":"<pre><code>% iNRG example of SIAM; break spin symmetry\n\nclear\n\nnum_threads_SL(10);\n\n% Hamiltonian parameter\nU = 0.3;\nepsd = -U/2;\nGamma = 0.1;\nT = 1e-5;\n\n% NRG parameter\nLambda = 2;\nN = max(ceil(-2*log(T)/log(Lambda))+7,20);\nnz = 2;\ninrg = [1 2]; % order of iNRG sub-channels\n% inrg = [2 1];\nNkeep = 1500;\nETRUNC = inf(10,1);\nEtrunc = 10;\nnrgdata = go('data/NRG/NRG');\n\n% Define operators\n[FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge,Aspin','NC',1);\n[FF,ZF,EF] = setItag('s00','op',FF,ZF,IF.E);\n\n% impurity Hamiltonian\nNF = QSpace;\nfor ito = (1:2)\n    NF(ito) = contract(FF(ito),'!2*',FF(ito));\nend\nHU = (U/2)*sum(NF)*(sum(NF)-1);\nH00 = HU + epsd*sum(NF) + 1e-30*EF;\nA0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'A00*',[1 3 2]);\nH0 = contract(A0,'!2*',{H00,'!1',A0});\n\nFHU = QSpace; % [FF,HU], to compute the correlator &lt; [d,H_U] || d' &gt;\nfor ito = (1:2)\n    FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito));\nend\n\n% Operators within the bath\n[Fp,Zp] = singleFZ(FF,ZF);\n% NOTE: Input array of Z operators for NRG_SL should have one-to-one\n% correspondence to the iNRG sub-channels (NOT to particle flavors). That\n% is, Z(n) corresponds to the n-th sub-channel that contains ALL the\n% particle flavors j such that iflag(j) == n. If a sub-channel contains\n% more than one flavor, one may use 'chainSpace' routine to generate the Z\n% operator for the sub-channel.\nZp2 = QSpace(1,max(inrg));\nfor ito = (1:max(inrg))\n    oktmp = (inrg == ito);\n    if sum(oktmp) == 1\n        Zp2(ito) = Zp(inrg == ito);\n    elseif sum(oktmp) &gt; 1\n        [~,Zp2(ito)] = chainSpace(Fp(oktmp),(1:sum(oktmp)),Zp(oktmp));\n    else\n        error(['ERR: no Z operator for iNRG sub-channel #',sprintf('%i',ito)]);\n    end\nend\n\n[ff,~,dff] = doZLD([-1 1],(Gamma/pi)*ones(2,max(inrg)),Lambda,N,nz,'inrg',inrg);\nAdisc11 = cell(1,1,nz); % spin-up, &lt; d || d' &gt;\nAdisc12 = cell(1,1,nz); % spin-down, &lt; d || d' &gt;\nAdisc21 = cell(1,1,nz); % spin-up, &lt; [d,H_U] || d' &gt;\nAdisc22 = cell(1,1,nz); % spin-down, &lt; [d,H_U] || d' &gt;\n\nfor itz = (1:nz)\n    NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},Fp,Zp2, ...\n        'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'F0',FF,'iflag',inrg,'dff',dff{itz});\n    if itz == nz\n        [Es,Qs] = plotE(nrgdata,'noshow');\n        plotE(Es(1:2:end),Qs(1:2:end));\n    end\n    getRhoFDM(nrgdata,T,'-v');\n    [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF(:);FHU(:)],[FF(:);FF(:)],ZF);\n    Adisc11{itz} = Adiscz{1};\n    Adisc12{itz} = Adiscz{2};\n    Adisc21{itz} = Adiscz{3};\n    Adisc22{itz} = Adiscz{4};\nend\n\nAdisc11avg = mean(cell2mat(Adisc11),3);\nAdisc12avg = mean(cell2mat(Adisc12),3);\nAdisc21avg = mean(cell2mat(Adisc21),3);\nAdisc22avg = mean(cell2mat(Adisc22),3);\n\n[ocont,Acont11] = getAcont(odisc,Adisc11avg,sigmak,T/10,'-v','alphaz',1/nz);\n[~    ,Acont12] = getAcont(odisc,Adisc12avg,sigmak,T/10,'-v','alphaz',1/nz);\n[~    ,Acont21] = getAcont(odisc,Adisc21avg,sigmak,T/10,'-v','alphaz',1/nz);\n[~    ,Acont22] = getAcont(odisc,Adisc22avg,sigmak,T/10,'-v','alphaz',1/nz);\n\n[SE,Aimp] = SEtrick(ocont,(Acont11+Acont12)/2,(Acont21+Acont22)/2, ...\n    'ozin',[-1;1],'RhoV2in',(Gamma/pi)*[1;1],'epsd',epsd);\n\nfigure;\nplot(ocont,[Acont11 Acont12 Aimp]*(pi*Gamma));\nxlim([0 1]);\nset(gca,'XScale','log');\ngrid on;\nlegend({'Bare (spin-up)','Bare (spin-down)','Improved (spin-averaged)'});\n</code></pre>"},{"location":"examples/NRG/NRG1_Energy_Flow/","title":"NRG-1: Energy Flow","text":"<p>Author: QSpace version written by Andreas Gleis</p> <p>Numerical renormalization group (NRG) is a method for solving quantum impurity systems. Kenneth G. Wilson has itnvented NRG to solve the Kondo problem which was not solvable then. The invention of NRG, indeed, is a part of his Nobel prize citation. NRG is an ancestor of all numerical methods having \"renormalization group\" in their names.</p>"},{"location":"examples/NRG/NRG1_Energy_Flow/#logarithmic-discretization-of-bath","title":"Logarithmic discretization of bath","text":"<p>The starting point of the methods we covered before, such as DMRG and iTEBD, is the Hamiltonian of a system which is already discrete, such as chain. On the other hand, an NRG calculation starts from discretizing the continuous system.</p> <p>Here we consider an example of quantum impurity system, where the impurity is a spinful fermionic level and the bath consists of non-interacting spinful fermions. The Hamiltonian is given by</p> \\[ H = H_\\mathrm{imp} [ \\hat{d}_s, \\hat{d}_s^\\dagger ] + H_\\mathrm{hyb} [ \\hat{d}_s,  \\hat{d}_s^\\dagger , \\hat{c}_{ks}, \\hat{c}_{ks}^\\dagger  ] + H_\\mathrm{bath}  [ \\hat{c}_{ks}, \\hat{c}_{ks}^\\dagger ], \\] \\[ H_\\mathrm{hyb} = \\sum_k \\sum_{s = {\\uparrow},{\\downarrow}} v_k (\\hat{d}_s^\\dagger  \\hat{c}_{ks} + \\hat{c}_{ks}^\\dagger \\hat{d}_s ), \\] \\[H_\\mathrm{bath} = \\sum_k \\sum_{s = {\\uparrow},{\\downarrow}} \\epsilon_k \\hat{c}_{ks}^\\dagger  \\hat{c}_{ks} , \\] <p>where \\(s = {\\uparrow},{\\downarrow}\\) is spin, \\(\\epsilon_k\\) is the energy of bath fermion of momentum \\(k\\), and \\(v_k\\) is the coupling amplitude between the impurity level (to which a particle of spin \\(s\\) is added by applying \\(\\hat{d}_s^\\dagger\\)) and the bath level of momentum \\(k\\). The coupling between the impurity and the bath is characterized by the hybridization function,</p> \\[ \\Delta (\\omega) = \\sum_k v_k^2 \\, \\delta (\\omega - \\epsilon_k). \\] <p>In this demonstration, we choose the Anderson impurity and the \"box-shaped\" hybridization function,</p> \\[ H_\\mathrm{imp} = U \\hat{n}_{d\\uparrow} \\hat{n}_{d\\downarrow} + \\epsilon_d  (\\hat{n}_{d\\uparrow} + \\hat{n}_{d\\downarrow}) , \\] \\[ \\Delta (\\omega) = \\frac{\\Gamma}{\\pi} \\Theta (D - \\omega), \\] <p>where \\(\\hat{n}_{ds} = \\hat{d}_{s}^\\dagger \\hat{d}_s\\) is a number operator at the impurity, \\(U\\) is the local Coulomb interaction, \\(\\epsilon_d\\) is the impurity energy level, \\(\\Gamma\\) is hybridzation strength, and \\(D\\) is the half-bandwidth of the bath. This case is called single-impurity Anderson model (SIAM). Throughout this tutorial, we set \\(D=1\\) as an energy unit, without loss of generality. </p> <p>The \"box-shaped\" hybridization function would look like:</p> <p> </p> <p>To discretize this, we consider a logarithmic discretization parameter \\(\\Lambda &gt; 1\\). The logarithmic frequency grid \\(\\pm \\Lambda^{-n}\\) splits the whole bandwidth \\(\\omega \\in [-1, 1]\\) into the intervals \\(\\mathcal{I}_{\\pm n}\\) that are defined by \\(\\mathcal{I}_{+n} = [\\Lambda^{-n}, \\Lambda^{-n+1}]\\) and \\(\\mathcal{I}_{-n} = [-\\Lambda^{-n+1}, -\\Lambda^{-n}]\\).</p> <p> </p> <p>The part of the bath on each interval \\(\\mathcal{I}_{\\pm n}\\) is replaced by a discrete level at \\(\\omega = \\xi_{\\pm n}\\) that is coupled to the impurity with amplitude \\(\\gamma_{\\pm n}\\).</p> <p> </p> <p>The discretized Hamiltonian is written by</p> \\[ H_\\mathrm{bath} \\mapsto H_\\mathrm{bath}^\\mathrm{star} = \\sum_{\\pm n} \\sum_s  \\xi_{\\pm n} \\hat{a}_{\\pm n, s}^\\dagger \\hat{a}_{\\pm n, s} , \\] \\[H_\\mathrm{hyb} \\mapsto H_\\mathrm{hyb}^\\mathrm{star} = \\sum_{\\pm n} \\sum_s  \\gamma_{\\pm n} ( \\hat{d}_s^\\dagger \\hat{a}_{\\pm n, s} + \\hat{a}_{\\pm n, s}^\\dagger   \\hat{d}_s ) . \\] <p>Each discretized bath level (to which a particle of spin \\(s\\) is added by applying \\(\\hat{a}_{\\pm n, s}^\\dagger\\)) represents the part of the bath on an interval \\(\\mathcal{I}_{\\pm n}\\). Therefore the coupling strength of the level should be the same as the integrated hybridazation strength over the inteval,</p> \\[ \\gamma_{\\pm n}^2 = \\int_{\\mathcal{I}_{\\pm n}} \\mathrm{d}\\omega \\, \\Delta  (\\omega) . \\] <p>While the coupling amplitude \\(\\gamma_{\\pm n}\\) is unambigously determined, there are several different ways to determine the discretized level position \\(\\xi_{\\pm n}\\). Here we use the Campo\u2013Oliveira scheme V. L. Campo and L. N. Oliveira, Phys. Rev. B 72, 104432 (2005), which defines the level position \\(\\xi_{\\pm n}\\) as</p> \\[ \\xi_{\\pm n} = \\frac{ \\int_{\\mathcal{I}_{\\pm n}} \\mathrm{d}\\omega \\, \\Delta(\\omega)  }{ \\int_{\\mathcal{I}_{\\pm n}} \\mathrm{d}\\omega \\, \\frac{\\Delta(\\omega)}{\\omega}  } . \\] <p>(This way of determining \\(\\xi_{\\pm n}\\) is better than Wilson's original way. There is a more advanced scheme, but it is harder to implement. That's why we use the Campo\u2013Oliveira scheme here.)</p> <p>The discretized Hamiltonian \\(H_\\mathrm{imp} + H_\\mathrm{hyb}^\\mathrm{star} + H_\\mathrm{bath}^\\mathrm{star}\\) is so-called star-geometry Hamiltonian. The impurity level and the discretized bath levels (as vertices of a graph), which are coupled via hopping (as edges of the graph), can be depicted as a star graph.</p> <p>The code implementing logarithmic discretization described above can be downlodaed doCLD.m</p> <p>you can run the following demonstration for verifying the impelementation:</p> <p><pre><code>clear\n\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\n\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n</code></pre> Since MATLAB indexes the array from 1, we need to shift the indices: |ff(1)| corresponds to \\(t_\\mathrm{imp}\\) and |ff(n)| for \\(n &gt; 1\\) corresponds to \\(t_{\\ell = n-2}\\).</p> <p>The hopping amplitudes |ff| decay exponentianlly, while the on-site energies |gg| are zeros up do double precision. To see this, we rescale the values with factors \\(\\Lambda^{n/2}\\). [Quick exercise: Why \\(\\Lambda^{n/2}\\), not \\(\\Lambda^n\\)? We started from the discretization grid of \\(\\pm \\Lambda^{-n}\\), so it might look weird to have factor 1/2 in the exponent; but of course, there is a good reason.]</p> <pre><code>figure;\nplot([ff gg].*(Lambda.^((1:numel(ff)).'/2)), ...\n    'LineWidth',1);\nset(gca,'FontSize',13,'LineWidth',1);\ngrid on;\nxlabel('Index n');\nlegend({'ff(n) \\times \\Lambda^{n/2}', ...\n    'gg(n) \\times \\Lambda^{n/2}'}, ...\n    'Location','eastoutside');\n</code></pre> <p> </p> <p>The first elements of |ff| deviate from the exponential dependence, as we see the deviation from the horizontal line. They come from the specific details of the hybridization function. For example, the square of ff(1) is equivalent to the integral of the hybridization,</p> \\[ t_\\mathrm{imp}^2 = \\int_{-D}^{D} \\mathrm{d}\\omega \\Delta (\\omega) = 2 \\Gamma D/ \\pi. \\] <pre><code>ff(1)^2 - 2*Gamma/pi % D = 1 as energy unit\n</code></pre>"},{"location":"examples/NRG/NRG1_Energy_Flow/#lanczos-tridiagnolization","title":"Lanczos tridiagnolization","text":"<p>The star-geometry Hamiltonian is \\(H_\\mathrm{imp} + H_\\mathrm{hyb}^\\mathrm{star} + H_\\mathrm{bath}^\\mathrm{star}\\) is mapped onto the Wilson chain Hamiltonian, via the Lanczos tridiagonalization. The Lanczos method (which is implemented, for example, in <code>DMRG/eigs_1site.m</code> in the context of DMRG) first constructs a tridiagonal matrix representation of the input matrix constrained within the Krylov space, and then diagonalizes the tridiagonal matrix to obtain the ground state. The Lanczos tridiagonalization indicates the first part of this process. Here in the mapping onto the Wilson chain, we consider the tridiagonal matrix representation of the quadratic (i.e., single-particle) terms of the bath and the hybridization, without the quartic (i.e., interacting) impurity Hamiltonian.</p> <p>The Wilson chain Hamiltonian for the SIAM is given by</p> \\[ H_\\mathrm{SIAM}^\\mathrm{chain} = H_\\mathrm{imp} + H_\\mathrm{bath}^\\mathrm{chain}  + H_\\mathrm{hyb}^\\mathrm{chain}, \\] \\[ H_\\mathrm{imp} = U \\hat{n}_{d\\uparrow} \\hat{n}_{d\\downarrow} + \\epsilon_d  (\\hat{n}_{d\\uparrow} + \\hat{n}_{d\\downarrow}), \\] \\[ H_\\mathrm{bath}^\\mathrm{chain} = \\sum_{\\ell \\geq 0} \\sum_{s = \\uparrow,\\downarrow}  t_\\ell \\left( \\hat{f}_{\\ell, s}^\\dagger \\, \\hat{f}_{\\ell+1,s} + \\hat{f}_{\\ell+1,s}^\\dagger  \\, \\hat{f}_{\\ell, s} \\right), \\] \\[ H_\\mathrm{hyb} ^\\mathrm{chain}= \\sum_s t_\\mathrm{imp} \\left( \\hat{d}_s^\\dagger  \\hat{f}_{0,s} + \\hat{f}_{0,s}^\\dagger \\hat{d}_s \\right). \\] <p>Note that the impurity Hamiltonian \\(H_\\mathrm{imp}\\) is not changed along the logarithmic discretization and the tridiagonalizatoin. The Wilson chain is in principle semi-infinite, but in practice we consider a large but finite length. The length \\(N\\) sets in the minimum energy scale \\(\\sim \\Lambda^{-N/2}\\) to consider.</p> <p>We will solve this one-dimensional system with the iterative diagonalization.</p> <p>The code implementing logarithmic discretization described above can be downlodaed NRG_IterDiag.m</p> <p>This NRG style of the iterative diagonalization differs from the iterative diagonalization covered in <code>Examples</code> in that (i) the Hamiltonian is rescaled by the energy scale factors \\(\\sim \\Lambda^{-n/2}\\) and (ii) the energy eigenvalues are shifted so that the lowest energy eigenvalue becomes zero. Other than these, it is the same iterative diagonalization.</p> <p>As a demonstration of the completed iterative diagonalization, we apply it to the SIAM.</p> <p><pre><code>% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\n\n% NRG parameter\nNkeep = 300;\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> Here each line indicates the information of each iteration step: time stamp, number of the kept states, number of the total states, the largest energy of the kept states, the largest energy of the discarded states.</p>"},{"location":"examples/NRG/NRG1_Energy_Flow/#energy-flow-diagram","title":"Energy flow diagram","text":"<p>NRG provides a method to analyze the spectrum obtained along the iterative diagonalization. Let's plot the lowest-lying (many-body) energy levels. We plot the results from even iterations and those from odd iterations separately. The plotting is handled by the function plotEQS|.m|. Please have a look at the code to get an idea how the data from the iterative diagonalization is prepared to finally plot the flow diagram.</p> <pre><code>plotEQS(Inrg);\n</code></pre> <p> </p> <p>These plots are called energy flow diagram or finite-size energy spectra. The name \"flow\" literally comes from that the lines flow from one regime to the other. There are three regions (iterations 1--10; 17--25; 35--55) connected via two crossovers. These regions correspond to different fixed points: free orbital, local moment, and strong coupling. The strong-coupling fixed-point regime exhibits prominent plateau of the energy levels.</p> <p>Exercise: Reproduce lowest-lying energies in the strong-coupling regime by fixed-point Hamiltonians</p> <p>Let's consider iteration 54 in the strong-coupling fixed-point regime.. Their lowest-lying energies, including all degenerate levels, are:</p> <p><pre><code>E = eigQS(diag(Inrg.HK{54}));\nEKodd = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKodd = [EKodd;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKodd = E;\nend\nfprintf([sprintf('%.4f, ',EKodd(1:5).'),'\\n', ...\n    sprintf('%.4f, ',EKodd(6:11).'),'...\\n']);\n</code></pre> We see 1-fold, 4-fold, and 6-fold degeneracies. On the other hand, the energy levels at the next iteration 55 have more degeneracies:</p> <pre><code>E = eigQS(diag(Inrg.HK{55}));\nEKeven = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKeven = [EKeven;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKeven = E;\nend\nfprintf([sprintf('%.4f, ',EKeven(1:4).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(5:12).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(13:20).'),'...\\n']);\n</code></pre> <p>There are 4-fold and 16-fold degeneracies, up to numerical noise of \\(O(10^{-6})\\). Reproduce these (many-body) energy values by considering strong-coupling fixed-point Hamiltonians. (Hint: The fixed-point Hamiltonians are single-particle Hamiltonians, effectively!)</p> <p>Solution to Exercise: Reproduce lowest-lying energies in the strong-coupling regime by fixed-point Hamiltonians </p> <p>Let's perform the iterative diagonalization first. <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre></p> <p>Then we plot the energy flow diagram:</p> <pre><code>% Energy flow diagram\nplotEQS(Inrg);\n</code></pre> <p> </p> <p>The lowest-lying energies at iteration 54 are:</p> <pre><code>E = eigQS(diag(Inrg.HK{54}));\nEKodd = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKodd = [EKodd;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKodd = E;\nend\nfprintf([sprintf('%.4f, ',EKodd(1:5).'),'\\n', ...\n    sprintf('%.4f, ',EKodd(6:11).'),'...\\n']);\n</code></pre> <p>The fixed-point description for this iteration is that the impurity (site 1) and the first bath site (site 2) are strongly bound and the rest of the chain (from site 3 to site 54) are decoupled from the dimer. So the excitation spectrum is obtained by considering the lowest excitations of the single-particle Hamiltonian for the part from site 3 to site 54, having even number of sites.</p> <pre><code>Hsp = diag(ff(3:53),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:53)]);\nHsp = Hsp/Inrg.EScale(54); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\n\n% many-body energy values\nEvs = [0; ... % ground-state\n    Esp(end/2+1); Esp(end/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp(end/2); -Esp(end/2); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp(end/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp(end/2)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n</code></pre> <p>On the other hand, the lowest-lying energies for iteration 55 have more degeneracies,</p> <pre><code>E = eigQS(diag(Inrg.HK{55}));\nEKeven = []; \nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKeven = [EKeven;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKeven = E;\nend\nfprintf([sprintf('%.4f, ',EKeven(1:4).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(5:12).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(13:20).'),'...\\n']);\n</code></pre> <p>The 4-fold and 16-fold degeneracies can be seen as that extra factor 4 is multiplied to the degeneracies of the 1-fold and 4-fold degeneratices in the case of iteration 54, putting aside different values of energies. This factor 4 can be understood by the fixed-point Hamiltonian as well. The part of the chain decoupled from the strongly coupled dimer has odd number of sites. So it has a zero mode:</p> <pre><code>Hsp = diag(ff(3:54),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:54)]);\nHsp = Hsp/Inrg.EScale(55); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\nfprintf('%.4f\\n',Esp((end+1)/2));\n</code></pre> <p>There are four Fock states regarding the zero mode (empty, spin-up, spin-down, doubly occupied), having all the same zero energy. So it introduces factor 4 to the degeneracies. Factoring out the degrees of freedom of this zero mode, we construct the lowest-lying energies at iteration 55 as for iteration 54:</p> <pre><code>% many-body energy values\nEvs = [0; ... % ground-state\n    Esp((end+1)/2+1); Esp((end+1)/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp((end+1)/2-1); -Esp((end+1)/2-1); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp((end+1)/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp((end+1)/2-1)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n</code></pre>"},{"location":"examples/NRG/NRG1_Energy_Flow/#single-impurity-kondo-model-sikm","title":"Single-Impurity Kondo model (SIKM)","text":"<p>We can derive the Wilson chain Hamiltonian \\(H_\\mathrm{SIKM}^\\mathrm{chain}\\) for the single-impurity Kondo model (SIKM), from the chain Hamiltonian of the SIAM \\(H_\\mathrm{SIAM}^\\mathrm{chain}\\) shown above. By applying the Schrieffer-Wolff transformation to the impurity site (on which \\(\\hat{d}_s\\) acts) and the first bath site (on which \\(\\hat{f}_{0,s}\\) acts), we obtain</p> \\[ H_\\mathrm{SIKM}^\\mathrm{chain} = H_\\mathrm{exc} + H_\\mathrm{bath}, \\] \\[ H_\\mathrm{exc} = 2J \\hat{\\vec{S}}_d \\cdot \\hat{\\vec{S}}_0 , \\] \\[ H_\\mathrm{bath} = \\sum_{\\ell \\geq 0} \\sum_{s = \\uparrow,\\downarrow} t_\\ell \\left( \\hat{f}_{\\ell, s}^\\dagger \\, \\hat{f}_{\\ell+1,s} + \\hat{f}_{\\ell+1,s}^\\dagger \\, \\hat{f}_{\\ell, s} \\right) . \\] <p>Here \\(\\hat{\\vec{S}}_d\\) is the spin operator acting on the impurity site,</p> \\[ \\hat{\\vec{S}}_0 = \\sum_{s,s'} \\hat{f}_{0,s}^\\dagger \\frac{\\vec{\\sigma}_{s,s'}}{2}  \\hat{f}_{0,s'} \\] <p>is the spin operator acting on the first bath site, \\(\\vec{\\sigma} = [\\sigma_x, \\sigma_y, \\sigma_z]\\) is the vector of Pauli matrices, and</p> \\[ J = t_0^2 \\left( \\frac{1}{-\\epsilon_d} + \\frac{1}{U + \\epsilon_d} \\right) \\] <p>is the Kondo coupling strength. For particle-hole symmetric case \\(\\epsilon_d = -U/2\\) which we considered above, it becomes</p> \\[ J = \\frac{4 t_0^2}{U} = \\frac{8 \\Gamma D}{\\pi U}. \\] <p>The bath term \\(H_\\mathrm{bath}\\) is the same as in the SIAM case. Note that the impurity site in the SIKM has dimension 2, while that in the SIAM has 4; the doubly occupied and the empty states are \"integrated out\" by the Schrieffer-Wolff transformation. Refer to J. R. Schrieffer and P. A. Wolff, Phys. Rev. 149, 491 (1966) for the details of the Schrieffer-Wolff transformation.</p> <p>Exercise: Perform the iterative diagonalization of this chain Hamiltonian for the SIKM, with the value of \\(J\\) corresponding to the choice of parameters \\(U\\), \\(\\epsilon_d\\), and \\(\\Gamma\\) above. (Again \\(D = 1\\) is the energy unit.) Compare the energy flow diagram with the SIAM result.</p> <p>(Hint: You can do it by changing <code>H0</code>, <code>A0</code>, and <code>ff</code> only, with using the same function <code>NRG_IterDiagQS</code>!)</p> <p>Solution to Exercise: Single-impurity Kondo model</p> <p>In the example of the SIAM, we set the first leg (i.e., left leg) of <code>A0</code> as a dummy leg for vacuum and the second leg (i.e., bottom leg) for the Anderson impurity. The impurity Hamiltonian \\(H_\\mathrm{imp}\\) involves only one fermionic site (i.e., \\(d\\) level). The rest of the chain Hamiltonian is the hopping and on-site terms that are generated within <code>NRG_IterDiagQS</code>.</p> <p>On the other hand, in the SIKM, the exchange interaction \\(H_\\mathrm{exc}\\) acts on two sites: a spin site for \\(\\hat{\\vec{S}}_d\\) and a spinful fermionic site for \\(\\hat{\\vec{S}}_0\\). The latter site is the first bath site, and coupled with the other fermionic sites via particle hopping that can be generated inside <code>NRG_IterDiagQS</code>.</p> <p>Therefore, to use the same function <code>NRG_IterDiagQS</code> for the SIKM, we associate the first leg of <code>A0</code> with the spin site for \\(\\hat{\\vec{S}}_d\\) and its second leg with the spinful fermionic site for \\(\\hat{\\vec{S}}_0\\). Accordingly, we shift the hopping amplitudes and on-site energies by one site to the left, as the second leg of <code>A0</code> involves the first bath site.</p> <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n</code></pre> <p>Here <code>ff(1)</code>, <code>ff(2)</code>, <code>ff(3)</code>, ... are equal to <code>ff(2)</code>, <code>ff(3)</code>, <code>ff(4)</code>, ... for the <code>ff</code> vector in the SIAM case. Note that the first element <code>ff(1)</code> in the SIAM case depends on the hybridization strength \\(\\Gamma\\); it is absorbed into the definition of \\(J\\) after the Schrieffer-Wolff transformation.</p> <p>Then run the iterative diagonalization, and plot the energy flow diagram.</p> <pre><code>% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <p>Then plot the energy flow:</p> <pre><code>% Energy flow diagram\nplotEQS(Inrg);\n</code></pre> <p> </p> <p>The energy flow diagram looks similar with the diagram for the SIAM, especially the last crossovers and the spectrum at the last iterations in the strong-coupling fixed-point regime. There are two differences as well:</p> <p>The panel for even (odd) iterations in the SIKM case look similar to the panel for odd (even) iterations in the SIAM. It is because we have shifted the chain sites by one to the left. While there are two crossovers in the SIAM, here in the SIKM there is only one crossover, which is from the local moment regime to the Kondo regime.</p> <p> </p>"},{"location":"examples/NRG/NRG2_ImpThermo/","title":"NRG2 ImpThermo","text":"<p>NRG2</p>"},{"location":"examples/NRG/NRG3_ImpSpec/","title":"NRG3 ImpSpec","text":"<p>NRG3</p>"},{"location":"examples/NRG/NRG_Eflow/","title":"NRG Eflow","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Reproduce lowest-lying energies in the strong-coupling regime by fixed-point Hamiltonians\n% Let's perform the iterative diagonalization first.\n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n\n% Energy flow diagram\nplotEQS(Inrg);\n%% \n% The lowest-lying energies at iteration 54 are:\n\nE = eigQS(diag(Inrg.HK{54}));\nEKodd = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKodd = [EKodd;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKodd = E;\nend\nfprintf([sprintf('%.4f, ',EKodd(1:5).'),'\\n', ...\n    sprintf('%.4f, ',EKodd(6:11).'),'...\\n']);\n%% \n% The fixed-point description for this iteration is that the impurity (site \n% 1) and the first bath site (site 2) are strongly bound and the rest of the chain \n% (from site 3 to site 54) are decoupled from the dimer. So the excitation spectrum \n% is obtained by considering the lowest excitations of the single-particle Hamiltonian \n% for the part from site 3 to site 54, having even number of sites.\n\nHsp = diag(ff(3:53),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:53)]);\nHsp = Hsp/Inrg.EScale(54); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\n\n% many-body energy values\nEvs = [0; ... % ground-state\n    Esp(end/2+1); Esp(end/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp(end/2); -Esp(end/2); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp(end/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp(end/2)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n%% \n% On the other hand, the lowest-lying energies for iteration 55 have more degeneracies,\n\nE = eigQS(diag(Inrg.HK{55}));\nEKeven = []; \nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKeven = [EKeven;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKeven = E;\nend\nfprintf([sprintf('%.4f, ',EKeven(1:4).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(5:12).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(13:20).'),'...\\n']);\n%% \n% The 4-fold and 16-fold degeneracies can be seen as that extra factor 4 is \n% multiplied to the degeneracies of the 1-fold and 4-fold degeneratices in the \n% case of iteration 54, putting aside different values of energies. This factor \n% 4 can be understood by the fixed-point Hamiltonian as well. The part of the \n% chain decoupled from the strongly coupled dimer has odd number of sites. So \n% it has a zero mode:\n\nHsp = diag(ff(3:54),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:54)]);\nHsp = Hsp/Inrg.EScale(55); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\nfprintf('%.4f\\n',Esp((end+1)/2));\n%% \n% There are four Fock states regarding the zero mode (empty, spin-up, spin-down, \n% doubly occupied), having all the same zero energy. So it introduces factor 4 \n% to the degeneracies. Factoring out the degrees of freedom of this zero mode, \n% we construct the lowest-lying energies at iteration 55 as for iteration 54:\n\n% many-body energy values\nEvs = [0; ... % ground-state\n    Esp((end+1)/2+1); Esp((end+1)/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp((end+1)/2-1); -Esp((end+1)/2-1); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp((end+1)/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp((end+1)/2-1)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n</code></pre>"},{"location":"examples/NRG/NRG_Kondo/","title":"NRG for SIKM","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Single-impurity Kondo model\n% In the example of the SIAM, we set the first leg (i.e., left leg) of |A0| \n% as a dummy leg for vacuum and the second leg (i.e., bottom leg) for the Anderson \n% impurity. The impurity Hamiltonian $H_\\mathrm{imp}$ involves only one fermionic \n% site (i.e., $d$ level). The rest of the chain Hamiltonian is the hopping and \n% on-site terms that are generated within |NRG_IterDiagQS|.\n% \n% On the other hand, in the SIKM, the exchange interaction $H_\\mathrm{exc}$ \n% acts on two sites: a spin site for $\\hat{\\vec{S}}_d$ and a spinful fermionic \n% site for $\\hat{\\vec{S}}_0$. The latter site is the first bath site, and coupled \n% with the other fermionic sites via particle hopping that can be generated inside \n% |NRG_IterDiagQS|.\n% \n% Therefore, to use the same function |NRG_IterDiagQS| for the SIKM, we associate \n% the first leg of |A0| with the spin site for $\\hat{\\vec{S}}_d$ and its second \n% leg with the spinful fermionic site for $\\hat{\\vec{S}}_0$. Accordingly, we shift \n% the hopping amplitudes and on-site energies by one site to the left, as the \n% second leg of |A0| involves the first bath site.\n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n%% \n% Here |ff(1)|, |ff(2)|, |ff(3)|, ... are equal to |ff(2)|, |ff(3)|, |ff(4)|, \n% ... for the |ff| vector in the SIAM case. Note that the first element |ff(1)| \n% in the SIAM case depends on the hybridization strength $\\Gamma$; it is absorbed \n% into the definition of $J$ after the Schrieffer-Wolff transformation.\n% \n% Then run the iterative diagonalization, and plot the energy flow diagram.\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n\n% Energy flow diagram\nplotEQS(Inrg);\n%% \n% The energy flow diagram looks similar with the diagram for the SIAM, especially \n% the last crossovers and the spectrum at the last iterations in the strong-coupling \n% fixed-point regime. There are two differences as well:\n%% \n% * The panel for even (odd) iterations in the SIKM case look similar to the \n% panel for odd (even) iterations in the SIAM. It is because we have shifted the \n% chain sites by one to the left.\n% * While there are two crossovers in the SIAM, here in the SIKM there is only \n% one crossover, which is from the local moment regime to the Kondo regime.\n</code></pre>"},{"location":"examples/NRG/NRG_Kondo_Thermal/","title":"SIKM Thermal Properties","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Single-impurity Kondo model\n% Perform the iterative diagonalization for the whole Kondo model (SIKM). \n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,~] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,30);\n% post-processing\nff = [ff;ff(end).*(Lambda.^(-(1:(N-numel(ff))).'/2))];\ngg = zeros(size(ff));\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = 2*J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\nbeta0 = 1; % parameter to define temperature values\n[T,Tchi,Sent] = getTDconvQS(Inrg,beta0);\n%% \n% Perform the iterative diagonalization for the bath only. *We replace the Kondo \n% impurity with vacuum*.\n\nA0_2 = getIdentity(setItag(getvac(EF,1),'L00'),2,EF,2,'K00',[1 3 2]); \nH0_2 = 1e-33*contract(A0_2,'!2*',A0_2);\nInrg2 = NRG_IterDiagQS(H0_2,A0_2,Lambda,ff,F,gg,NF,Z,Nkeep);\n[~,Tchi2,Sent2] = getTDconvQS(Inrg2,beta0);\n%% \n% Then subtract the thermodynamic properties from the bath only from those from \n% the whole impurity model, to obtain the impurity contribution.\n\n% impurity contribution to the spin susceptibility (* temperature)\nTchi_imp = Tchi - Tchi2; \n% impurity contribution to the entropy\nSent_imp = Sent - Sent2;\n\nlogT = log(T);\n% impurity contribution to the specific heat C = T* dS/dT = dS / d(log T)\nC_imp = interp1((logT(1:end-1)+logT(2:end))/2, ...\n    diff(Sent_imp)./diff(logT),logT,'linear','extrap');\n\n% Sommerfeld-Wilson ratio\nWR = (Tchi_imp./C_imp)*(4*(pi^2)/3);\n%% \n% To rescale the temperature, we compute the Kondo temperature $T_\\mathrm{K}$. \n% Here we use the formula from the second-order poor man's scaling calculation.\n\n% Kondo temperature\nTK = sqrt(J) * exp(-1/J); % half-bandwidth D = 1\ndisp(TK);\n%% \n% Plot the result.\n\nfigure;\nsemilogx(T/TK,(Tchi_imp./T)*(4*TK), ...\n    T/TK,Sent_imp/log(2), ...\n    T/TK,WR,'LineWidth',1);\nset(gca,'LineWidth',1,'FontSize',13);\nxlabel('$T / T_\\mathrm{K}$','Interpreter','latex');\nlegend({'$4 T_\\mathrm{K} \\chi_\\mathrm{imp}$'; ...\n    '$S_\\mathrm{imp} / \\ln 2$'; ...\n    '$R$'}, ...\n    'Interpreter','latex','Location','northwest');\nylim([0 3]);\nxlim([min(T) max(T)]/TK);\ngrid on;\n%% \n% The curves of $R(T)$ and $\\chi_\\mathrm{imp}(T)$ for the SIKM exhibit similar \n% behavior as those for the SIAM. Compare this plot with the demonstration plot. \n% The kinks of $R$ at the highest and the lowest temperatures come from numerical \n% artifact.\n% \n% On the other hand, the curve of $S_\\mathrm{imp}(T)$ for the SIKM shows different \n% features from that for the SIAM. $S_\\mathrm{imp} (T)$ for the SIAM has had three \n% plateaus that represent three regimes: (i) $\\ln 4$ for the free orbital regime, \n% (ii) $\\ln 2$ for the local moment regime, and (iii) $0$ for the strong coupling \n% regime. $S_\\mathrm{imp} (T)$ for the SIKM has only two plateaus: (i) $\\ln 2$ \n% for the local moment regime and (ii) $0$ for the strong coupling regime.\n% \n% The absence of the free orbital regime is natural. In the derivation of the \n% SIKM out of the SIAM, the doubly-occupied and the empty states of the impurity \n% are \"integrated out.\" As the result, the impurity of the SIKM has only spin \n% degrees of freedom. That is, there is no free orbital regime at all for the \n% SIKM.\n</code></pre>"},{"location":"examples/NRG/NRG_SpecFunc/","title":"NRG for Spectral Functions","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Dynamical impurity spin susceptibility\n% Perform the iterative diagonalization calculation, with the same parameters \n% chosen in the demonstration of the previous examples.\n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n\nT = 1e-8;\nInrg = getRhoFDMQS(Inrg,T); % construct full density matrix\n%% \n% Compute the discrete spectral data of the dynamical impurity spin susceptibility \n% $\\chi_s (\\omega)$. Here, we use the spin-z operator |S(3)| in case of U(1) spin \n% symmetry or |S| in case of SU(2) spin symmetry. Note that in case of SU(2) spin \n% symmetry, we compute the sum of spin correlations in all three spatial directions, \n% which are all identical. To obtain only the z-component, we therefore have to \n% divide by 3. By setting the third input as empty (|[]|), the |getAdiscQS| routine \n% understands that the input operator is *bosonic*. For fermionic operators, the \n% so-called Z string should be considered, and the sign factor between two terms \n% in the anti-commutator is $+$. On the other hand, for bosonic operators, Z operators \n% do not involve, and the sign factor is $-$ due to commutator.\n\n% dynamical impurity spin susceptibility\nif numel(S)&gt;1 % U(1) spin\n    [odisc,Adisc] = getAdiscQS(Inrg,S(3),[]);\nelse % SU(2) spin\n    [odisc,Adisc] = getAdiscQS(Inrg,S,[]);\n    Adisc = Adisc/3; % divide by 3 to consider only z-direction\nend\n%% \n% Broaden the discrete data.\n\n    % broaden the discrete data to have a continuous curve\n    [ocont,Acont] = getAcont(odisc,Adisc,log(Lambda),T/5);\n%% \n% Plot the result.\n\n    figure;\n    hold on;\n    % positive frequency\n    plot(ocont(ocont&gt;0),Acont(ocont&gt;0), ...\n        'LineWidth',1,'LineStyle','-');\n    % negative frequency\n    plot(-ocont(ocont&lt;0),-Acont(ocont&lt;0), ...\n        'LineWidth',1,'LineStyle','--');\n    hold off;\n    set(gca,'FontSize',13,'LineWidth',1,'XScale','log','YScale','log');\n    legend({'$\\chi''''_s(\\omega &gt; 0)$','$-\\chi''''_s(\\omega &lt; 0)$'}, ...\n        'Interpreter','latex');\n    xlabel('$| \\omega |$','Interpreter','latex');\n    ylabel('$\\chi''''_s$','Interpreter','latex');\n    xlim([1e-11 1]);\n    grid on;\n%% \n% Note that the minus sign prefactor in $- \\chi''_s (\\omega &lt; 0)$ to visualize \n% the data for negative frequency. We see that the curve is an odd function, i.e., \n% $\\chi''_s (\\omega) = - \\chi''_s (-\\omega)$. It is the generic property of the \n% imaginary part of the correlation functions of bosonic operators.\n%% \n% Identify the peak position of the curve.\n\n    [~,maxid] = max(Acont);\n    disp(ocont(maxid));\n%% \n% This value is similar to the Kondo temperature $T_\\mathrm{K}$ that we obtained \n% from the Bethe ansatz solution. (Note that there are various ways of computing \n% the Kondo temperature, and these ways give similar but different values.)\n\n    TK = sqrt(U*Gamma/2)*exp(-pi*U/8/Gamma + pi*Gamma/2/U);\n    disp(TK);\n    disp(ocont(maxid)/TK); % ratio\n%% \n% Indeed, the peak position of $\\chi''_s (\\omega)$ is the method of choice to \n% determine the Kondo temperature for general quantum impurity systems! This method \n% is especially useful when analytical approaches (such as poor man's scaling \n% and the Bethe ansatz) are not applicable due to the complexity of the system.\n</code></pre>"},{"location":"reference/contractQS/","title":"contractQS","text":"<pre><code>function contractQS()\n\n    Contract set of QSpace tensors in a pairwise fashion\n    as described with usage #1 and #2 below. This automatically\n    also takes care of the underlying Clebsch Gordan coefficient\n    spaces if present based on X-symbols.\n\n    Each QSpace can be used as is, or as its 'conjugate' where the\n    conjugate of a QSpace A, i.e. conj(A) is defined as the QSpace\n\n     1) with all `arrows' reversed\n     2) keeping the SAME qlabels on all legs\n     3) and complex conjugation of all data{} if applicable,\n        i.e., if the (reduced) matrix elements are complex.\n\n    Because of (1), the specification of conjugate flags (`conj-flags')\n    is also important for QSpaces with all-real matrix elements.\n    For reversing individual arrows, see getIdentitQS(..,'-0').\n\nUsage #1: S=contractQS(A, ica, B, icb [, perm, OPTS ]);\n\n    Plain contraction of a single pair of QSpaces, A and B,\n    with respect to given explicitly specified  sets of\n    contraction indices ica and icb, which can be specified\n\n      - numerically (e.g. [1 2]),\n      - or as strings (e.g. '1,2', or '1 2')\n      - or as compact strings (e.g. '1,2', or '12')\n\n    The last 'compact format' is only possible / unique,\n    of course, if the tensors A and B do not have more than\n    9 legs (which basically never occurs), such that the\n    contraction indices reamin in the single digits\n    (this can be further relaxed, though, by extending the\n    digital range to letter, i.e. using a-z after 0-9).\n\n    The recommended way to specify conj-flag with usage #1\n    is together with the contraction indices in string notation!\n    For example,\n\n      contractQS(A,[1 3],B,[1 3],'conjA')  is equivalent to\n      contractQS(A,'1,3;*',B,[1 3])        is equivalent to\n      contractQS(A,'13*',B,'13')\n\n    (deprecated) options specific to usage #1:\n\n      'conjA'  use complex conjugate of A for contraction\n      'conjB'  use complex conjugate of B for contraction\n\nUsage #2: S=contractQS(A,..,{B,..,{C,..}},.. [, perm, OPTS ]);\n\n    Generalized 'cell-contraction' of tensors: when encountering\n    a cell, the content of that cell is contracted first, before\n    using its result. This allows the specification of an entire\n    patter of pairwise contractions based on a nested cell structure\n    where the lowest-level contractions are performed first.\n    An optional fully enveloping outer cell bracket at `base' level\n    as in S=contractQS({A,..,{B,..,{C,..}},..} [, perm, OPTS ])\n    is permitted, which may be used e.g., when debugging nested\n    parts of cell-contractions.\n\n    Cell contractions are furthermore based on QSpace `itags'\n    i.e. string labels for indices with up to 8chars, and which\n    are specified in QSpace.info.itags. This offers automated\n    contraction ('auto-contraction') of pairs of tensors solely\n    based on matching itags! Uusage #2 therefore does not (also)\n    allow explicit specification of contraction indices as in\n    usage #1.  Therefore itags (plus conj-flags) must be unique.\n\n    itags must always also contain individual conjugate flags\n    (this represent the bare minimum that must be specified with\n    each QSpacein v3): the conjugate flags on individual indices\n    (legs) of a tensor determine  whether that index (leg) is\n    in- or out-going, with the convention that\n\n        all out-going indices have a trailing * in their itags!\n\n    For example, an A-tensor with L(eft), R(ight), s(=local)\n    indices may have itags A.info.itags={'L','R*',s'}\n    assuming (L,R,s) index order.\n\n    In usage #2, for every operator additional optional strings\n    can be specified, appearing right after the affected tensor\n    e.g. QSpace A:\n\n      A,'!ij'  do not contract indices specified by ij (in compact\n               format) despite they share common matching itags.\n      A,'*'    apply overall (complex) conjugation on given input\n               tensor A (see early comments above)\n      A,'!ij*' both of the above in a single instruction\n               the conjugate flag '*' always trailing.\n\n      A,'ij'   [07/2023]\n      A,'ij*'  explicitly specify indices to contract\n               this is intended only for the case of degenerate itags\n               i.e., when identical itags appear on multiple legs\n               including the same conjugate flag.\n\n    itags may be set or adapted on the fly (this is performed\n    prior to the auto-contraction together wit the above directions)\n\n      X,'--op:&lt;tag&gt;[:&lt;opl=op&gt;]'\n         specify itags for given (e.g. local) operator.\n\n         The last option considers X an operator, and hence assumes\n         operator itags '&lt;tag&gt;;&lt;tag&gt;*[;opl*]' for QSpace X;\n         the default operator label is `op', but may be changed\n         by specifying a trailing ':&lt;opl&gt;' as indicated above.\n         As a safeguard, this issues a warning, if existing itags are\n         overwritten. This is relevant e.g. for local operators that\n         are applied to a very specific site with associated itag.\n\n         [11/2018] the specified &lt;tag&gt; may now also represent\n         a regular expression (regexp), recognized by non-alphabetic\n         special characters, while ignoring conj-flags (without\n         special characters, the specified &lt;tag&gt; is taken as is!).\n         This usage then searches for a matching itag in the paired\n         up QSpace (cell) in the contraction.\n\n         Ex. Consider A some QSpace with a single local index\n         that starts with `s', e.g., like 's010' for site 10;\n         then contract(A,Xloc,'-op:^s') will autocontract\n         the local operator Xloc to the correct local index in A\n         (here the regex `^s' indicates `starts with s');\n         An alternative operator itag may still be specified\n         by adding a trailing ':opl' as indicated earlier.\n\n      A,'--itag:s/pat/rep/[gi]   [07/2023]\n\n         replace/modify existing itags on the fly for a particular\n         recursive level of a cell contraction based on regular\n         expressions (regex; using ECMAScript grammar, cf. C++/regex).\n         The syntax is much analogous to perl regex.\n\n         The trailing flags enable case insensitive replacement [i]\n         and global replacement [g] of all possible matches\n         (by default, only the first match is replaced).\n\n    An adaptation of usage #2 can also be used\n    for plain sequential contractions\n\n        S=contractQS(A [,flagsA],B [,flagsB],C,... [, perm, OPTS ])\n\n    which is equivalent to\n    S=contractQS({A [,flagsA],{B [,flagsB], {C,...}}}, [,perm,OPTS ]).\n    That is, by grouping A*(B*(C*...)), sequential contractions start\n    from the right end onwards to the beginning of the specified set.\n    This structure is also permitted at any lower level inside cell\n    contractions. Non-contracted indices are always collected in the\n    order they appear in the input.\n\nThe remaining trailing OPTS are\n\n    perm  optional permutation (non-string) on the final object;\n          this permutation can be shorter than the actual rank\n          of the resulting QSpace, which then is completed as\n          an identity permutation on the remainder of indices.\n\n          By permitting the specification of indices to contract\n          also in contractions based on itags (cell-contractions)\n          there is a potential ambiguity of whether perm should\n          be interpreted as indices on the last specified tensor\n          (the latter may also be represented in compact string\n          format for better differentiation).\n\n          Hence the rules for perm to be interpreted as permutation\n          requires that (i) it is a valid permutation of length\n          r&gt;=2 to start with, and (ii) that it is in numeric format,\n          i.e., not written as compact string. Valid examples are\n          [2 1], [2 3 1], but not, e.g., 1, [2 3], or '21'.\n\n          The ambiguity above is fully circumvented when also\n          wrapping the last contraction at base level into a cell,\n          such as contractQS({A,...},perm [,'-v']) [see above],\n          in which case perm is always interpreted as permutation\n          on the overall result, irrespective of rank or whether\n          specified as numeric or compact string index. In case\n          of a string, this then also permits to specify an optional\n          conjugate flag to be applied on the overall result.\n\n    '-v'  debug mode that shows all levels of a cell contraction\n          together with the actual contractions performed\n          based on shown itags. Internally, degenerate itags are\n          frequently flagged by making use of signed characters,\n          which makes them unique and thus differentiate them.\n          When printed, flagged itags are formatted as \"&lt;itag&gt;|b\"\n          where the character `|' separates the actual itag string\n          from number b (int8 decimal) which in its binary form\n          reflects the internal flags.\n\nMixed usage of #2 and #1 is not possible.\nUsage #2 is typically recommended because auto-contraction\nmakes it far easier to contract entire networks in a single go\nwithout having to manually track and specify index locations.\n\nAW (C) May 2010-2023\n</code></pre>"},{"location":"reference/getLocalSpace/","title":"getLocalSpace","text":"<pre><code>function [FF,..,Iout]=getLocalSpace(model [,'sym1,sym2,...',varargin])\n\n  build local model state space as specified by means of the typical\n  associated operators such as spin (S), annihilation (F), or\n  charge parity operator (Z).\n\n  The residual info structure Iout contains further operators\n  (if applicable), such as the identity operator (E), the spinor for\n  particle-hole symmetry (C3), its equivalent to the Casimir operator\n  S^2 (C2), or Q2 := (N-1)^2, with N the total particle number summed\n  over all channels, as required for isotropic Coulomb interaction.\n\nModels available\n\n   [F,Z,S,I]=getLocalSpace('FermionS',sym [,opts]);   spinful fermions\n   [F,Z,  I]=getLocalSpace('Fermion', sym [,opts]);   spinless fermions\n   [S,    I]=getLocalSpace('Spin', S      [,opts]);   spin-S operators [SU(2)]\n   [S,    I]=getLocalSpace('SUN',N        [,opts]);   SU(N) site\n   [S,    I]=getLocalSpace('SU&lt;N&gt;',       [,opts]);   same as previous\n   [S,    I]=getLocalSpace('SON',5,       [,opts]);   SO(N) site\n   [S,    I]=getLocalSpace('SO&lt;N&gt;',       [,opts]);   SO(N) site\n   [S,    I]=getLocalSpace('Sp&lt;2N&gt;',      [,opts]);   Sp(SN) site\n\nOptions\n\n  'NC',..  number of channels (fermionic systems only)\n  '-A',..  use abelian symmetry (in 'Spin' mode only)\n  '-v'     verbose mode\n\nSymmetries for sym (single string, separated by commas)\n\n  'Acharge'      abelian total charge;        Acharge(:)  *)\n  'SU2charge'    SU(2) total particle-hole;   SU2charge(:) *)\n  'Aspin'        abelian total spin\n  'SU2spin'      SU(2) total spin (S)\n  'SU2spinJ'     SU(2) total spin (J=L+S)\n  'AspinJ'       U(1) total spin (J=L+S)_z\n  'SUNchannel'   SU(N) channel symmetry\n  'SONchannel'   SO(N) channel symmetry\n  'SpNchannel'   Sp(N) particle/hole (charge) * channel symmetry\n\n*) sym(:) indicates to use given symmetry &lt;sym&gt; for each\n   of the NC channels individually.\n\nExamples\n\n three channels with particle-hole SU(2) in each channel and total spin SU(2)\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','SU2charge(:),SU2spin','NC',3,'-v');\n\n three channels with abelian charge, SU(2) spin and SU(2) channel\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin,SUNchannel','NC',3,'-v');\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin,SU3channel','-v'); same\n\n three channels with SO(N) symmetry\n so far NC=3 only since this reduces to SU(2) with integer spins\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin,SO3channel','-v');\n   --&gt; IS.L3 contains L=1 `spin opertors' in orbital space\n\n three channels with SU2spinJ symmetry (total J=L+S)\n   [FF,Z,JJ,IS]=getLocalSpace('FermionS','Acharge,SU2spinJ','NC',3,'-v');\n\n three spinless channels with SU(3) channel symmetry\n   [FF,Z,IS]=getLocalSpace('Fermion','SUNchannel','NC',3,'-v');\n\n single spin-S site\n   [S,IS]=getLocalSpace('Spin',1,'-v'); \n\n   [S,IS]=getLocalSpace('SUN',3,'-v');  same as ...\n   [S,IS]=getLocalSpace('SU3','-v');\n\nExamples with flavor groups / split channels // Wb,Feb16,18\n\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','SU2spin,Acharge,SUNchannel','NC',[2 1],'-v');\n\n   [FF,Z,IS]=getLocalSpace('Fermion','Acharge,SUNchannel','NC',[2 1],'-v');\n\n   note that in the spinless case for an odd number of flavors,\n   their total charge label is taken to half-filling;\n   therefor if a group in NC has odd number nc of flavors,x\n   then the total charge labels are given by (2*nc-1).\n   getLocalSpace issues a NB/WRN in that respect.\n\nWb,Jul09,11 ; Wb,Jul30,12\n</code></pre>"},{"location":"tutorial/QSpace_intro/","title":"Get to Know QSpace","text":"<p>Author: Seung-Sup Lee</p> <p>QSpace is a powerful tensor network library developed by Andreas Weichselbaum, a long-term colleague of our group. This library enables the generation and manipulation of tensors that respect general Abelian and non-Abelian symmetries. It consists of many MATLAB functions (.m), as well as MEX functions (.mexa64 or .mexamaci64) that are binary files written in C++. These MEX functions are used for computationally demanding jobs, such as contraction and eigendecomposition. Thus using the QSpace library can be more efficient, even without exploiting symmetries, than the bare MATLAB code!</p> <p>The goal of this tutorial is to provide the practical knowledge on using the QSpace library and understanding QSpace objects. For the details of physical and mathematical concepts (e.g., IROP, IREP), please refer to A. Weichselbaum, Ann. Phys. 327, 2972 (2012) and A. Weichselbaum, Phys. Rev. Research 2, 023385 (2020).</p>"},{"location":"tutorial/QSpace_intro/#clebsch-gordan-coefficient-data","title":"Clebsch-Gordan coefficient data","text":"<p>The key idea of QSpace is to decompose the tensor into two parts, Clebsch-Gordan coefficients and reduced matrix elements, and to treat them separately. The reduced matrix elements may change depending on the system parameters, while the Clebsch-Gordan coefficients are generic. For example, two spin-1/2's should be always combined anti-symmetrically to make the spin singlet, independent of system parameters. So, once the coefficients are generated, they can be recycled for the next calculations.</p> <p>In this regard, the QSpace library generates Clebsch-Gordan coefficient data on the fly, e.g., when tensors are manipulated. The Clebsch-Gordan coefficients are tensors by themselves, and stored in a disk drive. The path to the directory in which the data is stored is saved as a MATLAB environment variable (not a shell variable) RC_STORE. To see the path, type in the MATLAB Command Window:</p> <pre><code>getenv('RC_STORE')\n</code></pre> <p>ans = '/Users/S.Lee/data/RCStore' </p> <p>startup.mwhich we provided automatically sets the path and creates the corresponding directory, if not exists.</p> <p>The Clebsch-Gordan data generated on the fly are indexed depending on their order of appearance. Therefore, it is possible that the same Clebsch-Gordan coefficients are indexed differently, or vice versa. So manipulating (e.g., contracting) one QSpace object generated from the calculation on one machine and another QSpace objected generated from the other calculation on the other machine can lead to the inconsistency of the Clebsch-Gordan coefficients. Therefore, it is advised to generate large enough set of the Clebsch-Gordan data and use the data set for different calculations. However, for the tutorial here, this is not important: The Clebsch-Gordan coefficients relevant to this tutorial can be generated from scratch with very small computational cost.</p>"},{"location":"tutorial/QSpace_intro/#generate-local-operators","title":"Generate local operators","text":"<p>The first step of using QSpace is to identify which symmetries in the system are to be exploited. Then we generate the tensors that respect such symmetries. The tensors for a local space (e.g., one lattice site) are generated by getLocalSpace. For example, we obtain the operators that act on a spin-1/2 site and respect SU(2) spin symmetry:</p> <pre><code>clear\n[S,I] = getLocalSpace('Spin', 1/2);\nS  % spin operator\n</code></pre> <p>S = \u00a0\u00a0\u00a0Q:  1x [1 1 1] having 'SU2',\u00a0\u00a0\u00a0operator, \u00a0\u00a0\u00a0{ , * , * }   data:  3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 2 x 3  \u00a0\u00a0\u00a01.  1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| 2x2x3\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.225 <pre><code>I  % struct that contains various information\n</code></pre></p> <p>I = struct with fields: \u00a0\u00a0\u00a0\u00a0Sloc: 0.5000 \u00a0\u00a0\u00a0\u00a0\u00a0SOP: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0sym: 'SpinS' \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0U: [2x2 double] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Is: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E: [1x1 QSpace]</p> <p><pre><code>I.E  % Identity operator\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'SU2',\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>Meaning of the displayed information will be explained in the next section.</p> <p>On the other hand, the operators for one spinful fermionic site, which respect U(1) charge and SU(2) spin symmetries, are generated by:</p> <pre><code>[F,Z,S,I] = getLocalSpace('FermionS', 'Acharge,SU2spin','NC', 1);\n</code></pre> <p>Here 'FermionS' means spinful fermion, 'Acharge,SU2spin' means U(1) charge (A from Abelian) and SU(2) spin symmetries, and 'NC',1' means that there is only one channel (NC from number of channels).</p> <p><pre><code>F % particle annihilation operator\n</code></pre> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p><pre><code>Z % fermionic sign operator\n</code></pre> Z =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0(1.414) \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01</p> <p><pre><code>S % spin operator\n</code></pre> S =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0 operator, \u00a0\u00a0{  , * , * } \u00a0data: 3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 2 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ; 0 2  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.225</p> <p><pre><code>I.E % identity operator\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0(1.414) \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01</p> <p>F and S are rank-3 tensors, since they change charge and spin quantum numbers. On the other hand, Zand I.E are rank-2 tensors, since they do not change quantum numbers; that is, they are scalars in terms of the Clebsch-Gordan coefficients.</p> <p>getLocalSpace can deal with general situations. For details, type in the MATLAB command window: 'help getLocalSpace'.</p>"},{"location":"tutorial/QSpace_intro/#differences-from-the-tn-tutorial-materials","title":"Differences from the TN tutorial materials","text":"<p>Careful readers might have realized that the syntax of getLocalSpace here is similar to that of TN/Tensor/getLocalSpace which has been used for the previous tutorials. Actually, the TN tutorial materials are designed to be consistent with the syntax convention of the QSpace library. Here by TN, I mean the tutorial materials that we have used so far during the course, whose computational routines are pure MATLAB .m files.</p> <p>There are, however, a few differences between the conventions of TN and QSpace that need to be kept in mind. </p> <p>1. The last output I of getLocalSpace in the TN material is the identity operator, while I from the QSpace function is the struct variable that contains the identity operator.</p> <p>2. The leg order convention is different. For the rank-2 tensors (e.g., identity I and fermion sign Z), the convention is the same as in the TN material.</p> <p> </p> <p>The numbers attached to the legs are the order of legs. The first (bottom) and second (top) legs are to be contracted with bra and ket states, respectively. On the other hand, the QSpace convention for the rank-3 tensors (e.g., fermion annihilation F and spin S) generated by getLocalSpace is different:</p> <p> </p> <p>Here the first and second legs have the same roles as for the rank-2 tensors, while the third leg indicates the nature of operator (e.g., spin-raising, annihilating particle of a specific spin at a specific channel). In the TN convention, the top leg is at the third place and the operator leg is at the second place.</p> <p>While the TN convention is better compatible with covariant formulation of tensors, the QSpace convention has practical advantage. Typically, the bottom and top legs of tensors can involve large dimensions. For example, consider a situation when we compute correlator of two operators acting on different sites in a one-dimensional system. We should contract the bra and ket tensors and the local operators iteratively, all the way from one site to the other. At each iteration, the dimensions of the bottom and top legs are bond dimensions, while the operator leg has small dimensions (e.g., 1 for a single spin-\\(z\\) operator and 3 for a full spin operator). Practically, it is better to place the legs of the largest dimensions to the front; then in most cases the tensors are matrices, not multi-dimensional arrays.</p> <p>3. The leg directions are incorporated in QSpace objects, while the leg directions are rather bookkeeping in the TN materials. The tensors in the TN materials are just matrices or multi-dimensional arrays that cannot bring the information of leg directions. On the other hand, since the legs of QSpace objects are associated with quantum numbers, the directions of legs (inward or outward) are crucial.</p>"},{"location":"tutorial/QSpace_intro/#understand-qspace-objects","title":"Understand QSpace objects","text":"<p>Let me explain how to interpret the displayed information, with the example of identity operator I.E and particle annihilation operator <code>F</code>. <pre><code>I.E\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01</p> <p>The identity operator I.E shows that there are three symmetry sectors: [-1 0] is for empty state (no charge, no spin), [0 1] is for singly occupied doublets (one charge, total spin 1/2; doublet means for two states \\(S_z =\\pm 1/2\\)), and [1 0] is for doubly occupied state (two charges, total spin 0; the doubly occupied state for a single orbital should be spin singlet, due to Pauli exclusion principle).</p> <p><pre><code>F\n</code></pre> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>From top left to bottom right:</p> <ul> <li>Q: 2x [2 2 2] : first 2x means that there are two symmetry sectors. [2 2 2] means that there are three legs (so three 2's) and each leg has two quantum numbers (so 2 each). </li> <li>having 'A,SU2' : two quantum numbers are for U(1) (Abelian, so A) and SU(2) symmetries, respectively. </li> <li>operator: FF is an operator with three legs. </li> <li>{, * , * } : itag (index tag) for each leg. The itag indcates the name and the direction of legs. Here the names are not given (since it is just generated from getLocalSpace), while indicating the directions. Empty for the first leg means inward, and * for the second and third legs means outward. See the next sections for the detail of itags. </li> <li>data: 3-D double (240 bytes): the data sector (i.e. reduced matrix elements) are three-dimensional array (since FF is rank-3), and occupies 240 bytes. </li> <li>2 x 2 x 1 : Hilbert space dimension, in terms of symmetry multiplets. It means that there are 2, 2, and 1 multiplets for the first, second, and third legs, respectively. </li> <li>3 x 3 x 2 : Hilbert space dimension, in terms of bare states (not multiplets). It means that there are 3, 3, and 2 states for the first, second, and third legs, respectively. </li> <li>1. 1x1x1 | 1x2x2: The first symmetry sector (so 1.) has the reduced matrix elements as 1x1x1 array in the multiplet basis. And a single multiplet representing the sector has multiplet dimension 1x2x2, that is, the multiplet corresponds to one state for the first leg and two states for the second and third legs, respectively. </li> <li>[ -1 0 ; 0 1; -1 1 ] : Quantum numbers for each symmetry sector. Each chunk separated by ; indicates the quantum number for each leg. As we used 'Acharge,SU2spin' option for getLocalSpace, the first number for each chunk is the charge quantum number (number of charges with respect to half filling) and the second number is the spin quantum number (total spin multiplied by 2). So we see that, for this first symmetry sector, the first leg space has no charge (charge quantum number -1, since half filling has one charge), and no spin (spin quantum number 0). And the second leg space has one charge (charge quantum number 0) and total spin 1/2 (spin quantum number 1). Finally the quantum number [-1 1] of the third chunk shows how the operator FF changes quantum number; it decreases charge quantum number by 1 (since it is an annihilation operator) and it is indeed a spinor of total spin 1/2 (spin quantum number is the total spin multiplied by 2) </li> <li>-1.414 : It is the reduced matrix element for the first symmetry sector. </li> </ul>"},{"location":"tutorial/QSpace_intro/#access-data-in-qspace-objects","title":"Access data in QSpace objects","text":"<p>The information of QSpace objects can be accessed in a similar way as for struct variables. The quantum numbers of F are accessed by: <pre><code>F.Q % cell array of quantum numbers\n</code></pre></p> <p>ans = 1x3 cell  1 2 3 1 [-1,0;0,1] [0,1;1,0] [-1,1;-1...] <p></p> <p><pre><code>F.Q{1} % first leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a01 </p> <p><pre><code>F.Q{2} % second leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a00 <pre><code>F.Q{3} % third leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a01 </p> <p>A m-th row of F.Q{n} indicates the quantum number of the m-th symmetry sector for the n-th leg space.</p> <p>The reduced matrix elements are accessed by: <pre><code>F.data % cell array of reduced matrix element data\n</code></pre></p> <p>ans = 2x1 cell  1 1 -1.4142 2 -1.4142 <p></p> <p><pre><code>celldisp(F.data) % display the contents of a cell array\n</code></pre> Of course, we can change the values of the data sector. For example, <pre><code>F2 = F;\nF2.data{1} = 10;\nF2\n</code></pre></p> <p>F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>Also we can set and edit the itags (index tags). The itags are saved as the cell array .info.itags. Each cell element is a char array, which should be consistent with the direction of each leg. When the itag of a leg ends with , it means that the leg is outward. Otherwise, the leg is inward. Since the original direction was in-out-out, the first itag should not include  and the second and third itags should end with *. <p><pre><code>F2.info.itags = {'s00','s00*','op*'}\n</code></pre> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ s00, s00 , op } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>Here the name of the space, s00, for the first and second legs means that the legs act on the space of the local site s00. And the name op for the third leg means that it indicates the nature of the operator, not acting on the physical space.</p> <p>One can try to set the itags to be inconsistent with the original itags. Then the QSpace library detects the inconsistency in the data and gives error message.</p> <p><pre><code>try\n    F2.info.itags = = {'s00','s00'','op*'};\n    F2\ncatch e\n    getReport(e);\nend\n</code></pre> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2]\u00a0\u00a0 having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ s00, s00 , op* } ./clebsch.cc:3605\u00a0\u00a0 15:29:54\u00a0ERR init() got CGR QSet mismatch ./clebsch.cc:3605\u00a0\u00a015:29:54\u00a0ERR\u00a0U(1) (-1,0,-1) &lt;&gt; U(1)  </p> <p>The itags are really useful when we treat many tensors at the same time. For example, when many tensors are contracted sequentially (as in TN/Tensor/updateLeft), tracking down the leg order at each contraction step is quite tedious job, and is often the source of bug, if one makes a mistake in counting the leg order. By using itags, however, the QSpace library performs the sanity check for the compatibility of legs, and enables the contraction multiple tensors/legs with simple syntax!</p> <p>We emphasize that one can directly edit only the reduced matrix elements (.data) and itags (.info.itags) of QSpace objects. Tinkering any other part of QSpace object may break the consistency of data; and the QSpace library detects such consistency, as you see from the above example of wrong itags.</p>"},{"location":"tutorial/QSpace_intro/#basic-operations","title":"Basic operations","text":"<p>QSpace library provides an efficient way of manipulating the tensors, in a similar way as the standard numerical arrays of MATLAB.</p> <p>First, one can generate the array of empty QSpace objects, similarly as zeros. <pre><code>M = QSpace\n</code></pre> M = (empty QSpace)  <pre><code>M = QSpace(3,1)\n</code></pre> M = (empty QSpace) ... M(3) = (empty QSpace)  <pre><code>size(M)\n</code></pre> ans = 1x2 \u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a01 </p> <p>And we can add and subtract QSpace objects. <pre><code>Z\n</code></pre> Z =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. <pre><code>I.E\n</code></pre></p> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p> <pre><code>Z - I.E % minus\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <p>Multiply a number to QSpace object. <pre><code>Z*3 % multiply number\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ;\u00a0 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ;\u00a0 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.</p> <p>Take complex conjugation. <pre><code>F\n</code></pre></p> <p>F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ , *, *  } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; \u00a01 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414.</p> <p><pre><code>conj(F) % complex conjugation\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ *, ,  } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414.</p> <pre><code>F1 = F;\nF1.data{1} = 1i;\nconj(F1)\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ *, ,  }\u00a0\u00a0\u00a0complex \u00a0data: 3-D double (232 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1i \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>We see that the complex conjugation of QSpace object flips all the leg directions (inward vs. outward) and takes the complex conjugate to the reduced matrix elements (numerical arrays in .data{..}).</p> <p>The permutation of the legs can be done by permute, which is the wrap-up routine for the binary MEX function permuteQS.</p> <pre><code>permute(F,[2 1 3]) % permute top and bottom legs \n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ * , ,* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p><pre><code>permute(F,'213') % equivalent expression to the above \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ * , ,* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>Also the complex conjugation can be done together with permutation, by setting the option 'conj' in the syntax of permute. Then the Hermitian conjugate, which is the combination of the complex conjugate and transpose, to the particle annihilation operator F is obtained by:</p> <p><pre><code>permute(F, [2 1 3],'conj') % creation operator \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *, }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p><pre><code>permute(F,'213*') % equivalent expression to the above \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *, }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>That is, it becomes the particle creation operator. The tensor network diagram for this is:</p> <p> </p> <p>The Hermitian conjugation for rank-2 operator is:</p> <p><pre><code>permute(I.E,[2 1],'conj') \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.</p> <p>We see that the identity operator is Hermtian:</p> <p><pre><code>I.E - permute(I.E,[2 1],'conj') \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <p>Interestingly, the wrap-up function has the same name as the MATLAB bulit-in permute. Will it be a problem? Answer is no. MATLAB finds and executes a proper routine depending on the type of input variables. When it detects QSpace objects as input, it calls the routine QSpace/Class/@QSpace/permute which is the wrap-up of the MEX function QSpace/bin/permuteQS .</p> <p><pre><code>which permute(F) \n</code></pre> /Users/S.Lee/Documents/MATLAB/QSpace_v3/Class/@QSpace/permute.m \u00a0 % QSpace method</p> <p>On the other hand, if we give a numeric array, then MATLAB calls the built-in function.</p> <p><pre><code>M = [1,2;3,4];\nwhich permute(F) \n</code></pre> built-in (/Applications/MATLAB_R220a.app/toolbox/matlab/elmat/@double/permute) \u00a0 % double method</p> <p><pre><code>permute(M,[2 1]) % transpose \n</code></pre> ans =  2 x 2 \u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a0\u00a02 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a04 </p> <p>To see the documentations for MEX functions (which are binary files stored in QSpace/bin), type in the MATLAB Command Window:</p> <p>&gt;&gt;Name_of_MEX_function -?</p> <p>For example, for permuteQS, type:</p> <pre><code>permuteQS   -? \n</code></pre> <p>Usage: A = permuteQS(A, P [,'conj']) \u00a0\u00a0\u00a0\u00a0\u00a0permute input QSpace using given permutation P.  \u00a0\u00a0\u00a0\u00a0\u00a0Optional trailing 'conj' also applies (complex) conjugation \u00a0\u00a0\u00a0\u00a0\u00a0(note that this also affects real QSpaces in that qdir and \u00a0\u00a0\u00a0\u00a0\u00a0itags are altered!).  \u00a0\u00a0\u00a0\u00a0\u00a0For convenience, P[,'conj'] may also be represented as \u00a0\u00a0\u00a0\u00a0\u00a0single string, e.e. [2 1],'conj' is equivalent to '2,1;' \u00a0\u00a0\u00a0\u00a0\u00a0or '21' where the convention on string notation \u00a0\u00a0\u00a0\u00a0\u00a0follows that of contraction indices [ctrIdx]  \u00a0\u00a0\u00a0\u00a0\u00a0NB! [06/02/2019] the provided permutation can be shorter \u00a0\u00a0\u00a0\u00a0\u00a0than the rank of the QSpace; in this case it only affects the \u00a0\u00a0\u00a0\u00a0\u00a0leading range of indices, i.e., acts like an identity \u00a0\u00a0\u00a0\u00a0\u00a0on the remainder of indices.  AW (C) Aug 2006 ; May 2010 ; Oct 2014 </p>"},{"location":"tutorial/QSpace_intro/#select-subspace","title":"Select subspace","text":"<p>We can select part of symmetry sectors, by using getsub. <pre><code>I.E\n</code></pre></p> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <pre><code>getsub(I.E,2)  % select the second sector \n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{-1.414} <pre><code>getsub(I.E,[1 3])  % select the first and third sectors \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>To choose the sectors of specific quantum numbers, we can combine getsub, find, and ismember (the latter two are MATLAB built-ins.) <pre><code>getsub(I.E,find(ismember(I.E.Q{1},[0 1],'rows'))) % choose [0 1] sector \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>It can be done also with all and bsxfun. <pre><code>getsub(I.E,find(all(bsxfun(@eq,I.E.Q{1},[0 1]),2))) % the same \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p>"},{"location":"tutorial/QSpace_intro/#contraction","title":"Contraction","text":"<p>The contraction of tensors can be done by contract (which is the wrap-up of MEX function contractQS). By exploiting symmetries, the contraction of QSpace objects is done for every symmetry sectors. Only the sectors of two tensors, whose quantum numbers are identical, are to be contracted. And the QSpace library automatically and seamlessly treats the contraction of the Clebsch-Gordan coefficients; we users need to only care about reduced matrix elements.</p> <p>For example, the particle number operator \\(\\hat{n} =\\sum_{\\sigma } {\\hat{f} }_{\\sigma }^{\\dagger } {\\hat{f} }_{\\sigma }\\) can be obtained by:</p> <p><pre><code>NF = contract(F, '1,3;*',F, '1,3') \n</code></pre> NF =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p> <p>We see that the sector of quantum number [0 1]has one particle (see .data{1} is 1) and the sector of [1 0] has two (see .data{2} is 2).</p> <p>In the usage of contract, * at the end of the second input '1,3;*'means that the first input F is complex conjugated before contraction. And '1,3' in the second and fourth inputs mean that the first legs ('1' and '1' each) and the third legs ('3' and '3'each) are contracted, respectively. The tensor network diagram for this is:</p> <p> </p> <p>Here F* means the complex conjugate to F.</p> <p>By using itags, the contraction can be made simpler. For example, the number operator can be obtained by: <pre><code>F1 = F;\nF1.info.itags = { 's00', 's00*', 'op*'};\nNF = contract(F1,'!2*',F1) \n</code></pre> NF =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p> <p>In the usage of contract here, '*' at the end of the second input  '!2*' means that the first input F is complex conjugated, and '!2' in the second input means that all the legs of the first input except the second leg are contracted to the legs of the third input, as long as their itags match. Only the pair of outward leg (e.g., with itag 's00*') and inward leg (e.g., with itag 's00') of the same name can be contracted.** Here, the first legs and the third legs have compatible itags, so they are contracted.</p> <p>Also, the contract function supports multiple contractions in a single line syntax. For example, the squared number operator \\(\\sum_{\\sigma \\sigma^{\\prime } } {\\hat{f} }_{\\sigma }^{\\dagger } {\\hat{f} }_{\\sigma } {\\hat{f} }_{\\sigma^{\\prime } }^{\\dagger } {\\hat{f} }_{\\sigma^{\\prime } }\\) can be obtained by:</p> <pre><code>N2 = contract(F1, '!2*',{F1, '!1',{F1,  '!2*',F1}});\n</code></pre> <p>N2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.</p> <p>In such syntax, the contraction inside the inner-most parenthesis { } is performed first, and then the contraction for the next inner-most parenthesis is done, and so on. In the above example, the parenthesis are given so that the contraction is performed over two right-most tensors, and contract the left ones iteratively. For details, type:</p> <p>&gt;&gt; contractQS -?</p>"},{"location":"tutorial/QSpace_intro/#rank-2-tensors","title":"Rank-2 tensors","text":"<p>Rank-2 tensors are of the simplest type. (Quick exercise: Why not rank-1?) They are scalar in terms of Clebsch-Gordan coefficients and there is no (outer) multiplicity of symmetry sectors. And their reduced matrix elements form matrices.</p> <p>So the QSpace library enables to treat rank-2 QSpace objects, in a way that usual matrices are treated by MATLAB built-in functions.</p> <pre><code>Z.'  % transpose\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <pre><code>Z'  % Hermitian conjugate\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p><pre><code>Z' - Z  % Z is Hermitian\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <pre><code>Z * I.E  % matrix multiplication as contraction\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>As in the case of permute explained above, MATLAB can execute different functions depending on the type of inputs. That is, there are several QSpace functions that override the MATLAB built-in functions.</p> <p>This simplification also works for some rank-3 tensors (whose .info.otype is set as 'operator'').</p> <pre><code>F  % Hermitian conjugate, the result is particle creation operators\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *,  }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>However, it is advisable to use permute and  contract in general, to avoid any mistake.</p>"},{"location":"tutorial/QSpace_intro/#vacuum-space","title":"Vacuum space","text":"<p>The left end and the right end of the matrix product states (MPS) are dummy legs of dimension 1. These dummy legs are introduced to represent all the constituent tensors (so-called A and B tensors) as being rank-3. Thus the dummy legs point to the space which has nothing, i.e., vacuum. The vacuum space carries no quantum number at all, and it is different from the empty state which has specific quantum number. The vacuum space for given set of symmetries is obtained by using getvac:</p> <p><pre><code>getvac(I.E)\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 1 x 1  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 0 ; 0 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p>"},{"location":"tutorial/QSpace_intro/#generate-identity-operators-and-isometries","title":"Generate identity operators and isometries","text":"<p>We can obtain identity operators and isometries by using getIdentity(which is the wrap-up of MEX function getIdentityQS). There are three contexts of using getIdentity.</p> <p>1. Obtain the identity operator for a given leg space.</p> <p>For example, the following provides the identity operator for the Hilbert space of the second leg of F. <pre><code>FE2 = getIdentity(F,2)\n</code></pre></p> <p>FE2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>Note that FE2 is different from the identity operator I.E that is for the whole Hilbert space of a spinful fermionic site, since FE2 does not contain the subspace in which there is no particle (with quantum number [-1 0]).</p> <pre><code>I.E - FE2(F,2)\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2.22e-16\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <p>2. Generate the isometry that combines the spaces of two legs.</p> <p>Let's create the isometry (so-called A tensors) which combines two local spaces (each of which spans for a spinful fermionic site) to span the product space. In this case, to distinguish different local spaces, it is advised to use itags.</p> <pre><code>E1 = I.E;\nE1.info.itags = { 's00', 's00*'};\nE2 = I.E;\nE2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2) \n</code></pre> <p>A =  \u00a0\u00a0\u00a0\u00a0Q: 10x [2 2 1] having 'A,SU2',\u00a0\u00a0\u00a0A-matrix,\u00a0\u00a0\u00a0{ s00, s01, * }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (1200 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 x 10 =&gt; 4 x 4 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 0 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a01 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; -1 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.732\u00a0\u00a0\u00a0\u00a08. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a01 0 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 1 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. </p> <p>The corresponding diagram is:</p> <p> </p> <p>This isometry is left-normalized. (Quick exercise: check this!) Such isometries are the building blocks of the MPS.</p> <p>In the lecture course, the convention for ordering the legs of isometries is left-bottom-right, as A is so here. However, many functions and programs in and based on the QSpace library use different convention: left-right-bottom. The same reason, explained in the previous section on the convention differences, applies here as well. Typically the left and right legs have the largest dimensions, while the bottom leg acts on low-dimensional local space. So placing the left and right legs before the bottom leg is more practical.</p> <p>getIdentity also supports (i) setting the itag for a newly generated leg spanning the product space and (ii) permuting legs in a single line.</p> <pre><code>A = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);\n</code></pre> <p>A =  \u00a0\u00a0\u00a0\u00a0Q: 10x [2 2 1] having 'A,SU2',\u00a0\u00a0\u00a0A-matrix,\u00a0\u00a0\u00a0{ s00, A01*, s01 }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (1200 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 x 10 =&gt; 4 x 4 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ; \u00a00 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ; -1 0 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ; \u00a01 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ; \u00a00 1 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 0 ; -1 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x3x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 2 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.732\u00a0\u00a0\u00a0\u00a08. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a01 1 ; \u00a01 0 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 1 ; \u00a00 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a02 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. </p> <p>Here the 5th input is the itag, and the 6th input is the permutation indices.</p> <p>3. Generate a \\(1j\\) symbol to invert the direction of the legs.</p> <p>As we have learned from the lecture, it is crucial to flip the leg directions to bring the MPS into different canonical forms (see the material for Tutorial T02a). While inverting leg directions was of mere bookkeeping purpose in the TN materials, it should be performed explicitly for the QSpace objects.</p> <p>For example, let's invert the third leg of particle annihilation operator.</p> <pre><code>F1 = F;\nF1.info.itags = { 's00', 's00*', 'op*'};\nF1\n</code></pre> <p>F1 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00*, op* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 \u00a01 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 \u00a00 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <pre><code>I0 = getIdentity(F1,3, '-0')\n</code></pre> <p>I0 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ op, op }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>The generated operator I' is rank-2, and has all-in legs. By looking at the quantum numbers associated with the third leg of F1, we see that the first leg of I0 corresponds the third leg of F1. The tensor network diagram for I0 is:</p> <p> </p> <p>Here the left and right legs in solid lines are the first and second legs, respectively.</p> <p>In this diagram, we see an implicit leg drawn in dashed line, which does not appear in the display information above. This implicit leg carries all zero quantum numbers since the sum of the quantum numbers of incoming legs should be the same as the sum of those of outgoing legs (i.e., Kirchoff's law for quantum numbers). Note that the second quantum number is spin quantum number (multiplied by 2) associated with the SU(2) symmetry, and the spin quantum number for the implicit leg is zero (which means spin singlet). In other words, the Hilbert space for this implicit leg is vacuum; that's why the leg does not show up explicitly in the numerical object.</p> <p>In the space of explicit legs, the \\(1j\\) symbol behaves as unitary operation. So the tensor network state on which \\(1j\\) symbol is acted can differ from the original state. One exception is that the explicit leg to be flipped acts on one-dimensional Hilbert space, where the unitary operation reduces to a single prefactor. Therefore, in general, it is required to consider the pair of \\(1j\\) symbol and its conjugate. When a \\(1j\\) symbol is acted, then its conjugate should be introduced at some point. This notion of pair can be understood intuitively by considering implicit legs that need to be contracted at last:</p> <p> </p> <p>Let's return to the example of inverting the third leg of F1. We invert the leg by contracting the \\(1j\\) symbol.</p> <pre><code>F1I = contract(F1, '!1',I0, '!2')\n</code></pre> <p>F1I =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00*, op }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 \u00a01 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 \u00a00 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>The resulting F1I is also an annihilation operator, but it has the inward third leg.</p> <p>For details, type: getIdentityQS -?</p>"},{"location":"tutorial/QSpace_intro/#automatic-truncation-of-all-zero-sectors","title":"Automatic truncation of all-zero sectors","text":"<p>The contract (and some other functions) of the QSpace library may remove the sectors whose reduced matrix elements (elements of .data{..}) are all zeros. For example, consider the following case. <pre><code>[F,Z,S,I] = getLocalSpace( 'FermionS', 'Acharge', 'SU2spin', 'NC',1);\nM1 = I.E; M1.info.itags = { 's00', 's00*'};\nM2 = I.E; M2.info.itags = { 's01', 's01*'};\nA = getIdentity(M1,2,M2,2, 'A01*',[1 3 2]);\ncontract(A, '!2*',{M1, '!1',{M2, '!1',A}})\n</code></pre></p> <p>A =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>This is the normal contraction of the identity tensors. The result acts on 16-dimensional space of two spinful fermionic sites.</p> <p>What happens if we replace one sector of A with all-zero reduced matrix elements?</p> <p><pre><code>A.data{1} = zeros(size(A.data{1}));\ncontract(A, '!2*',{M1, '!1',{M2, '!1',A}});\n</code></pre> A =  \u00a0\u00a0\u00a0\u00a0Q: 5x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (672 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09 x 9 =&gt; 15 x 15  \u00a0\u00a0\u00a0\u00a01. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a04. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a05. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. </p> <p>Then we have the sector [-2 0] is missing, and the result acts on 15-dimensional space.</p> <p>It is an intended feature rather than a bug. When contract tensors over the tensor network, the all-zero sectors in the constituent tensors do not contribute to the result. So the truncation of such all-zero sectors yields better computational efficiency.</p> <p>However, when we consider the Hamiltonian in effective basis, the Hamiltonian may have the sectors of all zero matrix elements, and such sectors should be kept. All the energy eigenvalues, whether zero or finite, have meaning! For this, we should enforce to keep all-zero sectors. One trick is to add the identity operator, multiplied by very small number smaller than double precision (e.g., \\(10^{-30}\\)), to the Hamiltonian. Such small number should not change the physical results, but prevents unwanted truncation.</p>"},{"location":"tutorial/QSpace_intro/#eigendecomposition","title":"Eigendecomposition","text":"<p>Let's construct the hopping term \\(\\sum_{\\sigma } {\\hat{f} }_{2\\sigma }^{\\dagger } {\\hat{f} }_{1\\sigma } +{\\hat{f} }_{1\\sigma }^{\\dagger } {\\hat{f} }_{2\\sigma }\\) acting on two spinful fermionic sites.</p> <pre><code>% for site s00\nF1 = F; F1.info.itags = { 's00', 's00*', 'op*'};\nE1 = I.E; E1.info.itags = { 's00', 's00*'};\n% for site s01\nF2 = F; F2.info.itags = { 's01', 's01*', 'op*'};\nE2 = I.E; E2.info.itags = { 's01', 's01*'};\nZ2 = Z; Z2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);\n\nH = contract(A, '!2*',{F1, '!1',{F2, '!2*',{Z2, '!1',A}}}) + ...\n    contract(A, '!2*',{F1, '!2*',{Z2, '!1',{F2, '!1',A}}}) + ...\n    getIdentity(A,2) * 1e-40\n</code></pre> <p>The first line of defining H means \\(\\sum_{\\sigma } {\\hat{f} }_{2\\sigma }^{\\dagger } {\\hat{f} }_{1\\sigma }\\), and the second line means its Hermitian conjugate. And in the third line, we added the identity multiplied by a small number, to let <code>H</code> have all the sectors (that amount to 16 dimensional space).</p> <pre><code>celldisp(H.data)\n</code></pre> <p>ans{1} =  \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a00.0000   ans{3} =  \u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a00.0000   ans{4} =  \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0-1.0000 \u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a00.0000   ans{6} =  \u00a0\u00a0\u00a01.0000e-40 </p> <p>The eigenvalues and eigenvectors of H can be obtained by eig which is the wrap-up of eigQS.</p> <pre><code>[V,D] = eig(H)\n</code></pre> <p>V =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.  D =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (704 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06 x 10 =&gt; 10 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 F and D are QSpace objects. Each data of V is the unitary matrix whose columns are eigenvectors: <pre><code>celldisp(V.data)\n</code></pre></p> <p>ans{1} =  \u00a0\u00a0\u00a01  ans{2} =  \u00a0\u00a0-0.7071\u00a0\u00a0\u00a0\u00a00.7071 \u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a00.7071   ans{3} =  \u00a0\u00a0\u00a0-0.5000\u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0\u00a0-0.5000 \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0-0.5000\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a0-0.5000   ans{4} =  \u00a0\u00a0\u00a01  ans{5} =  \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.7071 \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.7071   ans{6} =  \u00a0\u00a0\u00a01 </p> <p>We can check the unitarity of V by</p> <pre><code>V2 = contract(V, '!2*',V);\nsameas(V2,getIdentity(A,2))\n</code></pre> <p>ans =  logical \u00a0\u00a0\u00a01 </p> <p>Each data of D is the row vector of eigenvalues:</p> <p><pre><code>celldisp(D.data)\n</code></pre> ans{1} = \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0-1.0000  ans{3} =  \u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000  ans{4} = \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0-1.0000  ans{6} = \u00a0\u00a0\u00a01.0000e-40 </p> <p>(Quick exercise: Explain the eigenvalues.)</p> <p>To make D as an operator representing a diagonal matrix,</p> <pre><code>D2 = diag(D)\n</code></pre> <p>V =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 </p> <pre><code>celldisp(D2.data)\n</code></pre> <p>ans{1} =  \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a01.0000   ans{3} =  \u00a0\u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a02.0000   ans{4} =  \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-1.0000   ans{6} =  \u00a0\u00a0\u00a01.0000e-40 </p> <p>One may also directly use the original MEX function eigQS. <pre><code>[E,Ieig] = eigQS(H);\n</code></pre></p> <p>Note that the syntax is a bit different from the wrap-up eig. E is two-column matrix whose first column is the energy eigenvalues (sorted in ascending order) and second column indicates the multiplet dimensions (i.e., degeneracy due to non-Abelian symmetry) associated with the eigenvalues. When only the Abelian symmetries are used, E becomes a column vector, without having the second column for the multiplet dimensions.</p> <pre><code>E\n</code></pre> <p>ans = 10x2  \u00a0\u00a0\u00a0\u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a03.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 </p> <p>And Inrg is the struct that contains more result of the eigendecomposition, including the eigenvectors (.AK and .AT) and eigenvalues (.EK and .ET). <pre><code>Ieig\n</code></pre> ans = struct with fields:  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AK: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AD: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0EK: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ED: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DB: [6x2 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NK: 10 \u00a0\u00a0\u00a0Etrunc: 0 </p> <p>Becasue of the MATLAB policy, the direct result of MEX functions should be of MATLAB built-in types, while the QSpace is the user-defined data type. Here .AK, .AT, .EK, and .ET are struct variables that are compatible with QSpace. So we wrap them up as QSpace objects:</p> <p><pre><code>Ieig.EK = QSpace(Ieig.EK);\nIeig.AK = QSpace(Ieig.AK);\nIeig.EK\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 <pre><code>Ieig.AK\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>We can set several options for eigQS, such as Nkeep (number of multiplets to be kept) and Etrunc (threshold energy such that the energy eigenvalues below the value are to be kept). For details, type: eigQS -?</p>"},{"location":"tutorial/QSpace_intro/#singular-value-decomposition","title":"Singular value decomposition","text":"<p>We can perform the singular value decomposition (SVD) of QSpace objects, by using MEX function svdQS. The first input to svdQSis a QSpace object whose legs are all in. Indeed, this notion of decomposing all-in tensor is consistent with the diagrammatic expresssion of the Schmidt decomposition.</p> <p>And the second input is the leg indices. The corresponding legs are to be the legs of the third output Vd for right singular vectors. When non-Abelian symmetry is used, it is allowed to choose only one or \\(r-1\\) indices, where \\(r\\) is the rank of the first input. To \"split off\" different number of legs (to be associated with Vd), we need to fuse the legs by using the isometry generated by getIdentity; then perform the SVD; then split the legs by appling the conjugate of the iseometry used to fuse the legs.</p> <p>For example, consider an isometry:</p> <pre><code>[S,I] = getLocalSpace( 'Spin',1/2);\nE1 = I.E; E1.info.itags = { 's00', 's00*'};\nE2 = I.E; E2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2,'A01*',[1 3 2]);\n</code></pre> <p>We need to flip the second leg to perform the SVD.</p> <pre><code>I0 = getIdentity(A,2, '-0');\nAI = contract(A, '!1',I0, '!2*',[1 3 2])\n</code></pre> <p>Then use the svdQS. <pre><code>[U,S,Vd] = svdQS(AI,1);\n</code></pre></p> <p>As mentioned above, the direct outputs from MEX functions are in the form of struct variables, not as QSpace objects. So we need to wrap them up. <pre><code>U = QSpace(U);\n</code></pre> U =  \u00a0\u00a0\u00a0\u00a0Q: 2x [1 1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00*, A01, s01 }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 2 x 1 =&gt; 2 x 4 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 0 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x3x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 2 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.225</p> <p><pre><code>S = QSpace(S)\n</code></pre> S =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0{1.414}</p> <p><pre><code>Vd = QSpace(Vd)\n</code></pre> Vd =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00*, s00 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>The first leg (incoming) of AI is associated with the second leg (incoming) of Vd. And the singular value tensor S is all-in.</p>"},{"location":"tutorial/QSpace_intro/#normalization-convention","title":"Normalization convention","text":"<p>The QSpace library has different conventions of normalizing the Clebsch-Gordan coefficients for rank-2 tensors (such as Z and I.E) and for higher-rank tensors (such as F and S).</p> <p>For rank-2 tensors, the Clebsch-Gordan coefficients are normalized so that the reduced matrix elements have immediately relevant values. The elements of the tensor D (obtained after eig) for the energy eigenvalues are indeed energy eigenvalues. <pre><code>celldisp(D.data)\n</code></pre></p> <p>ans{1} = \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000  ans{3} =  \u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000  ans{4} = \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a01.0000  ans{6} = \u00a0\u00a0\u00a01.0000e-40  Also each cell .data{..} of identity operator I.E contains the identity matrices themselves. <pre><code>celldisp(I.E.data)\n</code></pre></p> <p>ans{1} = \u00a0\u00a0\u00a01.0000 </p> <p>On the other hand, for higher-rank tensors, the Clebsch-Gordan coefficents are normalized so that the contraction of a tensor and its Hermitian conjugate becomes unity, when the reduced matrix elements are unity. For example, consider a rank-3 tensor which is the subspace projection of F, <pre><code>O1 = getsub(F,2)\n</code></pre></p> <p>O1 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , *,  * }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 1 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <pre><code>O1.data{1} = 1; % make the reduced matrix to be trivial 1\n</code></pre> <p>The contraction of O1 and its Hermitian conjugate, with all the legs contracted, is equal to the squared norm of the Clebsch-Gordan coefficents, since the reduced matrix is set as trivial 1.</p> <p><pre><code>contract(O1, '1,2,3',O1, '1,2,3;*')\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>On the other hand, due to the different normalization convention of rank-2 tensors, the contraction of two identity operators, with all the legs contracted, becomes the Hilbert space dimension. <pre><code>contract(I.E, '1,2',I.E, '1,2;*')\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p>"},{"location":"tutorial/QSpace_intro/#outer-multiplicity","title":"Outer multiplicity","text":"<p>When non-Abelian symmetry is used, it is possible that there are multiple sectors with the same quantum numbers, while different sectors are indeed associated with different (orthogonal) Clebsch-Gordan coefficients. It is called outer multiplicity. One simple example is:</p> <pre><code>[S,I] = getLocalSpace( 'Spin',1/2);\nA1 = getIdentity(I.E,2,I.E,2);\nA2 = getIdentity(A1,3,I.E,2);\nA12 = contract(A1, '3',A2, '1')\n</code></pre> <p>A12 =  \u00a0\u00a0\u00a0\u00a0Q: 3x [1 1 1 1] having 'SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , , , * }\u00a0\u00a0\u00a0 \u00a0data: 4-D double (352 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 x 3 =&gt; 2 x 2 x 2 x 8  \u00a0\u00a0\u00a0\u00a01. 1x1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a02. 1x1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a03. 1x1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x4 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 3 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.  The first and second sectors have the same quantum numbers! But, of course, they are orthogonal. Consider their parts:</p> <pre><code>A12a = getsub(A12,1);\nA12a.data{1} = 1;\nA12b = getsub(A12,2);\nA12b.data{1} = 1;\n</code></pre> <p>Here we replaced the reduced matrix elements (.data{..}) with ones, to focus on the Clebsch-Gordan coefficients. Then their overlap, i.e., contraction between A12a and the conjugate of A12b vanishes.</p> <p><pre><code>contract(A12a,'1234',A12b, '1234*');\n</code></pre> ans = (empty QSpace) </p> <p>On the other hand, three incoming legs (from the first to the third) look identical, so it seems that the tensor remains the same after permuting the incoming legs. But it's not! The overlap with A12a and the permutation of the first and third legs of A12a is not unity. It means that the Clebsch-Gordan coefficients can change by permuting legs.</p> <pre><code>contract(A12a,'1234',A12b, '3214*'); % note the 4th input\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.5</p> <p>Why? Let's draw the tensor network diagram for the first and second sectors of A12.</p> <p> </p> <p>Attached to the legs are spin quantum numbers. Fusing two \\(S=1/2\\) (two incoming legs of A1) lead to two values of spin \\(S=0\\oplus 1\\) (outgoing leg of A1). These two values can result in \\(S=1/2\\) (outgoing leg of A2) by being fused with one \\(S=1/2\\) (bottom incoming leg of A2). The outer multiplicity of A12 reflects this two different ways of having four legs of \\(S=1/2\\). In this diagram, it is clear to see that the left leg of A1 and the bottom leg of A2 are not equivalent.</p> <p> </p>"},{"location":"tutorial/getLocalSpace/","title":"Starting Point: <code>getLocalSpace</code>","text":"<p>The <code>getLocalSpace</code> function in the QSpace library is the foundational step for generating tensors with symmetries, serving as the crucial starting point for any tensor algorithm within this framework. It's designed to construct local model state spaces, incorporating a variety of quantum operators like spin, annihilation, and charge parity. The function also supports a wide range of symmetries, including abelian and non-abelian groups like SU(2) and SU(N). This makes <code>getLocalSpace</code> a versatile tool for building tensor networks with different symmetries, crucial for quantum physics research.</p>"},{"location":"tutorial/getLocalSpace/#understanding-the-function-syntax","title":"Understanding the Function Syntax","text":"<ul> <li>General Form: <code>[FF,...,Iout]=getLocalSpace(model, ['sym1,sym2,...', varargin])</code></li> <li>Parameters Explained:<ul> <li><code>model</code>: This denotes the quantum model type. It could be fermions (spinful/spinless), spin operators, etc.</li> <li><code>sym1, sym2, ...</code>: These are symmetries applicable to the model. Examples include total charge, spin, and particle-hole symmetry.</li> <li><code>varargin</code>: Additional options for customizing the function's operation, like specifying the number of channels or enabling verbose mode for detailed output.</li> </ul> </li> </ul>"},{"location":"tutorial/getLocalSpace/#delving-into-supported-models-and-options","title":"Delving into Supported Models and Options","text":"<p>The <code>getLocalSpace</code> function in QSpace supports a diverse range of models, each tailored for specific quantum systems. This includes:</p> <ol> <li>Fermionic Systems: Both spinful and spinless fermions are supported, allowing for simulations of electrons with or without spin considerations.</li> <li>Pure Spin Models: These models focus solely on the spin aspect, crucial for studies in spin dynamics and spin-based quantum interactions.</li> <li>Various Quantum Groups: The function supports a variety of groups like SU(2), SU(N), SO(N), and Sp(2N), each offering different symmetry structures for the tensors.</li> </ol> <p>In terms of options, <code>getLocalSpace</code> provides flexibility through parameters like:</p> <ul> <li><code>NC</code> (number of channels): Defines the complexity of the system, particularly in fermionic models.</li> <li><code>-A</code> (abelian symmetry): Simplifies the model by using abelian symmetries, useful for certain theoretical studies.</li> <li><code>-v</code> (verbose mode): Offers detailed output for in-depth analysis and debugging.</li> </ul> <p>Each model and option in <code>getLocalSpace</code> is designed to give users precise control over their tensor network configurations, making it a versatile tool in quantum physics research.</p>"},{"location":"tutorial/getLocalSpace/#comprehensive-guide-to-symmetries","title":"Comprehensive Guide to Symmetries","text":"<ul> <li>Symmetry Types Explained:<ul> <li><code>Acharge</code>: Represents abelian total charge symmetry, used in charge-conserving quantum models.</li> <li><code>SU2charge</code>: Denotes SU(2) symmetry for total particle-hole systems, pivotal in complex quantum systems.</li> <li><code>Aspin</code>: Abelian total spin symmetry, applicable in spin-conserving models.</li> <li><code>SU2spin</code>: A non-abelian symmetry representing total spin, essential for studying spin interactions.</li> <li><code>SU2spinJ</code>: Combines orbital (L) and spin (S) symmetries, denoted as J=L+S.</li> <li><code>AspinJ</code>: A U(1) symmetry for total spin (J=L+S)_z.</li> <li><code>SUNchannel</code>: Represents SU(N) channel symmetry, crucial for studying systems with N-level quantum states.</li> <li><code>SONchannel</code>: SO(N) channel symmetry, applicable in certain types of quantum models.</li> <li><code>SpNchannel</code>: Sp(N) symmetry, used in particle/hole charge models with channel symmetry.</li> </ul> </li> <li>Application: Each symmetry type tailors the quantum model to specific physical properties and interactions.</li> </ul>"},{"location":"tutorial/getLocalSpace/#examples","title":"Examples","text":"<ol> <li> <p>Pure Spin Model (Spin-1 System):</p> <ul> <li><code>[S,IS]=getLocalSpace('Spin',1,'-v');</code></li> <li>Configures a single spin-1 site, useful for studying isolated spin dynamics.</li> </ul> </li> <li> <p>Spinless Fermions with SU(3) Channel Symmetry:</p> <ul> <li><code>[FF,Z,IS]=getLocalSpace('Fermion','SUNchannel','NC',3,'-v');</code></li> <li>Sets up three spinless fermion channels with SU(3) symmetry.</li> </ul> </li> <li> <p>Spinful Fermions with Abelian Charge and SU(2) Spin:</p> <ul> <li><code>[FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin','NC',3,'-v');</code></li> <li>Constructs a system with three channels, each having an abelian charge and an SU(2) spin symmetry.</li> </ul> </li> <li> <p>Spinful Fermions with Particle-Hole Symmetry:</p> <ul> <li><code>[FF,Z,SS,IS]=getLocalSpace('FermionS','SU2charge(:),SU2spin','NC',3,'-v');</code></li> <li>Creates a spinful fermion model with individual SU(2) charge symmetry in each of three channels and an overall SU(2) spin symmetry.</li> </ul> </li> <li> <p>Spinful Fermions with SU(2) SpinJ Symmetry:</p> <ul> <li><code>[FF,Z,JJ,IS]=getLocalSpace('FermionS','Acharge,SU2spinJ','NC',3,'-v');</code></li> <li>This example configures spinful fermions with a combined orbital and spin symmetry (SU(2) SpinJ).</li> </ul> </li> </ol>"},{"location":"tutorial/getLocalSpace/#decoding-the-outputs","title":"Decoding the Outputs","text":"<ul> <li>Output Variables: <code>FF</code>, <code>Iout</code>, and others vary based on the selected model. They represent the quantum states and operators configured by <code>getLocalSpace</code>.</li> <li>Usage in Quantum Models: These outputs form the backbone of tensor network states, used in simulations and calculations in quantum physics.</li> </ul>"}]}