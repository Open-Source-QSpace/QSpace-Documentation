{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is QSpace?","text":"<p>QSpace is an advanced open-source tensor library specifically designed to handle both Abelian and non-Abelian symmetries. Embedded in C++ and interfaced with Matlab, QSpace facilitates quantum symmetry spaces in tensor network states. Its capabilities allow users to exploit a variety of symmetries, including the U(1) and special unitary groups, making it versatile for different operations across symmetries. QSpace's design emphasizes a bottom-up approach, starting from the defining representation and utilizing Clebsch-Gordan coefficient tensors. This approach makes QSpace a powerful tool for developing tensor network algorithms, providing a user-friendly environment while handling complex symmetry details.</p> Open Source QSpace <p>The Open Source QSpace project includes a standard and a community edition. The community edition (OSQSpace) is a tailored version of the standard QSpace (QSpace4u) tensor library which is part of our commitment to fostering an open, collaborative environment for scientific exploration and software development. The community edition is distinctively designed to cater to a vibrant community of developers, researchers, and academicians who are deeply invested in the advancement of tensor network algorithms for quantum lattice models.</p>"},{"location":"changelog/","title":"Changlog","text":""},{"location":"changelog/#401-2024-10-12","title":"4.0.1 (2024-10-12)","text":"<ul> <li>Added: Create Metadata information after compilation.</li> <li>Added: Welcome information for deployed applications.</li> <li>Added: <code>configure</code> script and <code>osqs</code> entrance application.</li> <li>Added: <code>osqs</code> command line tool in MATLAB interative interface.</li> </ul>"},{"location":"changelog/#400-2024-10-07","title":"4.0.0 (2024-10-07)","text":"<ul> <li>Added: One-line compilation script for macOS and Linux.</li> <li>Added: Environment presets for macOS and ASC HPC clusters.</li> <li>Fixed: Optimize hostname warning message.</li> <li>Updated: Improved <code>RC_STORE</code> strategy in startup.m.</li> </ul>"},{"location":"community/","title":"Why Community Edition?","text":"<p>Welcome to the Open Source QSpace - Community Edition, a tailored version of the standard QSpace tensor library which is part of our commitment to fostering an open, collaborative environment for scientific exploration and software development. The community edition is distinctively designed to cater to a vibrant community of developers, researchers, and academicians who are deeply invested in the advancement of tensor network algorithms for quantum lattice models.</p>"},{"location":"community/#advantages-of-the-community-edition","title":"Advantages of the Community Edition","text":"<p>The community edition of QSpace stands out by emphasizing user collaboration and enhanced performance. Unlike the standard version of QSpace, which is open to the public for general usage under the Apache 2.0 license, the community edition is an exclusive offering that benefits from direct contributions from its users. This edition is ideally suited for those who are keen on diving deeper into both Abelian and non-Abelian symmetries, with a focus on participatory development and sharing of innovative ideas.</p> <p>Our community-driven approach allows users to:</p> <ul> <li> <p>Collaborate directly with peers and lead contributors such as Changkai Zhang and Dai-Wei Qu, who are both deeply involved in the ongoing development and maintenance of the library.</p> </li> <li> <p>Access cutting-edge features and optimizations before they become available in the standard release.</p> </li> <li> <p>Contribute to the library's roadmap by proposing new features, improving existing functionalities, and enhancing the library\u2019s documentation.</p> </li> </ul>"},{"location":"community/#exclusive-community-access","title":"Exclusive Community Access","text":"<p>Following the request of the original author, Dr. Andreas Weichselbaum, access to the QSpace community edition is exclusively available to members of the Open Source QSpace organization on GitHub. This ensures that contributions and enhancements are aligned with the high standards set for QSpace and that all modifications and expansions are thoroughly vetted by a community dedicated to excellence in quantum many-body research.</p>"},{"location":"community/#joining-the-open-source-qspace-organization","title":"Joining the Open Source QSpace Organization","text":"<p>Joining the Open Source QSpace organization is straightforward:</p> <ol> <li>Request an Invitation: Interested parties are encouraged to request an invitation by contacting our current administrator Changkai Zhang.</li> <li>Contribute: Membership is granted primarily to those who are actively contributing to the project or who have a demonstrated interest in advancing tensor network algorithms and quantum symmetry spaces.</li> </ol> <p>We welcome and value the unique perspectives and expertise each new member brings to QSpace. Together, we can propel the library to new heights, continuously adapting and refining it to meet the evolving challenges of quantum many-body physics and tensor network research. Join us in shaping the future of quantum many-body physics, one tensor at a time!</p>"},{"location":"contribg/","title":"How to Contribute","text":""},{"location":"contribg/#introduction","title":"Introduction","text":"<p>When contributing to our this documentation, it's crucial to adhere to a structured Git branching strategy. This ensures that the codebase remains stable and manageable, allowing for efficient development and release processes.</p>"},{"location":"contribg/#branching-strategy","title":"Branching Strategy","text":"<p>We use three types of branches in our workflow:</p> <ol> <li>Main Branch: Reserved for production releases.</li> <li>Develop Branch: Used for integrating new contents and fixes.</li> <li>Contributor-Specific Branch (e.g., <code>&lt;name&gt;</code>): For individual contributors to create new contents or fixes.</li> </ol>"},{"location":"contribg/#why-this-strategy","title":"Why This Strategy?","text":"<ul> <li>Stability: By restricting direct pushes to the <code>main</code> branch, we ensure that only thoroughly reviewed contents get deployed.</li> <li>Continuous Integration: The <code>develop</code> branch serves as an integration point, allowing for regular testing and early detection of conflicts.</li> <li>Ownership and Isolation: Contributor-specific branches allow contributors to work independently on their tasks without interfering with others' work.</li> </ul>"},{"location":"contribg/#workflow-steps-and-git-commands","title":"Workflow Steps and Git Commands","text":""},{"location":"contribg/#1-setup-your-workspace","title":"1. Setup Your Workspace","text":"<p>Before you start, ensure you have the latest version of the <code>develop</code> branch.</p> <pre><code>git checkout develop\ngit pull origin develop\n</code></pre>"},{"location":"contribg/#2-create-your-contributor-specific-branch","title":"2. Create Your Contributor-Specific Branch","text":"<p>Create a new branch for your work. Replace <code>&lt;name&gt;</code> with your branch name.</p> <pre><code>git checkout -b &lt;name&gt;\n</code></pre>"},{"location":"contribg/#3-implement-your-changes","title":"3. Implement Your Changes","text":"<p>Make your changes, commit them to your branch. Replace <code>&lt;commit-message&gt;</code> with a meaningful description of your changes.</p> <pre><code># Add files to the staging area\ngit add .\n\n# Commit changes\ngit commit -m \"&lt;commit-message&gt;\"\n</code></pre>"},{"location":"contribg/#4-keep-your-branch-updated","title":"4. Keep Your Branch Updated","text":"<p>Regularly update your branch with changes from the <code>develop</code> branch to avoid conflicts later.</p> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout &lt;name&gt;\ngit merge develop\n</code></pre> <p>Resolve any conflicts that arise from the merge.</p>"},{"location":"contribg/#5-finalizing-your-contribution","title":"5. Finalizing Your Contribution","text":"<p>Once your contents or fixes are complete:</p> <ul> <li>Pull the latest <code>develop</code> branch.</li> <li>Merge it into your branch.</li> <li>Solve any conflicts.</li> </ul> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout &lt;name&gt;\ngit merge develop\n</code></pre>"},{"location":"contribg/#6-merge-back-to-develop","title":"6. Merge Back to Develop","text":"<p>After resolving conflicts and ensuring the local website works as expected, merge your branch back to <code>develop</code>.</p> <pre><code>git checkout develop\ngit merge &lt;name&gt;\n</code></pre>"},{"location":"contribg/#7-push-to-develop","title":"7. Push to Develop","text":"<p>Push your changes to the remote <code>develop</code> branch. Your code will be reviewed before merging.</p> <pre><code>git push origin develop\n</code></pre>"},{"location":"contribg/#8-code-review-and-testing","title":"8. Code Review and Testing","text":"<p>Once pushed, your code will undergo review and testing by peers and CI tools.</p> <p>Note</p> <p>The <code>main</code> branch is off-limits for direct contributions. It is exclusively managed by the administrator for stable releases.</p> <p>This workflow, while structured, ensures that our codebase remains clean, stable, and manageable. By following these guidelines, you contribute not only code but also to the overall health and quality of the project.</p>"},{"location":"mdref/","title":"Markdown Syntax Guide","text":"<p>Welcome to the world of Markdown! Markdown is a simple way to format text that can be easily converted to HTML. It's widely used in writing for the web, documentation, and much more. This guide will help you understand the basics of Markdown formatting.</p>"},{"location":"mdref/#headings","title":"HeadingsHeading","text":"<p>Headings are used to structure your document. Markdown supports six levels of headings, which are created with <code>#</code> symbols:</p> MarkdownRendered Result <pre><code># h1 Heading\n## h2 Heading\n### h3 Heading\n#### h4 Heading\n</code></pre> <p>Heading Heading Heading</p> <p>Just add the number of <code>#</code> symbols corresponding to the level of heading you want.</p>"},{"location":"mdref/#horizontal-rules","title":"Horizontal Rules","text":"<p>To create a thematic break or a horizontal rule, use three or more dashes, e.g. <code>---</code> renders as:</p> <p>This is typically used to signify a major topic change in your document.</p>"},{"location":"mdref/#emphasis","title":"Emphasis","text":"<p>To emphasize text, you can use bold or italic formatting:</p> <p>Bold: Wrap your text with two asterisks or underscores.</p> MarkdownRendered Result <pre><code>**This is bold text**\n__This is also bold__\n</code></pre> <p>This is bold text This is also bold</p> <p>Italic: Wrap your text with one asterisk or underscore.</p> MarkdownRendered Result <pre><code>*This is italic text*\n_This is also italic_\n</code></pre> <p>This is italic text This is also italic</p>"},{"location":"mdref/#blockquotes","title":"Blockquotes","text":"<p>Blockquotes are used for quoting text from another source. Use the <code>&gt;</code> symbol:</p> MarkdownRendered Result <pre><code>&gt; Blockquotes can also be nested...\n&gt;&gt; ...by using additional greater-than signs right next to each other...\n&gt; &gt; &gt; ...or with spaces between arrows.\n</code></pre> <p>Blockquotes can also be nested...</p> <p>...by using additional greater-than signs right next to each other...</p> <p>...or with spaces between arrows.</p>"},{"location":"mdref/#lists","title":"Lists","text":"<p>Lists are a great way to organize information.</p> <p>Unordered Lists: Start a line with <code>+</code>, <code>-</code>, or <code>*</code>:</p> MarkdownRendered Result <pre><code>+ Item 1\n+ Item 2\n- Subitem 2.1\n- Subitem 2.2\n</code></pre> <ul> <li>Item 1</li> <li>Item 2</li> <li>Subitem 2.1</li> <li>Subitem 2.2</li> </ul> <p>Ordered Lists: Use numbers followed by a period:</p> MarkdownRendered Result <pre><code>1. First item\n2. Second item\n3. Third item\n</code></pre> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol> <p>You can also use the same number to let Markdown handle the numbering:</p> MarkdownRendered Result <pre><code>1. Item\n1. Item\n1. Item\n</code></pre> <ol> <li>Item</li> <li>Item</li> <li>Item</li> </ol>"},{"location":"mdref/#code","title":"Code","text":"<p>There are several ways to represent code in Markdown.</p> <ul> <li>Inline Code: For small bits of code, use backticks:</li> </ul> <p>This is an inline <code>code</code> example.</p> <ul> <li>Indented Code: Indent your code by four spaces or a tab for block code:</li> </ul> <pre><code>    This is a block of code.\n</code></pre> <ul> <li>Fenced Code Blocks: Use triple backticks and optionally specify the language for syntax highlighting:</li> </ul> <pre><code>import tensorflow as tf\n</code></pre>"},{"location":"mdref/#equations","title":"Equations","text":"<p>MathJax allows you to display mathematical notation in Markdown documents. With MathJax, you can write complex mathematical expressions using LaTeX syntax. To use MathJax in your document, you have two main options: inline math and display math.</p> <ul> <li>Inline Math: For inline mathematical expressions, enclose your LaTeX code within single dollar signs <code>$</code>. This method is used when you want to include math expressions within a line of text.</li> </ul> MarkdownRendered Result <pre><code>$E = mc^2$\n</code></pre> <p>\\(E = mc^2\\)</p> <ul> <li>Display Math: For larger expressions or equations that you want to display on their own line, use double dollar signs <code>$$</code> to enclose your LaTeX code. This centers the math expression and puts it on a new line.</li> </ul> MarkdownRendered Result <pre><code>$$\n\\begin{align*}\na^2 + b^2 &amp;= c^2 \\\\\ne^{i\\pi} + 1 &amp;= 0\n\\end{align*}\n$$\n</code></pre> \\[ \\begin{align*} a^2 + b^2 &amp;= c^2 \\\\ e^{i\\pi} + 1 &amp;= 0 \\end{align*} \\] <p>Remember, for complex LaTeX expressions, ensure that your syntax is correct as MathJax will render exactly what is written within the delimiters.</p>"},{"location":"mdref/#tables","title":"Tables","text":"<p>Create tables using dashes <code>-</code> for headers and pipes <code>|</code> for columns:</p> MarkdownRendered Result <pre><code>| Header 1 | Header 2 |\n| -------- | -------- |\n| Row 1    | Data     |\n| Row 2    | Data     |\n</code></pre> Header 1 Header 2 Row 1 Data Row 2 Data <p>To align columns, use colons <code>:</code> in the header row:</p> MarkdownRendered Result <pre><code>| Left Aligned | Right Aligned | Center Aligned |\n| :----------- | ------------: | :------------: |\n| left         |         right |     center     |\n</code></pre> Left Aligned Right Aligned Center Aligned left right center"},{"location":"mdref/#links-and-images","title":"Links and Images","text":"<ul> <li>Links: To create a link, wrap the link text in brackets <code>[ ]</code>, followed by the URL in parentheses <code>( )</code>:</li> </ul> MarkdownRendered Result <pre><code>This is a link to the [Google Website](https://www.google.com)\n</code></pre> <p>This is a link to the Google Website</p> <p>For a link with a title, add the title in quotes after the URL:</p> MarkdownRendered Result <pre><code>This is a link to the [Google Website](https://www.google.com \"Google Homepage\")\n</code></pre> <p>This is a link to the Google Website</p> <ul> <li>Images: Similar to links, but start with an exclamation mark <code>!</code>:</li> </ul> MarkdownRendered Result <pre><code>&lt;figure markdown&gt;\n  ![Alt text](../assets/QSpace.png){ width=\"300\" }\n&lt;/figure&gt;\n</code></pre> <p> </p>"},{"location":"mdref/#extended-syntax-and-functionalities","title":"Extended Syntax and Functionalities","text":"<p>In our documentation, we leverage Markdown extensions to enrich the standard Markdown syntax. These extensions are invaluable for adding advanced formatting and interactive elements that are not possible with basic Markdown. They are particularly useful in creating comprehensive and user-friendly documentation, allowing for more engaging and organized content.</p> <p>For example, extensions enable the inclusion of tabbed content, detailed footnotes, custom admonition blocks, and enhanced code blocks with syntax highlighting. To explore the full range of possibilities these extensions offer, and for detailed syntax reference, please visit MkDocs Material Extensions Reference.</p>"},{"location":"mkdocsg/","title":"Comprehensive MkDocs Guide","text":""},{"location":"mkdocsg/#introduction-to-mkdocs","title":"Introduction to MkDocs","text":""},{"location":"mkdocsg/#what-is-mkdocs","title":"What is MkDocs?","text":"<p>MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file.</p>"},{"location":"mkdocsg/#key-features","title":"Key Features","text":"<ul> <li>Ease of Use: MkDocs is straightforward to set up. All you need is your documentation in Markdown format. No database is required.</li> <li>Theme Support: MkDocs comes with a built-in theme. Additional themes can be installed via <code>pip</code>. This site is built with the Material for MkDocs theme.</li> <li>Host Anywhere: MkDocs builds completely static HTML sites that you can host on GitHub pages, Amazon S3, or anywhere else you choose.</li> <li>Markdown Centric: Focus on your project's documentation and not on the tooling to make your documentation work. Additional features can be incorporated via extensions.</li> </ul>"},{"location":"mkdocsg/#mkdocs-directory-structure","title":"MkDocs Directory Structure","text":"<p>When you create a new project, MkDocs will automatically create the a directory structure and files. If you pull this repository, the directory structure is already set up, which looks like this:</p> Directory Structure<pre><code>project_name/\n\u2502\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md    # The main documentation page.\n\u2502   \u2514\u2500\u2500 ...         # Other markdown pages for your documentation.\n\u2502\n\u2514\u2500\u2500 mkdocs.yml      # The MkDocs configuration file.\n</code></pre> <ul> <li><code>docs/</code>: This directory contains all your documentation in Markdown format.</li> <li><code>mkdocs.yml</code>: This is the configuration file for your MkDocs site.</li> </ul> <p>Note</p> <p>It is possible to have subdirectories within the <code>docs/</code> directory. This is useful for organizing the documentation into sections. However, please inform the administrator if you plan to do this.</p>"},{"location":"mkdocsg/#mkdocs-yaml-configuration","title":"MkDocs YAML Configuration","text":"<p>The <code>mkdocs.yml</code> file is where you configure your documentation site. YAML, which stands for \"YAML Ain't Markup Language,\" is a human-readable data serialization format. YAML files typically end with the .yml or .yaml extension and use indentation to represent data hierarchies, making it visually clear and straightforward. This format is often preferred for writing configuration files, like those used in MkDocs.</p>"},{"location":"mkdocsg/#basic-configuration","title":"Basic Configuration:","text":"<ul> <li>site_name: Title of your documentation site.</li> <li>nav: Structure of your site's navigation.</li> </ul>"},{"location":"mkdocsg/#example-mkdocsyml","title":"Example <code>mkdocs.yml</code>:","text":"mkdocs.yml<pre><code>site_name: QSpace Documentation\nnav:\n    - Home: index.md\n    - About: about.md\n    - User Guide:\n        - Writing Docs: user-guide/writing.md\n        - Styling Docs: user-guide/styling.md\n</code></pre> <p>Warning</p> <p>You will see many more configuration options in the <code>mkdocs.yml</code> file in this repository. Please do not touch any of the settings other than the ones mentioned above. If you have any questions, please contact the administrator.</p>"},{"location":"mkdocsg/#installing-building-and-using-mkdocs","title":"Installing, Building, and Using MkDocs","text":"<p>Before you start building the project, you will need to create a Python virtual environment. A Python environment is a self-contained directory that holds a specific version of Python and a collection of Python packages. Think of it as an isolated workspace for Python projects, ensuring that each project has its own dependencies and settings, separate from other projects. This isolation prevents conflicts between project requirements and allows for more organized and manageable development. The most common tool for creating Python environments is venv, which is included in the Python Standard Library.</p>"},{"location":"mkdocsg/#create-a-python-virtual-environment","title":"Create a Python Virtual Environment:","text":"<pre><code>python -m venv venv\n</code></pre> <ul> <li><code>python -m venv</code>: This command tells Python to create a new virtual environment.</li> <li><code>venv</code>: This is the name of the virtual environment folder. You can name it anything, but <code>venv</code> is a common convention. The administrator highly recommends using this name for convenience in version control. If you strongly prefers another name, please ensure that this directory is excluded in your <code>.gitignore</code> file, and you should not commit your <code>.gitignore</code> file to the repository.</li> </ul> <p>Note</p> <p>This project has been tested for Python 3.10.11. The command to use may differ depending on the version and platform you are working with. In general, Python 3.10 and above should work without any issues.</p>"},{"location":"mkdocsg/#activatedeactivate-the-virtual-environment","title":"Activate/Deactivate the Virtual Environment:","text":"<p>The Python virtual environment can be activated using the following commands:</p> Linux/MacOSWindows <pre><code>source venv/bin/activate\n</code></pre> <ul> <li><code>source</code>: This command changes the current shell\u2019s environment to the one provided.</li> <li><code>venv/bin/activate</code>: This is the path to the activation script of the virtual environment. Running this script activates the virtual environment.</li> </ul> <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <ul> <li><code>.\\venv\\Scripts\\activate</code>: This command activates the virtual environment on Windows. The path differs slightly from Linux/MacOS.</li> </ul> <p>The Python virtual environment can be deactivated using the following command (same for both Linux/MacOS and Windows):</p> <pre><code>deactivate\n</code></pre> <p>Warning</p> <p>You must activate the virtual environment every time you start working with this project. Otherwise, you will be using the system Python environment, which may cause conflicts with the packages you install. Also, please remember to deactivate the virtual environment when you are done working with this project.</p>"},{"location":"mkdocsg/#install-mkdocs-and-dependencies","title":"Install MkDocs and Dependencies:","text":"<p>The required packages and relevant dependencies (together with the required version) are listed in the <code>requirements.txt</code> file. To install these packages, run the following command:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <ul> <li><code>pip install -r</code>: This command is used to install packages listed in <code>requirements.txt</code> from the Python Package Index (PyPI).</li> <li><code>requirements.txt</code>: This file includes all the packages and dependencies for the project. Please do not modify this file before consulting the administrator.</li> </ul>"},{"location":"mkdocsg/#start-the-mkdocs-server","title":"Start the MkDocs Server:","text":"<p>MkDocs allows you to preview your documentation as you work on it, by running the website locally on your computer. Every time you make changes to your documentation, you can see the changes in real time in your browser. To start the MkDocs server, run the following command:</p> <pre><code>mkdocs serve\n</code></pre> <ul> <li> <p><code>mkdocs serve</code>: This command starts a local server for your MkDocs site. It allows you to see your changes in real time as you work on your documentation.</p> </li> <li> <p>After running this command, MkDocs will start a web server accessible at <code>http://localhost:8000</code>. You can open this address in your web browser to see your documentation.</p> </li> </ul>"},{"location":"mkdocsg/#building-your-site","title":"Building Your Site:","text":"<pre><code>mkdocs build\n</code></pre> <ul> <li> <p><code>mkdocs build</code>: This command generates the static HTML files for your documentation. After running this command, you'll find these files in a folder named <code>site</code> within your project directory.</p> </li> <li> <p>The generated <code>site</code> directory can be hosted on any web server, GitHub Pages, or other hosting services for static sites.</p> </li> </ul> <p>By following these steps, you should be able to set up and use MkDocs in your local computers. If you have any questions, please contact the administrator Changkai Zhang at changkai.zhang@physik.lmu.de.</p>"},{"location":"examples/iterdiag/","title":"Iterdiag","text":"<p>[TODO]</p>"},{"location":"examples/DMRG/DMRGHubbard2D/","title":"2D Hubbard Model","text":"<p>Complete source code can be downloaded from DMRG.</p> <pre><code>clear;\n\n%%% begin input parameters %%%\n\nt = 1; % nn-hopping amplitude\nt_ = -0.2; % nnn-hopping amplitude\nU = 8; % onsite repulsion\n\nwidth = 5; % width of cylinder\nheight = 4; % height of cylinder\nfPBC = true; % periodic boundary conditions along y\n\nsym = 'SU2'; % U(1)_{charge} x SU(2)_{spin}\n%sym = 'U1'; % U(1)_{charge} x U(1)_{spin}\n\nD = 2000; % MPS bond dimension\nw = ham.get_num_mpo_states( sym, height, fPBC, t_ );\nD_prime = floor(D/w);\nD_hat = D;\nD_tilde = floor(D/10);\n\nnum_sweeps = 1000; % number of sweeps\nnum_davidson = 3; % number of davidson steps\neps_davidson = 1e-10; % threshold for termination of davidson\nnum_zero = 1e-10; % numerical zero\n\n% pick type of optimization\n%opt_enum = 1; % twosite\nopt_enum = 2; % shrewd cbe \n\n%%% end input paramters %%%\n\nN = width*height;\nif strcmp(sym,'U1')\n    [F,Z,S,I] = getLocalSpace('FermionS','Acharge,Aspin');\nelse\n    [F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin');\nend\nlocal_space = {F,Z,S,I};\n\n% initialize tensor network\nnetwork = Network;\nnetwork.mps = ham.get_prod_state(N,sym);\nnetwork.mpo = ham.get_mpo( t, t_, U, sym, width, height, fPBC );\nnetwork.model_iden = I.E;\nnetwork.D = D;\nnetwork.D_prime = D_prime;\nnetwork.D_hat = D_hat;\nnetwork.D_tilde = D_tilde;\nnetwork.num_davidson = num_davidson;\nnetwork.eps_davidson = eps_davidson;\nnetwork.num_zero = num_zero;\nnetwork.num_zero = num_zero;\nnetwork.opt_enum = opt_enum;\nnetwork.timetracker = TimeTracker;\n\nfprintf(\"DMRG ground state calculation for the Hubbard model on a cylinder\\n\\n\");\n\nif strcmp(sym,'U1')\n    fprintf(\"Acharge,Aspin\\n\");\nelse\n    fprintf(\"Acharge,SU2spin\\n\");\nend\nif fPBC==1\n    fprintf(\"periodic boundary conditions in y\\n\");\nelse\n    fprintf(\"open boundary conditions in y\\n\");\nend\nfprintf(\"t: %.16f\\n\",t);\nfprintf(\"t_: %.16f\\n\",t_);\nfprintf(\"U: %.16f\\n\",U);\nfprintf(\"width: %i\\n\",width);\nfprintf(\"height: %i\\n\",height);\n\nfprintf(\"D: %i\\n\",D);\nfprintf(\"D_prime: %i\\n\",D_prime);\nfprintf(\"D_hat: %i\\n\",D_hat);\nfprintf(\"D_tilde: %i\\n\",D_tilde);\nfprintf(\"num_sweeps: %i\\n\",num_sweeps);\nfprintf(\"num_davidson: %.16f\\n\",num_davidson);\nfprintf(\"eps_davidson: %.16f\\n\",eps_davidson);\nfprintf(\"num_zero: %i\\n\",num_zero);\n\nif opt_enum==1\n    fprintf(\"twosite opt\\n\");\nend\nif opt_enum==2\n    fprintf(\"shrewd cbe opt\\n\");\nend\nfprintf(\"\\n\\n\");\n\n% contract from right to left in the beginning\nfor i=(N:-1:3)\n    network.env_contract(i,i+1);\nend\n\nif opt_enum==1\n    % sweep and optimize twosite\n    for i=(1:num_sweeps)\n        network.twosite_sweep(i);\n        network.print_time();\n        pid = sprintf('%i',feature('getpid'));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmRSS']);\n        fprintf(\"RSS: %i MB\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmHWM']);\n        fprintf(\"Peak RSS: %i MB\\n\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n    end\nelse\n    % sweep and optimize cbe-onesite\n    for i=(1:num_sweeps)\n        network.cbe_sweep(i);\n        network.print_time();\n        pid = sprintf('%i',feature('getpid'));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmRSS']);\n        fprintf(\"RSS: %i MB\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n        [tmp mem_usage] = system(['cat /proc/' pid '/status | grep VmHWM']);\n        fprintf(\"Peak RSS: %i MB\\n\\n\", round(str2num(strtrim(extractAfter(extractBefore(mem_usage, ' kB'), ':'))) / 1000));\n    end\nend\n</code></pre>"},{"location":"examples/NRG/Ex_1CK/","title":"Ex 1CK","text":"<pre><code>% NRG calculation of spin-1/2 1-channel Kondo\n\nclear\n\nnum_threads_SL(10); % to use multiple cores\n\n% Hamiltonian parameter\nNC = 1;\nJ = 0.2;\nT = 1e-8;\n\n% NRG parameter\nLambda = 2;\nN = ceil(-2*log(T/10)/log(Lambda))+5;\nnz = 2;\nNkeep = 500;\n\n% % % % U(1) charge * SU(2) spin\n% Define operators\n[FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge,SU2spin','NC',NC);\n[Fs,Zs,Ss,Is] = setItag('s00','op',FF,ZF,SF,IF.E);\n[ZL,SL,IL] = setItag('L00','op',ZF,SF,IF.E);\n\n% project onto half-filled, spin-1/2 subspace\nIL = getsub(IL,find(IL.Q{1}(:,1) == 0));\nZ_L00 = getsub(ZL,find(ZL.Q{1}(:,1) == 0));\nA0 = getIdentity(IL,2,Is,2,'K00*',[1 3 2]);\n\nHSS = (2*J)*contract(SL,'!2*',Ss,[2 1 3 4]); % S*S interaction\nOp = [(contract(Fs,'!1',HSS,[3 4 1 5 2]) - contract(HSS,'!13',Fs)); SL];\ncflag = [1;-1]; % brackets in the correlation functions are fermionic (+1) or bosonic (-1)\nzflag = [1;0]; % operators are fermionic (1) or not (0)\n\nH0 = contract(A0,'!2*',{HSS,'!13',A0}) + 1e-40*getIdentity(A0,2); % impurity Hamiltonian\n\nff = doZLD([-1 1],[1 1],Lambda,N,nz,'Nfit',round(-2*log(1e-8)/log(Lambda)));\n\nAdisc = cell(1,1,nz,numel(Op));\nAcont = cell(1,numel(Op));\nAw0 = zeros(1,numel(Op),nz); % static susceptibilities\n\nfor itz = (1:nz)\n    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz}(2:end),FF,ZF,'Nkeep',Nkeep);\n    if itz == nz\n        [Es,Qs] = plotE(nrgdata);\n    end\n\n    nrgdata = getRhoFDM(nrgdata,T,'-v');\n    [odisc,Adiscz,sigmak,Aw0(1,:,itz)] = getAdisc(nrgdata,Op(:),Op(:),ZF,'Z_L00',Z_L00,'cflag',cflag,'zflag',zflag);\n    if numel(Op) &gt; 1\n        Adisc(:,:,itz,:) = Adiscz;\n    else\n        Adisc(:,:,itz,:) = {Adiscz};\n    end\nend\n\nfor ito = (1:numel(Op))\n    [ocont,Acont{1,ito}] = getAcont(odisc,mean(cell2mat(Adisc(:,:,:,ito)),3),sigmak,T/5,'alphaz',1/nz);\nend\n\n\nfigure;\nplot(ocont(ocont&gt;0),Acont{1}(ocont&gt;0)*(pi^2/2/2)); % /2 due to the sum over spin\nset(gca,'XScale','log');\ngrid on;\nxlabel('\\omega');\nylabel('T(\\omega)');\ntitle('Spin-1/2 + 1-channel: U(1) charge * SU(2) spin');\n\nfigure;\nplot(ocont(ocont&gt;0),Acont{2}(ocont&gt;0));\nset(gca,'XScale','log','YScale','log');\ngrid on;\nxlabel('\\omega');\nylabel('(-1/\\pi) Im \\chi (\\omega)');\n</code></pre>"},{"location":"examples/NRG/Ex_NonDiag/","title":"Ex NonDiag","text":"<pre><code>% Example: NRG calculation of an impurity model of spinless fermions in two\n% channels. Partcles can hop between the channels, leading to the\n% off-diagonal elements of the quadratic term at the impurity and of the\n% hybridization function.\n\nclear\n\nnum_threads_SL(10);\n\n% % Hamiltonian parameter\n% U = 0;\nU = 1;\n% epsd = eye(2)*(-U/2); % epsd is now matrix; it can have finite non-diagonal elements\nepsd = [-0.2,0.05*1i;-0.05*1i,-0.1]; % like this; it can also have complex elements\nGamma = 0.1;\nT = 1e-6;\n\n% NRG parameter\nLambda = 2;\nN = max(ceil(-2*log(T)/log(Lambda))+7,20);\nnz = 2;\nNkeep = 1000;\nETRUNC = inf(1,10);\nEtrunc = 9;\n% nrgdata = go('data/NRG/NRG');\n\n% % interleaved NRG (iNRG):\n% 'inrg' can be given as a row vector or a matrix; see the description of\n% an optional input 'inrg' to the 'doZLD' routine.\ninrg = [1,2];\n% inrg = [1,2;2,1]; % each row: a permutation of the iNRG sub-channels; to be averaged over different permutations\n% % ... or standard NRG (sNRG):\n% inrg = [];\n% % % % \n\n% frequency grid parametrizing the hybiridzation function. The function is\n% considered to vanish outside of the range [min(ozin), max(ozin)]. \nozin = [-1 1];\n\n% % matrix-valued hybridization functions evaluated on the 'ozin' grid\n% RhoV2in = (Gamma/pi)*repmat(reshape([1,0;0,1],[1 2 2]),[2 1 1]); % diagonal terms only\n% RhoV2in = (Gamma/pi)*permute(cat(3,[1,-1;-1,1],[1,1;1,1]),[3 1 2]); % with non-diagonal terms\nRhoV2in = (Gamma/pi)*permute(cat(3,[1,-1i;1i,1],[1,1;1,1]),[3 1 2]); % with complex non-diagonal terms\n\n% logarithmic discretization\nif ~isempty(inrg) % iNRG mode\n    [ff,gg,dff,dgg] = doZLD(ozin,RhoV2in,Lambda,N,nz,'inrg',inrg,'-zbound');\nelse % sNRG mode\n    [ff,gg,dff,dgg] = doZLD(ozin,RhoV2in,Lambda,N,nz);\nend\n\n% define operators for the impurity and (for sNRG) the chain sites. There\n% is only the total charge conservation (U(1) symmetry). For convenience,\n% we invoke the 'getLocalSpace' for spinful fermions without U(1) spin\n% symmetry, which is equivalent to the current problem up to relabelling\n% channel to spin.\n[FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge','NC',1);\n[FF,ZF,SF,EF] = setItag('s00','op',FF(:),ZF,SF(:),IF.E); % make FF as a column, for proper concatenation in defining the operator inputs to getAdisc\nNF = quadOp(FF,FF,[]); % particle number operator\n\n % operators for acting only on the Hilbert space involving single flavors;\n % to be used as the operators for the bath in the iNRG mode\n[Fp,Zp] = singleFZ(FF,ZF);\n\n% local quadratic term\nHepsd = QSpace;\nfor it1 = (1:numel(FF))\n    for it2 = (1:numel(FF))\n        Hepsd = Hepsd + epsd(it1,it2)*contract(FF(it1),'!2*',FF(it2));\n    end\nend\n\n% interaction term\nHU = (U/2)*sum(NF)*(sum(NF)-EF);\n\nA0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\nH0 = contract(A0,'!2*',{HU+Hepsd,'!1',A0}) + 1e-40*getIdentity(A0,2); % in the K00 basis\nFHU = QSpace(size(FF));\nfor ito = (1:numel(FF))\n    FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito)); % [FF,HU]\nend\n\n% indices for the first operator arguments of correlators\nOid1 = (1:numel(FF)).'+zeros(1,numel(FF));\nOid1 = Oid1(:);\n\n% indices for the second operator arguments of correlators\nOid2 = zeros(numel(FF),1)+(1:numel(FF));\nOid2 = Oid2(:);\n\nAdiscs = cell(numel(Oid1)*3,numel(ff)); % *3 is for three different correlators to compute the self-energy\nAdisc2sum = zeros(numel(FF),numel(FF),numel(ff)); % Hartree term in the self-energy, needed for Kugler's trick\nAconts = cell(numel(Oid1),3);\n\nfor itz = (1:numel(ff)) % for different z shifts and different iNRG permutations\n    % NOTE: Operator for the on-site energy term given to NRG_SL (say FL)\n    % is empty [], since the on-site terms will be generated from the\n    % annihilation operators FF or Fp when the Wilson chain parameters have\n    % non-diagonal terms.\n\n    if ~isempty(inrg) % iNRG mode\n        % iNRG sub-channel configuration for the current permutation\n        inrg_tmp = inrg(mod(itz-1,size(inrg,1))+1,:);\n\n        % NOTE: Input array of Z operators for NRG_SL should have one-to-one\n        % correspondence to the iNRG sub-channels (NOT to particle flavors). That\n        % is, Z(n) corresponds to the n-th sub-channel that contains ALL the\n        % particle flavors j such that inrg_tmp(j) == n. If a sub-channel contains\n        % more than one flavor, one may use 'chainSpace' routine to generate the Z\n        % operator for the sub-channel.\n        Zp2 = QSpace(1,max(inrg_tmp));\n        for ito = (1:max(inrg_tmp))\n            oktmp = (inrg_tmp == ito);\n            if sum(oktmp) == 1\n                Zp2(ito) = Zp(inrg_tmp == ito);\n            elseif sum(oktmp) &gt; 1\n                [~,Zp2(ito)] = chainSpace(Fp(oktmp),(1:sum(oktmp)),Zp(oktmp));\n            else\n                error(['ERR: no Z operator for iNRG sub-channel #',sprintf('%i',ito)]);\n            end\n        end\n\n        % % writing raw data onto a disk\n%         NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},Fp,Zp2,gg{itz},[], ...\n%             'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz}, ...\n%             'F0',FF,'iflag',inrg_tmp);\n\n        % % ... or memory-only mode\n        nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},Fp,Zp2,gg{itz},[], ...\n            'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz}, ...\n            'F0',FF,'iflag',inrg_tmp);\n\n\n        % NOTE: 'F0' for the particle operators at the impurity, 'iflag'\n        % denotes the permutation for the iNRG sub-channels.\n    else % sNRG mode\n%         nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},[], ...\n%             'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz});\n        NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},[], ...\n            'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'dff',dff{itz},'dgg',dgg{itz});\n    end\n\n    % % writing raw data onto a disk\n%     getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n\n    % % ... or memory-only mode\n    nrgdata = getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n\n    [odisc,Adiscs(:,itz),sigmak] = getAdisc(nrgdata, ...\n        [FF(Oid1);FHU(Oid1);FHU(Oid1)], ...\n        [FF(Oid2);FF(Oid2) ;FHU(Oid2)], ...\n        ZF);\n\n    Adisc2sum(:,:,itz) = reshape(cellfun(@(x) sum(x(:)), Adiscs(numel(Oid1)+(1:numel(Oid1)),itz)), numel(FF)*[1 1]);\nend\n\nfor ita = (1:size(Adiscs,1))\n    [ocont,Aconts{ita}] = getAcont(odisc,mean(cell2mat(reshape(Adiscs(ita,:),[1 1 size(Adiscs,2)])),3),sigmak,T/5,'alphaz',1/nz,'-v');\nend\n\nAconts = cell2mat(reshape(Aconts,[1 numel(FF)*[1 1] 3]));\nAdisc2sum = mean(Adisc2sum,3);\n\n% % R. Bulla's \"self-energy trick\"\n[SE1,Aimp1] = SEtrick(ocont,Aconts(:,:,:,1),Aconts(:,:,:,2),'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd);\n\n% % F. B. Kugler's symmetric estimator\n[SE2,Aimp2] = SEtrick(ocont,Aconts(:,:,:,1),Aconts(:,:,:,2),Adisc2sum,Aconts(:,:,:,3),'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd);\n\n\n%% draw figure\n\n% % color set (5 default + 2 new)\nclrs = {[0 .447 .741],[.85 .325 .098],[.773 .565 .061], ...\n        [.494 .184 .556],[.466 .674 .188],[.301 .745 .933], ...\n        [.635 .078 .184]};\n\nlegs = cell(0,1);\nfigure;\nhold on;\ncnt = 1;\nfor it1 = (1:numel(FF))\n    for it2 = (1:numel(FF))\n        plot(ocont,real(Aconts(:,it1,it2,1))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','--');\n        legs{end+1} = ['bare (',sprintf('%i,%i',[it1 it2]),'), real'];\n\n        plot(ocont,real(Aimp1(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-.');\n        legs{end+1} = ['Bulla (',sprintf('%i,%i',[it1 it2]),'), real'];\n\n        plot(ocont,real(Aimp2(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-');\n        legs{end+1} = ['Kugler (',sprintf('%i,%i',[it1 it2]),'), real'];\n\n        cnt = cnt+1;\n\n        plot(ocont,imag(Aconts(:,it1,it2,1))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','--');\n        legs{end+1} = ['bare (',sprintf('%i,%i',[it1 it2]),'), imag'];\n\n        plot(ocont,imag(Aimp1(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-.');\n        legs{end+1} = ['Bulla (',sprintf('%i,%i',[it1 it2]),'), imag'];\n\n        plot(ocont,imag(Aimp2(:,it1,it2))*(pi*Gamma),'Color',clrs{mod(cnt,numel(clrs))+1},'LineStyle','-');\n        legs{end+1} = ['Kugler (',sprintf('%i,%i',[it1 it2]),'), imag'];\n\n        cnt = cnt+1;\n    end\nend\nhold off;\nlegend(legs(:));\nxlim([-1 1]);\nxlabel('\\omega');\nylabel('\\pi \\Gamma A (\\omega)');\n</code></pre>"},{"location":"examples/NRG/Ex_SIAM/","title":"Ex SIAM","text":"<pre><code>% Example: NRG calculation of SIAM\n\nclear\n\nnum_threads_SL(8); % set this in the beginning; otherwise an error message occurs due to missing multithreading environment\n\n% % System paramters\n% Impurity Hamiltonian parameters\nU = 0.2; % interaction strength\nepsd = -U/2; % on-site level\nB = 0; % Zeeman field at the impurity, along the z direction\n\nT = 1e-7; % system temperature\n\n% Hybridization function parametrized by the frequency grid 'ozin' and the\n% function value 'RhoV2in' evaluated at 'ozin'. Here consider a simple\n% box-shaped case.\nD = 1; % half-bandwidth\nGamma = 0.03; % hybridization strength\nozin = [-D;D];\nRhoV2in = (Gamma/pi)*[1;1]; % values outside of the 'ozin' grid are assumed to be zero\n\n% NRG parameter\nLambda = 2;\nN = max(ceil(-2*log(T/500)/log(Lambda)),20);\nnz = 2;\nNkeep = 500;\nEtrunc = 9;\nETRUNC = inf(1,20);\n\nisHDD = false; % true: write/read temporary raw data to/from the disk, false: raw data stay in the memory\nif isHDD\n    nrgdata = go('data/NRG/NRG'); % location to save the results in hard disk drive\nend\n\n[ff,gg,dff,dgg] = doZLD(ozin,RhoV2in,Lambda,N,nz,'Nfit',round(-2*log(1e-8)/log(Lambda)));\n\n% Symmetries to use\nsymstr = {'Acharge,Aspin'; ...   % U(1) charge * U(1) spin\n          'Acharge,SU2spin'; ... % U(1) charge * SU(2) spin\n          'SU2charge,Aspin'; ... % SU(2) charge * U(1) spin\n          'SU2charge,SU2spin'};  % SU(2) charge * SU(2) spin\n\nfor its = (1:numel(symstr))\n    if (contains(symstr{its},'Aspin') || (B == 0)) &amp;&amp; ... % finite Zeeman term is only compatible with U(1) spin\n            (contains(symstr{its},'Acharge') || (U == -2*epsd)) % SU(2) charge is only compatible with half filling\n        % Define operators\n        [FF,ZF,SF,IF] = getLocalSpace('FermionS',symstr{its},'NC',1);\n        [FF,ZF,SF,EF] = setItag('s00','op',FF(:),ZF,SF(:),IF.E);\n\n        NF = quadOp(FF,FF,[]); % particle number operators\n\n        if contains(symstr{its},'Acharge')\n            HU = (U/2)*sum(NF)*(sum(NF)-EF); % interaction term\n            Hepsd = sum(NF)*epsd; % on-site level term\n        else\n            % in case of SU(2) charge, Hepsd is \"absorbed\" into HU, since\n            % they cannot be distinguished\n            HU = (-U/2)*getsub(EF,find(EF.Q{1}(:,1) == 0)); % half-filled sector has energy -U/2\n            Hepsd = QSpace;\n        end\n        if contains(symstr{its},'Aspin')\n            HB = -B*SF(3); % Zeeman term\n        else\n            HB = QSpace;\n        end\n        FHU = QSpace(size(FF));\n        for ito = (1:numel(FF))\n            FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito)); % commutator [FF,HU], to be used for the self-energy trick\n        end\n\n        A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]); % isometry\n        H0 = contract(A0,'!2*',{HU+Hepsd+HB,'!1',A0}) + 1e-40*getIdentity(A0,2); % add \"infinitesimal\" term to keep all symmetry sectors\n\n        % Impurity spectral functions for spin-up electrons\n        Adiscs = cell(3,nz); % discrete data\n        % 1st row: bare correlator &lt; FF || FF' &gt;, 2nd row: auxiliary correlator &lt;\n        % FHU || FF' &gt;, 3rd row: auxiliary correlator &lt; FHU || FHU' &gt;\n        Aconts = cell(1,size(Adiscs,1)); % continuous (i.e., broadened) spectral function\n\n        for itz = (1:nz) % for different z shifts\n            if isHDD\n                % HDD mode: write temporary raw data to the disk, to be read later\n                if contains(symstr{its},'SU2charge')\n                    NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2);\n                    % gg and dgg are not relevant if SU(2) charge symmetry\n                    % is used; also note 'zflag',2\n                else\n                    NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},NF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'dgg',dgg{itz});\n                end\n            else    \n                % memory-only mode\n                if contains(symstr{its},'SU2charge')\n                    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2);\n                    % gg and dgg are not relevant if SU(2) charge symmetry\n                    % is used; also note 'zflag',2\n                else\n                    nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF,gg{itz},NF, ...\n                        'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'dgg',dgg{itz});\n                end\n            end\n\n            % Plot finite-size spectrum (or energy flow diagram, as another name)\n            if itz == nz\n                plotE(nrgdata,'title',symstr{its});\n            end\n\n            if isHDD\n                getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n            else\n                nrgdata = getRhoFDM(nrgdata,T,'-v','Rdiag',true);\n            end\n            % NOTE: In the conventional NRG calculations (corresponding to\n            % \"'Rdiag',false\"), the reduced density matrices ('RhoK') are not\n            % diagonal in the basis of the kept states ('AK'). The option\n            % \"'Rdiag',true\" redefines the kept states to make the reduced density\n            % matrix diagonal, which improves the overall accuracy.\n\n            [odisc,Adiscs(:,itz),sigmak] = getAdisc(nrgdata,[FF(1);FHU(1);FHU(1)],[FF(1);FF(1);FHU(1)],ZF);\n        end\n\n        for ita = (1:size(Adiscs,1))\n            [ocont,Aconts{ita}] = getAcont(odisc,mean(cell2mat(reshape(Adiscs(ita,:),[1 1 nz])),3),sigmak,T/5,'alphaz',1/nz);\n        end\n\n        Adisc2sum = mean(cellfun(@(x) sum(x(:)), Adiscs(2,:)));\n\n        % Obtain improved estimates of the impurity spectral function, by using the\n        % equations of motion (EoM)\n        if contains(symstr{its},'Acharge')\n            [SE1,Aimp1] = SEtrick(ocont,Aconts{1},Aconts{2}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd+(-B/2)); % level shift of -B/2 for spin-up due to Zeeman\n            % \"Bulla's self-energy trick\", which uses asymmetric EoM\n            [SE2,Aimp2] = SEtrick(ocont,Aconts{1},Aconts{2},Adisc2sum,Aconts{3}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',epsd+(-B/2)); % level shift of -B/2 for spin-up due to Zeeman\n            % Kugler's method, which uses symmetric EoM\n        else\n            % in case of SU(2) charge symmetry, Hepsd is absorbed into HU,\n            % so replace the 'epsd' contribution with 0\n            [SE1,Aimp1] = SEtrick(ocont,Aconts{1},Aconts{2}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',0+(-B/2));\n            [SE2,Aimp2] = SEtrick(ocont,Aconts{1},Aconts{2},Adisc2sum,Aconts{3}, ...\n                'ozin',ozin,'RhoV2in',RhoV2in,'epsd',0+(-B/2));\n        end\n\n        figure;\n        hold on;\n        plot(ocont(ocont&gt;0),Aconts{1}(ocont&gt;0));\n        % multiply pi*Gamma so that the multiplied height at zero frequency is 1,\n        % which is consistent with the Friedel sum rule for half-filled impurity\n        plot(ocont(ocont&gt;0),Aimp1(ocont&gt;0));\n        plot(ocont(ocont&gt;0),Aimp2(ocont&gt;0));\n        plot(ocont(ocont&gt;0),zeros(sum(ocont&gt;0),1)+ ...\n            (sin(pi*mean(cellfun(@(x) sum(sum(x,2)./(exp(odisc/T)+1)), Adiscs(1,:))))^2)/(pi*Gamma), ...\n            'Color','k','LineStyle','--'); % Friedel sum rule: sin^2 (\\pi n_{d,\\sigma}) / (\\pi \\Gamma)\n        legend({'bare','Bulla','Kugler','sum rule'});\n        set(gca,'XScale','log','XLim',[T/10,10]);\n        xlabel('$\\omega$','Interpreter','latex');\n        ylabel('$\\pi \\Gamma \\cdot A_{\\uparrow} (\\omega)$','Interpreter','latex');\n        title(symstr{its});\n        hold off;\n    end\nend\n\n\n\n\n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz}); % HDD mode\n% %     nrgdata = NRG_SL([],H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz}); % use this line for RAM mode\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','U(1) charge * U(1) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v'); % HDD mode\n% %     nrgdata = getRhoFDM(nrgdata,T,'-v'); % use this line for RAM mode\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF(1);FHU(1)],[FF(1);FF(1)],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% % z-averaging discrete data\n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [SE,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],epsd);\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0) Acont2(ocont&gt;0) ... \n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega) for spin up');\n% title('U(1) charge * U(1) spin');\n% % % % %\n% \n% % % % % U(1) charge * SU(2) spin\n% % Define operators\n% [FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n% [FF,ZF,SF,EF] = setItag('s00','op',FF,ZF,SF,IF.E);\n% \n% % impurity Hamiltonian\n% NF = contract(FF,'!2*',FF);\n% HU = (U/2)*NF*(NF-1);\n% H0 = HU + epsd*NF + EF*1e-33; % no Zeeman term by construction\n% A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\n% FHU = contract(FF,'!1',HU,[1 3 2])-contract(HU,'!1',FF); % [FF,HU]\n% H0 = contract(A0,'!2*',{H0,'!1',A0});\n% \n% Adisc1 = cell(1,nz);\n% Adisc2 = cell(1,nz);\n% \n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz});\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','U(1) charge * SU(2) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v');\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF;FHU],[FF;FF],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [~,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],epsd);\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0)/2 Acont2(ocont&gt;0)/2 ... % /2 due to the sum over spins\n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega)');\n% title('U(1) charge * SU(2) spin');\n% % % % %\n% \n% %%\n% \n% % % % % SU(2) charge * U(1) spin\n% % Define operators\n% [FF,ZF,SF,IF] = getLocalSpace('FermionS','SU2charge,Aspin','NC',1);\n% [FF,ZF,SF,EF] = setItag('s00','op',FF,ZF,SF,IF.E);\n% \n% % impurity Hamiltonian\n% HU = getsub(EF,find(EF.Q{1}(:,1) == 0))*(-U/2); % subspace of half filling * (-U/2)\n% H0 = HU + B*SF(3) + EF*1e-33;\n% A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\n% H0 = contract(A0,'!2*',{H0,'!1',A0});\n% FHU = QSpace;\n% for ito = (1:numel(FF))\n%     FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito)); % [FF,HU]\n% end\n% \n% Adisc1 = cell(1,nz);\n% Adisc2 = cell(1,nz);\n% \n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2); % Note option zflag\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','SU(2) charge * U(1) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v');\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF(1);FHU(1)],[FF(1);FF(1)],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [~,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],0); % Note option edshift\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0)/2 Acont2(ocont&gt;0)/2 ... % /2 due to the sum over particle-hole symmetry\n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega) for spin-up');\n% title('SU(2) charge * U(1) spin');\n% % % % %\n% \n% %%\n% % % % % SU(2) charge * SU(2) spin\n% % Define operators\n% [FF,ZF,SF,IF] = getLocalSpace('FermionS','SU2charge,SU2spin','NC',1);\n% [FF,ZF,SF,EF] = setItag('s00','op',FF,ZF,SF,IF.E);\n% \n% % impurity Hamiltonian\n% HU = getsub(EF,find(EF.Q{1}(:,1) == 0))*(-U/2); % subspace of half filling * (-U/2)\n% H0 = HU + EF*1e-33; % no Zeeman term by construction\n% A0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'K00*',[1 3 2]);\n% FHU = contract(FF,'!1',HU,[1 3 2])-contract(HU,'!1',FF); % [FF,HU]\n% H0 = contract(A0,'!2*',{H0,'!1',A0});\n% \n% Adisc1 = cell(1,nz);\n% Adisc2 = cell(1,nz);\n% \n% for itz = (1:nz)\n%     NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},FF,ZF,'Nkeep',Nkeep,'Etrunc',Etrunc,'ETRUNC',ETRUNC,'dff',dff{itz},'zflag',2); % Note option zflag\n%     if itz == nz\n%         [Es,Qs] = plotE(nrgdata,'title','SU(2) charge * SU(2) spin');\n%     end\n%     getRhoFDM(nrgdata,T,'-v');\n%     [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF;FHU],[FF;FF],ZF);\n%     Adisc1{itz} = Adiscz{1};\n%     Adisc2{itz} = Adiscz{2};\n% end\n% \n% Adisc1avg = mean(cell2mat(reshape(Adisc1,[1 1 nz])),3);\n% Adisc2avg = mean(cell2mat(reshape(Adisc2,[1 1 nz])),3);\n% \n% [ocont,Acont1] = getAcont(odisc,Adisc1avg,sigmak,T/5,'-v','alphaz',1/nz);\n% [~    ,Acont2] = getAcont(odisc,Adisc2avg,sigmak,T/5,'-v','alphaz',1/nz);\n% \n% [~,Aimp] = SEtrick(ocont,Acont1,Acont2,[-1 1],(Gamma/pi)*[1 1],0); % Note option edshift\n% \n% figure;\n% plot(ocont(ocont&gt;0),[Acont1(ocont&gt;0)/4 Acont2(ocont&gt;0)/4 ... % /4 due to the sum over spins and over particle-hole\n%     Aimp(ocont&gt;0)]*(pi*Gamma)); % Friedel sum rule: A(\\omega=0)*\\pi*\\Gamma = 1\n% legend({'A(\\omega) (bare)','A''(\\omega)','A(\\omega) (\\Sigma-improved)'});\n% set(gca,'XScale','log');\n% grid on;\n% xlabel('\\omega');\n% ylabel('A(\\omega)');\n% title('SU(2) charge * SU(2) spin');\n% % % %\n</code></pre>"},{"location":"examples/NRG/Ex_SIAM_iNRG/","title":"Ex SIAM iNRG","text":"<pre><code>% iNRG example of SIAM; break spin symmetry\n\nclear\n\nnum_threads_SL(10);\n\n% Hamiltonian parameter\nU = 0.3;\nepsd = -U/2;\nGamma = 0.1;\nT = 1e-5;\n\n% NRG parameter\nLambda = 2;\nN = max(ceil(-2*log(T)/log(Lambda))+7,20);\nnz = 2;\ninrg = [1 2]; % order of iNRG sub-channels\n% inrg = [2 1];\nNkeep = 1500;\nETRUNC = inf(10,1);\nEtrunc = 10;\nnrgdata = go('data/NRG/NRG');\n\n% Define operators\n[FF,ZF,SF,IF] = getLocalSpace('FermionS','Acharge,Aspin','NC',1);\n[FF,ZF,EF] = setItag('s00','op',FF,ZF,IF.E);\n\n% impurity Hamiltonian\nNF = QSpace;\nfor ito = (1:2)\n    NF(ito) = contract(FF(ito),'!2*',FF(ito));\nend\nHU = (U/2)*sum(NF)*(sum(NF)-1);\nH00 = HU + epsd*sum(NF) + 1e-30*EF;\nA0 = getIdentity(setItag('L00',getvac(EF)),2,EF,2,'A00*',[1 3 2]);\nH0 = contract(A0,'!2*',{H00,'!1',A0});\n\nFHU = QSpace; % [FF,HU], to compute the correlator &lt; [d,H_U] || d' &gt;\nfor ito = (1:2)\n    FHU(ito) = contract(FF(ito),'!1',HU,[1 3 2])-contract(HU,'!1',FF(ito));\nend\n\n% Operators within the bath\n[Fp,Zp] = singleFZ(FF,ZF);\n% NOTE: Input array of Z operators for NRG_SL should have one-to-one\n% correspondence to the iNRG sub-channels (NOT to particle flavors). That\n% is, Z(n) corresponds to the n-th sub-channel that contains ALL the\n% particle flavors j such that iflag(j) == n. If a sub-channel contains\n% more than one flavor, one may use 'chainSpace' routine to generate the Z\n% operator for the sub-channel.\nZp2 = QSpace(1,max(inrg));\nfor ito = (1:max(inrg))\n    oktmp = (inrg == ito);\n    if sum(oktmp) == 1\n        Zp2(ito) = Zp(inrg == ito);\n    elseif sum(oktmp) &gt; 1\n        [~,Zp2(ito)] = chainSpace(Fp(oktmp),(1:sum(oktmp)),Zp(oktmp));\n    else\n        error(['ERR: no Z operator for iNRG sub-channel #',sprintf('%i',ito)]);\n    end\nend\n\n[ff,~,dff] = doZLD([-1 1],(Gamma/pi)*ones(2,max(inrg)),Lambda,N,nz,'inrg',inrg);\nAdisc11 = cell(1,1,nz); % spin-up, &lt; d || d' &gt;\nAdisc12 = cell(1,1,nz); % spin-down, &lt; d || d' &gt;\nAdisc21 = cell(1,1,nz); % spin-up, &lt; [d,H_U] || d' &gt;\nAdisc22 = cell(1,1,nz); % spin-down, &lt; [d,H_U] || d' &gt;\n\nfor itz = (1:nz)\n    NRG_SL(nrgdata,H0,A0,Lambda,ff{itz},Fp,Zp2, ...\n        'Nkeep',Nkeep,'ETRUNC',ETRUNC,'Etrunc',Etrunc,'F0',FF,'iflag',inrg,'dff',dff{itz});\n    if itz == nz\n        [Es,Qs] = plotE(nrgdata,'noshow');\n        plotE(Es(1:2:end),Qs(1:2:end));\n    end\n    getRhoFDM(nrgdata,T,'-v');\n    [odisc,Adiscz,sigmak] = getAdisc(nrgdata,[FF(:);FHU(:)],[FF(:);FF(:)],ZF);\n    Adisc11{itz} = Adiscz{1};\n    Adisc12{itz} = Adiscz{2};\n    Adisc21{itz} = Adiscz{3};\n    Adisc22{itz} = Adiscz{4};\nend\n\nAdisc11avg = mean(cell2mat(Adisc11),3);\nAdisc12avg = mean(cell2mat(Adisc12),3);\nAdisc21avg = mean(cell2mat(Adisc21),3);\nAdisc22avg = mean(cell2mat(Adisc22),3);\n\n[ocont,Acont11] = getAcont(odisc,Adisc11avg,sigmak,T/10,'-v','alphaz',1/nz);\n[~    ,Acont12] = getAcont(odisc,Adisc12avg,sigmak,T/10,'-v','alphaz',1/nz);\n[~    ,Acont21] = getAcont(odisc,Adisc21avg,sigmak,T/10,'-v','alphaz',1/nz);\n[~    ,Acont22] = getAcont(odisc,Adisc22avg,sigmak,T/10,'-v','alphaz',1/nz);\n\n[SE,Aimp] = SEtrick(ocont,(Acont11+Acont12)/2,(Acont21+Acont22)/2, ...\n    'ozin',[-1;1],'RhoV2in',(Gamma/pi)*[1;1],'epsd',epsd);\n\nfigure;\nplot(ocont,[Acont11 Acont12 Aimp]*(pi*Gamma));\nxlim([0 1]);\nset(gca,'XScale','log');\ngrid on;\nlegend({'Bare (spin-up)','Bare (spin-down)','Improved (spin-averaged)'});\n</code></pre>"},{"location":"examples/NRG/NRG1_Energy_Flow/","title":"NRG-1: Energy Flow","text":"<p>Author: QSpace version written by Andreas Gleis</p> <p>Numerical renormalization group (NRG) is a method for solving quantum impurity systems. Kenneth G. Wilson has itnvented NRG to solve the Kondo problem which was not solvable then. The invention of NRG, indeed, is a part of his Nobel prize citation. NRG is an ancestor of all numerical methods having \"renormalization group\" in their names.</p>"},{"location":"examples/NRG/NRG1_Energy_Flow/#logarithmic-discretization-of-bath","title":"Logarithmic discretization of bath","text":"<p>The starting point of the methods we covered before, such as DMRG and iTEBD, is the Hamiltonian of a system which is already discrete, such as chain. On the other hand, an NRG calculation starts from discretizing the continuous system.</p> <p>Here we consider an example of quantum impurity system, where the impurity is a spinful fermionic level and the bath consists of non-interacting spinful fermions. The Hamiltonian is given by</p> \\[ H = H_\\mathrm{imp} [ \\hat{d}_s, \\hat{d}_s^\\dagger ] + H_\\mathrm{hyb} [ \\hat{d}_s,  \\hat{d}_s^\\dagger , \\hat{c}_{ks}, \\hat{c}_{ks}^\\dagger  ] + H_\\mathrm{bath}  [ \\hat{c}_{ks}, \\hat{c}_{ks}^\\dagger ], \\] \\[ H_\\mathrm{hyb} = \\sum_k \\sum_{s = {\\uparrow},{\\downarrow}} v_k (\\hat{d}_s^\\dagger  \\hat{c}_{ks} + \\hat{c}_{ks}^\\dagger \\hat{d}_s ), \\] \\[H_\\mathrm{bath} = \\sum_k \\sum_{s = {\\uparrow},{\\downarrow}} \\epsilon_k \\hat{c}_{ks}^\\dagger  \\hat{c}_{ks} , \\] <p>where \\(s = {\\uparrow},{\\downarrow}\\) is spin, \\(\\epsilon_k\\) is the energy of bath fermion of momentum \\(k\\), and \\(v_k\\) is the coupling amplitude between the impurity level (to which a particle of spin \\(s\\) is added by applying \\(\\hat{d}_s^\\dagger\\)) and the bath level of momentum \\(k\\). The coupling between the impurity and the bath is characterized by the hybridization function,</p> \\[ \\Delta (\\omega) = \\sum_k v_k^2 \\, \\delta (\\omega - \\epsilon_k). \\] <p>In this demonstration, we choose the Anderson impurity and the \"box-shaped\" hybridization function,</p> \\[ H_\\mathrm{imp} = U \\hat{n}_{d\\uparrow} \\hat{n}_{d\\downarrow} + \\epsilon_d  (\\hat{n}_{d\\uparrow} + \\hat{n}_{d\\downarrow}) , \\] \\[ \\Delta (\\omega) = \\frac{\\Gamma}{\\pi} \\Theta (D - \\omega), \\] <p>where \\(\\hat{n}_{ds} = \\hat{d}_{s}^\\dagger \\hat{d}_s\\) is a number operator at the impurity, \\(U\\) is the local Coulomb interaction, \\(\\epsilon_d\\) is the impurity energy level, \\(\\Gamma\\) is hybridzation strength, and \\(D\\) is the half-bandwidth of the bath. This case is called single-impurity Anderson model (SIAM). Throughout this tutorial, we set \\(D=1\\) as an energy unit, without loss of generality. </p> <p>The \"box-shaped\" hybridization function would look like:</p> <p> </p> <p>To discretize this, we consider a logarithmic discretization parameter \\(\\Lambda &gt; 1\\). The logarithmic frequency grid \\(\\pm \\Lambda^{-n}\\) splits the whole bandwidth \\(\\omega \\in [-1, 1]\\) into the intervals \\(\\mathcal{I}_{\\pm n}\\) that are defined by \\(\\mathcal{I}_{+n} = [\\Lambda^{-n}, \\Lambda^{-n+1}]\\) and \\(\\mathcal{I}_{-n} = [-\\Lambda^{-n+1}, -\\Lambda^{-n}]\\).</p> <p> </p> <p>The part of the bath on each interval \\(\\mathcal{I}_{\\pm n}\\) is replaced by a discrete level at \\(\\omega = \\xi_{\\pm n}\\) that is coupled to the impurity with amplitude \\(\\gamma_{\\pm n}\\).</p> <p> </p> <p>The discretized Hamiltonian is written by</p> \\[ H_\\mathrm{bath} \\mapsto H_\\mathrm{bath}^\\mathrm{star} = \\sum_{\\pm n} \\sum_s  \\xi_{\\pm n} \\hat{a}_{\\pm n, s}^\\dagger \\hat{a}_{\\pm n, s} , \\] \\[H_\\mathrm{hyb} \\mapsto H_\\mathrm{hyb}^\\mathrm{star} = \\sum_{\\pm n} \\sum_s  \\gamma_{\\pm n} ( \\hat{d}_s^\\dagger \\hat{a}_{\\pm n, s} + \\hat{a}_{\\pm n, s}^\\dagger   \\hat{d}_s ) . \\] <p>Each discretized bath level (to which a particle of spin \\(s\\) is added by applying \\(\\hat{a}_{\\pm n, s}^\\dagger\\)) represents the part of the bath on an interval \\(\\mathcal{I}_{\\pm n}\\). Therefore the coupling strength of the level should be the same as the integrated hybridazation strength over the inteval,</p> \\[ \\gamma_{\\pm n}^2 = \\int_{\\mathcal{I}_{\\pm n}} \\mathrm{d}\\omega \\, \\Delta  (\\omega) . \\] <p>While the coupling amplitude \\(\\gamma_{\\pm n}\\) is unambigously determined, there are several different ways to determine the discretized level position \\(\\xi_{\\pm n}\\). Here we use the Campo\u2013Oliveira scheme V. L. Campo and L. N. Oliveira, Phys. Rev. B 72, 104432 (2005), which defines the level position \\(\\xi_{\\pm n}\\) as</p> \\[ \\xi_{\\pm n} = \\frac{ \\int_{\\mathcal{I}_{\\pm n}} \\mathrm{d}\\omega \\, \\Delta(\\omega)  }{ \\int_{\\mathcal{I}_{\\pm n}} \\mathrm{d}\\omega \\, \\frac{\\Delta(\\omega)}{\\omega}  } . \\] <p>(This way of determining \\(\\xi_{\\pm n}\\) is better than Wilson's original way. There is a more advanced scheme, but it is harder to implement. That's why we use the Campo\u2013Oliveira scheme here.)</p> <p>The discretized Hamiltonian \\(H_\\mathrm{imp} + H_\\mathrm{hyb}^\\mathrm{star} + H_\\mathrm{bath}^\\mathrm{star}\\) is so-called star-geometry Hamiltonian. The impurity level and the discretized bath levels (as vertices of a graph), which are coupled via hopping (as edges of the graph), can be depicted as a star graph.</p> <p>The code implementing logarithmic discretization described above can be downlodaed doCLD.m</p> <p>you can run the following demonstration for verifying the impelementation:</p> <p><pre><code>clear\n\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\n\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n</code></pre> Since MATLAB indexes the array from 1, we need to shift the indices: |ff(1)| corresponds to \\(t_\\mathrm{imp}\\) and |ff(n)| for \\(n &gt; 1\\) corresponds to \\(t_{\\ell = n-2}\\).</p> <p>The hopping amplitudes |ff| decay exponentianlly, while the on-site energies |gg| are zeros up do double precision. To see this, we rescale the values with factors \\(\\Lambda^{n/2}\\). [Quick exercise: Why \\(\\Lambda^{n/2}\\), not \\(\\Lambda^n\\)? We started from the discretization grid of \\(\\pm \\Lambda^{-n}\\), so it might look weird to have factor 1/2 in the exponent; but of course, there is a good reason.]</p> <pre><code>figure;\nplot([ff gg].*(Lambda.^((1:numel(ff)).'/2)), ...\n    'LineWidth',1);\nset(gca,'FontSize',13,'LineWidth',1);\ngrid on;\nxlabel('Index n');\nlegend({'ff(n) \\times \\Lambda^{n/2}', ...\n    'gg(n) \\times \\Lambda^{n/2}'}, ...\n    'Location','eastoutside');\n</code></pre> <p> </p> <p>The first elements of |ff| deviate from the exponential dependence, as we see the deviation from the horizontal line. They come from the specific details of the hybridization function. For example, the square of ff(1) is equivalent to the integral of the hybridization,</p> \\[ t_\\mathrm{imp}^2 = \\int_{-D}^{D} \\mathrm{d}\\omega \\Delta (\\omega) = 2 \\Gamma D/ \\pi. \\] <pre><code>ff(1)^2 - 2*Gamma/pi % D = 1 as energy unit\n</code></pre>"},{"location":"examples/NRG/NRG1_Energy_Flow/#lanczos-tridiagnolization","title":"Lanczos tridiagnolization","text":"<p>The star-geometry Hamiltonian is \\(H_\\mathrm{imp} + H_\\mathrm{hyb}^\\mathrm{star} + H_\\mathrm{bath}^\\mathrm{star}\\) is mapped onto the Wilson chain Hamiltonian, via the Lanczos tridiagonalization. The Lanczos method (which is implemented, for example, in <code>DMRG/eigs_1site.m</code> in the context of DMRG) first constructs a tridiagonal matrix representation of the input matrix constrained within the Krylov space, and then diagonalizes the tridiagonal matrix to obtain the ground state. The Lanczos tridiagonalization indicates the first part of this process. Here in the mapping onto the Wilson chain, we consider the tridiagonal matrix representation of the quadratic (i.e., single-particle) terms of the bath and the hybridization, without the quartic (i.e., interacting) impurity Hamiltonian.</p> <p>The Wilson chain Hamiltonian for the SIAM is given by</p> \\[ H_{\\mathrm{SIAM}}^{\\mathrm{chain}} = H_\\mathrm{imp} + H_\\mathrm{bath}^\\mathrm{chain}  + H_\\mathrm{hyb}^\\mathrm{chain}, \\] \\[ H_\\mathrm{imp} = U \\hat{n}_{d\\uparrow} \\hat{n}_{d\\downarrow} + \\epsilon_d  (\\hat{n}_{d\\uparrow} + \\hat{n}_{d\\downarrow}), \\] \\[ H_\\mathrm{bath}^\\mathrm{chain} = \\sum_{\\ell \\geq 0} \\sum_{s = \\uparrow,\\downarrow}  t_\\ell \\left( \\hat{f}_{\\ell, s}^\\dagger \\, \\hat{f}_{\\ell+1,s} + \\hat{f}_{\\ell+1,s}^\\dagger  \\, \\hat{f}_{\\ell, s} \\right), \\] \\[ H_\\mathrm{hyb} ^\\mathrm{chain}= \\sum_s t_\\mathrm{imp} \\left( \\hat{d}_s^\\dagger  \\hat{f}_{0,s} + \\hat{f}_{0,s}^\\dagger \\hat{d}_s \\right). \\] <p>Note that the impurity Hamiltonian \\(H_\\mathrm{imp}\\) is not changed along the logarithmic discretization and the tridiagonalizatoin. The Wilson chain is in principle semi-infinite, but in practice we consider a large but finite length. The length \\(N\\) sets in the minimum energy scale \\(\\sim \\Lambda^{-N/2}\\) to consider.</p> <p>We will solve this one-dimensional system with the iterative diagonalization.</p> <p>The code implementing logarithmic discretization described above can be downlodaed NRG_IterDiag.m</p> <p>This NRG style of the iterative diagonalization differs from the iterative diagonalization covered in <code>Examples</code> in that (i) the Hamiltonian is rescaled by the energy scale factors \\(\\sim \\Lambda^{-n/2}\\) and (ii) the energy eigenvalues are shifted so that the lowest energy eigenvalue becomes zero. Other than these, it is the same iterative diagonalization.</p> <p>As a demonstration of the completed iterative diagonalization, we apply it to the SIAM.</p> <p><pre><code>% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\n\n% NRG parameter\nNkeep = 300;\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> Here each line indicates the information of each iteration step: time stamp, number of the kept states, number of the total states, the largest energy of the kept states, the largest energy of the discarded states.</p>"},{"location":"examples/NRG/NRG1_Energy_Flow/#energy-flow-diagram","title":"Energy flow diagram","text":"<p>NRG provides a method to analyze the spectrum obtained along the iterative diagonalization. Let's plot the lowest-lying (many-body) energy levels. We plot the results from even iterations and those from odd iterations separately. The plotting is handled by the function plotEQS|.m|. Please have a look at the code to get an idea how the data from the iterative diagonalization is prepared to finally plot the flow diagram.</p> <pre><code>plotEQS(Inrg);\n</code></pre> <p> </p> <p>These plots are called energy flow diagram or finite-size energy spectra. The name \"flow\" literally comes from that the lines flow from one regime to the other. There are three regions (iterations 1--10; 17--25; 35--55) connected via two crossovers. These regions correspond to different fixed points: free orbital, local moment, and strong coupling. The strong-coupling fixed-point regime exhibits prominent plateau of the energy levels.</p> <p>Exercise: Reproduce lowest-lying energies in the strong-coupling regime by fixed-point Hamiltonians</p> <p>Let's consider iteration 54 in the strong-coupling fixed-point regime.. Their lowest-lying energies, including all degenerate levels, are:</p> <p><pre><code>E = eigQS(diag(Inrg.HK{54}));\nEKodd = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKodd = [EKodd;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKodd = E;\nend\nfprintf([sprintf('%.4f, ',EKodd(1:5).'),'\\n', ...\n    sprintf('%.4f, ',EKodd(6:11).'),'...\\n']);\n</code></pre> We see 1-fold, 4-fold, and 6-fold degeneracies. On the other hand, the energy levels at the next iteration 55 have more degeneracies:</p> <pre><code>E = eigQS(diag(Inrg.HK{55}));\nEKeven = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKeven = [EKeven;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKeven = E;\nend\nfprintf([sprintf('%.4f, ',EKeven(1:4).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(5:12).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(13:20).'),'...\\n']);\n</code></pre> <p>There are 4-fold and 16-fold degeneracies, up to numerical noise of \\(O(10^{-6})\\). Reproduce these (many-body) energy values by considering strong-coupling fixed-point Hamiltonians. (Hint: The fixed-point Hamiltonians are single-particle Hamiltonians, effectively!)</p> <p>Solution to Exercise: Reproduce lowest-lying energies in the strong-coupling regime by fixed-point Hamiltonians </p> <p>Let's perform the iterative diagonalization first. <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre></p> <p>Then we plot the energy flow diagram:</p> <pre><code>% Energy flow diagram\nplotEQS(Inrg);\n</code></pre> <p> </p> <p>The lowest-lying energies at iteration 54 are:</p> <pre><code>E = eigQS(diag(Inrg.HK{54}));\nEKodd = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKodd = [EKodd;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKodd = E;\nend\nfprintf([sprintf('%.4f, ',EKodd(1:5).'),'\\n', ...\n    sprintf('%.4f, ',EKodd(6:11).'),'...\\n']);\n</code></pre> <p>The fixed-point description for this iteration is that the impurity (site 1) and the first bath site (site 2) are strongly bound and the rest of the chain (from site 3 to site 54) are decoupled from the dimer. So the excitation spectrum is obtained by considering the lowest excitations of the single-particle Hamiltonian for the part from site 3 to site 54, having even number of sites.</p> <pre><code>Hsp = diag(ff(3:53),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:53)]);\nHsp = Hsp/Inrg.EScale(54); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\n\n% many-body energy values\nEvs = [0; ... % ground-state\n    Esp(end/2+1); Esp(end/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp(end/2); -Esp(end/2); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp(end/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp(end/2)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n</code></pre> <p>On the other hand, the lowest-lying energies for iteration 55 have more degeneracies,</p> <pre><code>E = eigQS(diag(Inrg.HK{55}));\nEKeven = []; \nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKeven = [EKeven;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKeven = E;\nend\nfprintf([sprintf('%.4f, ',EKeven(1:4).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(5:12).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(13:20).'),'...\\n']);\n</code></pre> <p>The 4-fold and 16-fold degeneracies can be seen as that extra factor 4 is multiplied to the degeneracies of the 1-fold and 4-fold degeneratices in the case of iteration 54, putting aside different values of energies. This factor 4 can be understood by the fixed-point Hamiltonian as well. The part of the chain decoupled from the strongly coupled dimer has odd number of sites. So it has a zero mode:</p> <pre><code>Hsp = diag(ff(3:54),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:54)]);\nHsp = Hsp/Inrg.EScale(55); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\nfprintf('%.4f\\n',Esp((end+1)/2));\n</code></pre> <p>There are four Fock states regarding the zero mode (empty, spin-up, spin-down, doubly occupied), having all the same zero energy. So it introduces factor 4 to the degeneracies. Factoring out the degrees of freedom of this zero mode, we construct the lowest-lying energies at iteration 55 as for iteration 54:</p> <pre><code>% many-body energy values\nEvs = [0; ... % ground-state\n    Esp((end+1)/2+1); Esp((end+1)/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp((end+1)/2-1); -Esp((end+1)/2-1); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp((end+1)/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp((end+1)/2-1)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n</code></pre>"},{"location":"examples/NRG/NRG1_Energy_Flow/#single-impurity-kondo-model-sikm","title":"Single-Impurity Kondo model (SIKM)","text":"<p>We can derive the Wilson chain Hamiltonian \\(H_\\mathrm{SIKM}^\\mathrm{chain}\\) for the single-impurity Kondo model (SIKM), from the chain Hamiltonian of the SIAM \\(H_\\mathrm{SIAM}^\\mathrm{chain}\\) shown above. By applying the Schrieffer-Wolff transformation to the impurity site (on which \\(\\hat{d}_s\\) acts) and the first bath site (on which \\(\\hat{f}_{0,s}\\) acts), we obtain</p> \\[ H_\\mathrm{SIKM}^\\mathrm{chain} = H_\\mathrm{exc} + H_\\mathrm{bath}, \\] \\[ H_\\mathrm{exc} = 2J \\hat{\\vec{S}}_d \\cdot \\hat{\\vec{S}}_0 , \\] \\[ H_\\mathrm{bath} = \\sum_{\\ell \\geq 0} \\sum_{s = \\uparrow,\\downarrow} t_\\ell \\left( \\hat{f}_{\\ell, s}^\\dagger \\, \\hat{f}_{\\ell+1,s} + \\hat{f}_{\\ell+1,s}^\\dagger \\, \\hat{f}_{\\ell, s} \\right) . \\] <p>Here \\(\\hat{\\vec{S}}_d\\) is the spin operator acting on the impurity site,</p> \\[ \\hat{\\vec{S}}_0 = \\sum_{s,s'} \\hat{f}_{0,s}^\\dagger \\frac{\\vec{\\sigma}_{s,s'}}{2}  \\hat{f}_{0,s'} \\] <p>is the spin operator acting on the first bath site, \\(\\vec{\\sigma} = [\\sigma_x, \\sigma_y, \\sigma_z]\\) is the vector of Pauli matrices, and</p> \\[ J = t_0^2 \\left( \\frac{1}{-\\epsilon_d} + \\frac{1}{U + \\epsilon_d} \\right) \\] <p>is the Kondo coupling strength. For particle-hole symmetric case \\(\\epsilon_d = -U/2\\) which we considered above, it becomes</p> \\[ J = \\frac{4 t_0^2}{U} = \\frac{8 \\Gamma D}{\\pi U}. \\] <p>The bath term \\(H_\\mathrm{bath}\\) is the same as in the SIAM case. Note that the impurity site in the SIKM has dimension 2, while that in the SIAM has 4; the doubly occupied and the empty states are \"integrated out\" by the Schrieffer-Wolff transformation. Refer to J. R. Schrieffer and P. A. Wolff, Phys. Rev. 149, 491 (1966) for the details of the Schrieffer-Wolff transformation.</p> <p>Exercise: Perform the iterative diagonalization of this chain Hamiltonian for the SIKM, with the value of \\(J\\) corresponding to the choice of parameters \\(U\\), \\(\\epsilon_d\\), and \\(\\Gamma\\) above. (Again \\(D = 1\\) is the energy unit.) Compare the energy flow diagram with the SIAM result.</p> <p>(Hint: You can do it by changing <code>H0</code>, <code>A0</code>, and <code>ff</code> only, with using the same function <code>NRG_IterDiagQS</code>!)</p> <p>Solution to Exercise: Single-impurity Kondo model</p> <p>In the example of the SIAM, we set the first leg (i.e., left leg) of <code>A0</code> as a dummy leg for vacuum and the second leg (i.e., bottom leg) for the Anderson impurity. The impurity Hamiltonian \\(H_\\mathrm{imp}\\) involves only one fermionic site (i.e., \\(d\\) level). The rest of the chain Hamiltonian is the hopping and on-site terms that are generated within <code>NRG_IterDiagQS</code>.</p> <p>On the other hand, in the SIKM, the exchange interaction \\(H_\\mathrm{exc}\\) acts on two sites: a spin site for \\(\\hat{\\vec{S}}_d\\) and a spinful fermionic site for \\(\\hat{\\vec{S}}_0\\). The latter site is the first bath site, and coupled with the other fermionic sites via particle hopping that can be generated inside <code>NRG_IterDiagQS</code>.</p> <p>Therefore, to use the same function <code>NRG_IterDiagQS</code> for the SIKM, we associate the first leg of <code>A0</code> with the spin site for \\(\\hat{\\vec{S}}_d\\) and its second leg with the spinful fermionic site for \\(\\hat{\\vec{S}}_0\\). Accordingly, we shift the hopping amplitudes and on-site energies by one site to the left, as the second leg of <code>A0</code> involves the first bath site.</p> <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n</code></pre> <p>Here <code>ff(1)</code>, <code>ff(2)</code>, <code>ff(3)</code>, ... are equal to <code>ff(2)</code>, <code>ff(3)</code>, <code>ff(4)</code>, ... for the <code>ff</code> vector in the SIAM case. Note that the first element <code>ff(1)</code> in the SIAM case depends on the hybridization strength \\(\\Gamma\\); it is absorbed into the definition of \\(J\\) after the Schrieffer-Wolff transformation.</p> <p>Then run the iterative diagonalization, and plot the energy flow diagram.</p> <pre><code>% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <p>Then plot the energy flow:</p> <pre><code>% Energy flow diagram\nplotEQS(Inrg);\n</code></pre> <p> </p> <p>The energy flow diagram looks similar with the diagram for the SIAM, especially the last crossovers and the spectrum at the last iterations in the strong-coupling fixed-point regime. There are two differences as well:</p> <p>The panel for even (odd) iterations in the SIKM case look similar to the panel for odd (even) iterations in the SIAM. It is because we have shifted the chain sites by one to the left. While there are two crossovers in the SIAM, here in the SIKM there is only one crossover, which is from the local moment regime to the Kondo regime.</p>"},{"location":"examples/NRG/NRG2_ImpThermo/","title":"NRG-2: Impurity Contribution  to Thermaldynamic  Properties","text":"<p>Author: Seung-Sup Lee</p> <p>Date: 21.06.2020  (Minor update: 30.06.2020)</p> <p>In this tutorial, we will compute the impurity contribution to the thermodynamic properties  of quantum impurity models. The impurity contribution to a thermodynamic property means the difference between the value of the thermodynamic property of the whole quantum impurity system (which has both the impurity and the bath) and that of the bath only. For example, the impurity contribution to the entropy is given by \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} =S_{{\\mathrm{t}\\mathrm{o}\\mathrm{t}}} -S_{{\\mathrm{b}\\mathrm{a}\\mathrm{t}\\mathrm{h}}}\\) . The subscript \"tot\" means the total system that contain both the impurity and the bath, and the subscript \"bath\" means the bath only.</p> <p>The impurity contributions to  spin susceptibility \\(\\chi_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) , to  entropy \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) , and to  specific heat \\(C_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) have strong temperature dependence, which shows the nature of fixed point regimes (free orbital, local moment, and strong coupling) and the crossover between these regimes.</p> <p>From the spin susceptibility and the specific heat, one can derive the Sommerfeld\u2013Wilson ratio</p> \\[   R=\\frac{\\chi_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} /\\chi_{{\\mathrm{b}\\mathrm{a}\\mathrm{n}\\mathrm{d}}} }{C_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} /C_{{\\mathrm{b}\\mathrm{a}\\mathrm{n}\\mathrm{d}}} }=\\frac{T\\chi_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} }{C_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} }\\times \\frac{4\\pi^2 }{3},  \\] <p>which is the universal value. Figure 6 in [P. Coleman, arXiv:cond-mat/0612006] shows that the Sommerfeld\u2013Wilson ratio for many correlated systems are quite much the same. For non-interacting systems, the ratio is 1. In the Kondo regime of the single-impurity Anderson model (SIAM) or the single-impurity Kondo model (SIKM), the ratio is 2.</p> <p>In this tutorial, we will use the conventional NRG scheme in which only the shell of energy eigenstates within each iteration is considered. The energy spectrum at iteration \\(\\ell\\) is regarded as the effective energy spectrum of the system at temperature \\(T_{\\ell } \\equiv {\\tilde{E} }_{\\ell } /\\beta_0\\) , where \\({\\tilde{E} }_{\\ell } \\propto\\Lambda^{-\\ell /2}\\) is the energy scale at the iteration \\(\\ell\\) (which is an element of the output Inrg.EScale from the iterative diagonalization routine NRG_IterDiagQS) and \\(\\beta_0\\) is a temperature prefactor parameter of order of \\(O(1)\\) . The effective Hamiltonian at the iteration \\(\\ell\\) is given by</p> \\[   {\\hat{H} }_{\\ell } =\\sum_{\\alpha } E_{\\alpha }^{\\ell } |\\alpha \\rangle_{\\ell \\ell } \\langle {\\alpha} |,  \\] <p>where \\(|\\alpha \\rangle_{\\ell }\\) are energy eigenstates (including both kept and discarded states) at the iteration \\(\\ell\\) and \\(E_{\\alpha }^{\\ell }\\) are the corresponding energy eigenvalue. Then the effective density matrix for the iteration \\(\\ell\\) can be constructed as</p> \\[  {\\hat{\\rho} }_{\\ell } =\\sum_{\\alpha } E_{\\alpha }^{\\ell } |\\alpha \\rangle_{\\ell \\ell } \\langle {\\alpha} |\\frac{\\exp \\left(-E_{\\alpha }^{\\ell } /T_{\\ell } \\right)}{Z_{\\ell } },  \\] <p>where \\(Z_{\\ell } =\\sum_{\\alpha } \\exp \\left(-E_{\\alpha }^{\\ell } /T_{\\ell } \\right)\\) is the partition function. The spin susceptibility is given by the variance of the spin- \\(z\\) operator divided by temperature,</p> \\[  T_{\\ell } \\,\\chi (T_{\\ell } )={\\mathrm{T}\\mathrm{r}}\\left({\\hat{\\rho} }_{\\ell } ({\\hat{S} }_{&lt;\\ell ,z} )^2 \\right)-{\\left({\\mathrm{T}\\mathrm{r}}\\left({\\hat{\\rho} }_{\\ell } {\\hat{S} }_{&lt;\\ell ,z} \\right)\\right)}^2 ,  \\] <p>where \\({\\hat{S} }_{&lt;\\ell ,z} =\\sum_{m\\le \\ell } {\\hat{S} }_{mz}\\) is the sum of spin-z operators acting on all the chain sites left from the site \\(\\ell\\) (including the site \\(\\ell\\) also). And the entropy is given by</p> \\[   S(T_{\\ell } )=\\frac{{\\mathrm{T}\\mathrm{r}}\\left({\\hat{\\rho} }_{\\ell } {\\hat{H} }_{\\ell } \\right)}{T_{\\ell } }+\\ln Z_{\\ell } .  \\] <p>For details, refer to Sec. III.A.1 of [R. Bulla et al., Rev. Mod. Phys. 80, 395 (2008) or its arXiv version].</p> <p>The function getTDconvQS.m is designed to compute the spin susceptibility (multiplied with temperature) \\(T_{\\ell } \\chi (T_{\\ell } )\\) and the entropy \\(S(T_{\\ell } )\\) at every iteration \\(\\ell\\) corresponding to temperature \\(T_{\\ell }\\) .</p>"},{"location":"examples/NRG/NRG2_ImpThermo/#single-impurity-anderson-model-siam","title":"Single-impurity Anderson model (SIAM)","text":"<p>As a demonstartion of getTDconv.m, we compute the spin susceptibility \\(\\chi_{{\\mathrm{t}\\mathrm{o}\\mathrm{t}}}\\) and the entropy \\(S_{{\\mathrm{t}\\mathrm{o}\\mathrm{t}}}\\) for the whole SIAM. Here we choose the same parameters as in the last tutorial T10.</p> <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n</code></pre> <p>For this tutorial, we perform a post-processing of the Wilson chain parameters after they are generated by the doCLD function. This post-processing is needed to reduce numerical noise, since the calculation of the impurity contributions to thermodynamic properties is sensitive to the noise. The reason for this sensitivity will be explained later at the end of this document.</p> <p>The doCLD function uses numerical integration for determining the positions and the coupling strengths of discretized levels in a star geometry. So these values of the discretized levels are susceptible to numerical error whose size is proportional to the values themselves. The position and the coupling strength of the level from the outmost discretization interval is much larger, by many orders of maginutes, than those from the nearest discretization interval to the Fermi level (which are finite, due to the finite number of discretization intervals in numerical implementation). Thus relatively small numerical error for the outmost interval can have significant size for the low-energy intervals.</p> <p>The Lanczos tridiagonalization which follows the numerical integration is also susceptible to numerical noise. Especially, the noise is accumulated via successive orthogonalization. As a result, the Wilson chain parameters for later sites have small but finite error.</p> <p>To overcome the inevitable numerical error, we extrapolate the hopping amplitudes for later sites from the values for earlier sites, based on the scaling behavior \\(t_{\\ell } \\propto\\Lambda^{-\\ell /2}\\) for large enough \\(\\ell\\) . Also, we set the on-site energyes as strict zero, which is always true for the particle-hole symmetric bath such that \\(\\Delta (\\omega )=\\Delta (-\\omega )\\) .</p> <pre><code>% Wilson chain\n[ff,~] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,30);\nff = [ff;ff(end).*(Lambda.^(-(1:(N-numel(ff))).'/2))];\ngg = zeros(size(ff));\n</code></pre> <p>The rest is the same for the iterative diagonalization.</p> <pre><code>% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <pre><code>21-05-10 17:11:26 | NRG: start\n21-05-10 17:11:26 | #00/55 : NK=3/3, EK=1e-33/1e-33\n21-05-10 17:11:26 | #01/55 : NK=10/10, EK=0.04891/0.04891\n21-05-10 17:11:26 | #02/55 : NK=35/35, EK=3.207/3.207\n21-05-10 17:11:26 | #03/55 : NK=126/126, EK=6.221/6.221\n21-05-10 17:11:26 | #04/55 : NK=310/462, EK=7.494/13.01\n21-05-10 17:11:26 | #05/55 : NK=310/1154, EK=7.028/13.07\n21-05-10 17:11:26 | #06/55 : NK=318/1150, EK=7.238/13.61\n21-05-10 17:11:27 | #07/55 : NK=310/1178, EK=7.043/13.08\n21-05-10 17:11:27 | #08/55 : NK=318/1150, EK=7.244/13.61\n21-05-10 17:11:27 | #09/55 : NK=310/1178, EK=7.068/13.12\n21-05-10 17:11:27 | #10/55 : NK=318/1150, EK=7.27/13.59\n21-05-10 17:11:27 | #11/55 : NK=310/1178, EK=7.112/13.18\n21-05-10 17:11:27 | #12/55 : NK=318/1150, EK=7.354/13.58\n21-05-10 17:11:27 | #13/55 : NK=310/1178, EK=7.202/13.32\n21-05-10 17:11:27 | #14/55 : NK=322/1150, EK=7.684/13.89\n21-05-10 17:11:27 | #15/55 : NK=312/1192, EK=7.455/13.81\n21-05-10 17:11:28 | #16/55 : NK=327/1166, EK=8.38/14.69\n21-05-10 17:11:28 | #17/55 : NK=304/1218, EK=8.445/14.97\n21-05-10 17:11:28 | #18/55 : NK=307/1136, EK=9.021/16.03\n21-05-10 17:11:28 | #19/55 : NK=312/1148, EK=9.324/16.01\n21-05-10 17:11:28 | #20/55 : NK=311/1170, EK=9.713/17.49\n21-05-10 17:11:28 | #21/55 : NK=327/1174, EK=9.798/17.17\n21-05-10 17:11:28 | #22/55 : NK=311/1231, EK=9.775/18.24\n21-05-10 17:11:28 | #23/55 : NK=302/1174, EK=9.745/17.31\n21-05-10 17:11:28 | #24/55 : NK=311/1134, EK=9.83/17.87\n21-05-10 17:11:28 | #25/55 : NK=322/1174, EK=9.973/17.45\n21-05-10 17:11:29 | #26/55 : NK=311/1210, EK=9.91/18.34\n21-05-10 17:11:29 | #27/55 : NK=322/1174, EK=10.12/17.63\n21-05-10 17:11:29 | #28/55 : NK=325/1210, EK=10.17/18.31\n21-05-10 17:11:29 | #29/55 : NK=322/1224, EK=10.33/18.22\n21-05-10 17:11:29 | #30/55 : NK=315/1210, EK=10.19/18.34\n21-05-10 17:11:29 | #31/55 : NK=322/1184, EK=10.64/18.35\n21-05-10 17:11:29 | #32/55 : NK=303/1210, EK=10.33/18.75\n21-05-10 17:11:29 | #33/55 : NK=300/1136, EK=10.78/18.8\n21-05-10 17:11:29 | #34/55 : NK=318/1122, EK=10.93/18.83\n21-05-10 17:11:29 | #35/55 : NK=300/1190, EK=11.32/19.87\n21-05-10 17:11:30 | #36/55 : NK=301/1119, EK=11.16/19.38\n21-05-10 17:11:30 | #37/55 : NK=316/1118, EK=11.93/20.39\n21-05-10 17:11:30 | #38/55 : NK=306/1175, EK=11.6/20.39\n21-05-10 17:11:30 | #39/55 : NK=310/1136, EK=12.08/21.48\n21-05-10 17:11:30 | #40/55 : NK=306/1151, EK=11.75/20.69\n21-05-10 17:11:30 | #41/55 : NK=307/1136, EK=11.97/21.77\n21-05-10 17:11:30 | #42/55 : NK=306/1139, EK=11.82/20.13\n21-05-10 17:11:30 | #43/55 : NK=309/1136, EK=12.19/21.89\n21-05-10 17:11:31 | #44/55 : NK=306/1147, EK=11.84/20.87\n21-05-10 17:11:31 | #45/55 : NK=309/1136, EK=12.21/21.94\n21-05-10 17:11:31 | #46/55 : NK=306/1147, EK=11.85/20.89\n21-05-10 17:11:31 | #47/55 : NK=309/1136, EK=12.21/21.96\n21-05-10 17:11:31 | #48/55 : NK=306/1147, EK=11.86/20.89\n21-05-10 17:11:31 | #49/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:31 | #50/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:31 | #51/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:31 | #52/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:32 | #53/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:32 | #54/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:32 | #55/55 : NK=0/1136, EK=0/21.97\n21-05-10 17:11:32 | Memory usage : 3.41GiB\nElapsed time: 5.765s, CPU time: 13.74s, Avg # of cores: 2.383\n</code></pre> <p>Now we compute the thermodynamic quantities for the whole impurity model (impurity + bath). We use the temperature prefactor parameter \\(\\beta_0 =1\\) .</p> <pre><code>beta0 = 1; % parameter to define temperature values\n[T,Tchi,Sent] = getTDconvQS(Inrg,beta0);\n% temperature T, T * spin susceptibility chi, entropy S\n\nfigure;\nhold on;\nplot(T,Tchi,'LineStyle','-','Marker','x','LineWidth',1);\nplot(T,Sent,'LineStyle','-','Marker','+','LineWidth',1);\nhold off;\nset(gca,'XScale','log','LineWidth',1,'FontSize',13);\nlegend({' $T \\chi$ ', ' $S$ '}, ...\n    'Interpreter','latex','Location','northwest');\nxlabel(' $T$ ','Interpreter','latex');\ntitle('Impurity + bath');\nxlim([min(T) max(T)]);\ngrid on;\n</code></pre> <p> </p>"},{"location":"examples/NRG/NRG2_ImpThermo/#thermodynamic-properties-of-the-bath-only","title":"Thermodynamic properties of the bath only","text":"<p>Then we compute the same properties when there is no impurity in the system. The simplest way is to apply large on-site potential to the impurity which effectively empties out the impurity. By using the same functions except for the large on-site potential, the results are given on the same temperature grid.</p> <pre><code>% \"without\" impurity\nH0_2 = 1e4*sum(NF);\n\nH0_2 = contract(A0,'!2*',{A0,H0_2}) + 1e-33*contract(A0,'!2*',A0);\n\n% take the impurity level epsd to be far above the band edge (epsd &gt;&gt; 1);\n% effectively emptied out\nInrg2 = NRG_IterDiagQS(H0_2,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <pre><code>21-05-10 17:11:33 | NRG: start\n21-05-10 17:11:33 | #00/55 : NK=3/3, EK=2e+04/2e+04\n21-05-10 17:11:33 | #01/55 : NK=10/10, EK=1.932e+04/1.932e+04\n21-05-10 17:11:33 | #02/55 : NK=35/35, EK=3.055e+04/3.055e+04\n21-05-10 17:11:33 | #03/55 : NK=126/126, EK=4.83e+04/4.83e+04\n21-05-10 17:11:33 | #04/55 : NK=326/462, EK=3.819e+04/7.637e+04\n21-05-10 17:11:33 | #05/55 : NK=310/1216, EK=12.48/6.038e+04\n21-05-10 17:11:33 | #06/55 : NK=309/1154, EK=12.22/23.03\n21-05-10 17:11:34 | #07/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:34 | #08/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:34 | #09/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:34 | #10/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:34 | #11/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:34 | #12/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:34 | #13/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:34 | #14/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:34 | #15/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:35 | #16/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:35 | #17/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:35 | #18/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:35 | #19/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:35 | #20/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:35 | #21/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:35 | #22/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:35 | #23/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:35 | #24/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:36 | #25/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:36 | #26/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:36 | #27/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:36 | #28/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:36 | #29/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:36 | #30/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:36 | #31/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:36 | #32/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:36 | #33/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:36 | #34/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:37 | #35/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:37 | #36/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:37 | #37/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:37 | #38/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:37 | #39/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:37 | #40/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:37 | #41/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:37 | #42/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:37 | #43/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:38 | #44/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:38 | #45/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:38 | #46/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:38 | #47/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:38 | #48/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:38 | #49/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:38 | #50/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:38 | #51/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:38 | #52/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:38 | #53/55 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:11:39 | #54/55 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:11:39 | #55/55 : NK=0/1147, EK=0/20.9\n21-05-10 17:11:39 | Memory usage : 3.45GiB\nElapsed time: 5.599s, CPU time: 13.21s, Avg # of cores: 2.359\n</code></pre> <pre><code>[~,Tchi2,Sent2] = getTDconvQS(Inrg2,beta0);\n</code></pre> <p>Plot the obtained data. The values show simpler temperature dependence than those of the whole impurity system.</p> <pre><code>figure;\nhold on;\nplot(T,Tchi2,'LineStyle','-','Marker','x','LineWidth',1);\nplot(T,Sent2,'LineStyle','-','Marker','+','LineWidth',1);\nhold off;\nset(gca,'XScale','log','LineWidth',1,'FontSize',13);\nlegend({' $T \\chi$ ', ' $S$ '}, ...\n    'Interpreter','latex','Location','west');\nxlabel(' $T$ ','Interpreter','latex');\ntitle('Bath only');\nxlim([min(T) max(T)]);\ngrid on;\n</code></pre> <p> </p>"},{"location":"examples/NRG/NRG2_ImpThermo/#impurity-contribution","title":"Impurity contribution","text":"<p>Subtract the values for the bath only from those for the whole impurity model, to obtain the impurity contribution.</p> <pre><code>% impurity contribution to the spin susceptibility * temperature\nTchi_imp = Tchi - Tchi2; \n% impurity contribution to the entropy\nSent_imp = Sent - Sent2;\n</code></pre> <p>The specific heat can be obtained by differentiating the entropy,</p> <p>$$ C=T\\frac{{\\mathrm{d}}S}{{\\mathrm{d}}T}=\\frac{{\\mathrm{d}}S}{{\\mathrm{d}}(\\ln T)}. $$  <pre><code>logT = log(T);\n% impurity contribution to the specific heat C = T* dS/dT = dS / d(log T)\n% numerical differentiation\nC_imp = interp1((logT(1:end-1)+logT(2:end))/2, ...\n    diff(Sent_imp)./diff(logT),logT,'linear','extrap');\n</code></pre></p> <p>Then we obtain the Sommerfeld\u2013Wilson ratio.</p> <pre><code>% Sommerfeld-Wilson ratio\nWR = (Tchi_imp./C_imp)*(4*(pi^2)/3);\n</code></pre> <p>The characteritic temperature scale of the Kondo regime is, literally, the Kondo temperature \\(T_{{\\mathrm{K}}}\\) . The Kondo temperature is the energy scale at which the crossover to the Kondo regime happens. Since the crossover is a smooth change, there are different ways to define the Kondo temperature, which give similar but different values. In this analysis, we use the formula given by the Bethe ansatz solution:</p> \\[  T_{{\\mathrm{K}}} =\\sqrt{\\frac{U\\Gamma }{2}}\\exp \\left(-\\frac{\\pi U}{8\\Gamma }+\\frac{\\pi \\Gamma }{2U}\\right)  \\] <pre><code>% Kondo temperature from the Bethe ansatz\nTK = sqrt(U*Gamma/2)*exp(-pi*U/8/Gamma + pi*Gamma/2/U);\ndisp(TK);\n</code></pre> <pre><code>1.5106e-06\n</code></pre> <p>Plot the result.</p> <pre><code>figure;\nsemilogx(T/TK,(Tchi_imp./T)*(4*TK), ...\n    T/TK,Sent_imp/log(2), ...\n    T/TK,WR,'LineWidth',1);\nset(gca,'LineWidth',1,'FontSize',13,'XTick',10.^(-4:2:4));\nxlabel(' $T / T_\\mathrm{K}$ ','Interpreter','latex');\nlegend({' $4 T_\\mathrm{K} \\chi_\\mathrm{imp}$ '; ...\n    ' $S_\\mathrm{imp} / \\ln 2$ '; ...\n    ' $R$ '}, ...\n    'Interpreter','latex','Location','northeast');\nylim([0 3]);\nxlim([min(T) max(T)]/TK);\ngrid on;\n</code></pre> <p> </p> <p>At \\(T\\ll T_{{\\mathrm{K}}}\\) , the Sommerfeld\u2013Wilson ratio \\(R\\) becomes 2, up to 3% error. The impurity contribution to the entropy \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) is \\(\\ln 4\\) at high temperature \\(T\\gg U\\) , then decreases to \\(\\ln 2\\) , and then finally vanishes at temperatures \\(T\\ll T_{{\\mathrm{K}}}\\) . These values indeed represent the nature of different fixed-point regimes:</p> <ol> <li>Free orbital regime: At \\(T\\gg U\\) , all four states of the impurity can be populated, so the presence of the impurity adds up \\(\\ln 4\\) to the entropy.</li> <li>Local moment regime: At \\(T_{{\\mathrm{K}}} \\ll T\\ll U\\) , only the singly occupied states of the impurity can be populated. So the impurity contribution is \\(\\ln 2\\) , for two impurity states of \\(S_{d,z} =\\pm 1/2\\) .</li> <li>Strong coupling regime: At \\(T\\ll T_{{\\mathrm{K}}}\\) , the impurity spin and the bath form the Kondo singlet. The impurity state is locked into the bath state; the impurity and the bath are quantum entangled. Thus there is no additional entropy by the presence of the impurity.</li> </ol> <p>There are a few technical remarks.</p> <ol> <li>The values of \\(T\\chi\\) and \\(S\\) , for the whole impurity system and for the bath only, depend on the choice of \\(\\beta_0\\) . However, their subtractions \\(T\\chi_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) and \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) do not change much with changing \\(\\beta_0\\) . (Quick exercise: try out different values of \\(\\beta_0\\) .)</li> <li>There is a kink in the curve of the Sommerfeld\u2013Wilson ratio at the lowest temperatures ( \\(T\\sim 10^{-5} T_{{\\mathrm{K}}}\\) ). This is a numerical noise. The Sommerfeld\u2013Wilson ratio at such temperatures is given by the ratio between two small values, and each small value is given by the subtraction of two large values (one for the whole impurity and the other for the bath only). For example, Tchi(end) and Tchi2(end) are \\(O(0.1)\\) , but their difference, Tchi_imp(end) is just \\(O(10^{-6} )\\) . That's why we have performed the post-processing of the Wilson chain paramers above.</li> </ol> <p>Exercise: Single-impurity Kondo model</p> <p>Compute the theremodynamic properties for the single-impurity Kondo model, for the value of \\(J=8\\Gamma D/\\pi U\\) , considering the same values of \\(\\Gamma\\) and \\(U\\) used in the above demonstration. Compare your result with Fig. 5 in [R. Bulla et al., Rev. Mod. Phys. 80, 395 (2008)]. Also compare with the SIAM result of \\(4T_{{\\mathrm{K}}} \\chi_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}}\\) , \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} /\\ln 2\\) , and \\(R\\) , shown in the above demonstration.</p> <p>Solution to exercise: Single-impurity Kondo model</p> <p>Perform the iterative diagonalization for the whole Kondo model (SIKM). For details of the iterative diagonalization for the SIKM, refer to the solution to T10b.</p> <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,~] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,30);\n% post-processing\nff = [ff;ff(end).*(Lambda.^(-(1:(N-numel(ff))).'/2))];\ngg = zeros(size(ff));\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = 2*J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <pre><code>21-05-10 17:44:16 | NRG: start\n21-05-10 17:44:16 | #00/54 : NK=4/4, EK=0.08/0.08\n21-05-10 17:44:16 | #01/54 : NK=15/15, EK=3.231/3.231\n21-05-10 17:44:16 | #02/54 : NK=56/56, EK=6.468/6.468\n21-05-10 17:44:16 | #03/54 : NK=210/210, EK=13.1/13.1\n21-05-10 17:44:16 | #04/54 : NK=310/792, EK=9.834/22.35\n21-05-10 17:44:16 | #05/54 : NK=311/1170, EK=9.829/18.02\n21-05-10 17:44:16 | #06/54 : NK=302/1174, EK=9.77/17.36\n21-05-10 17:44:16 | #07/54 : NK=311/1134, EK=9.852/17.96\n21-05-10 17:44:16 | #08/54 : NK=322/1174, EK=9.953/17.44\n21-05-10 17:44:17 | #09/54 : NK=311/1210, EK=9.893/18.39\n21-05-10 17:44:17 | #10/54 : NK=322/1174, EK=10.07/17.57\n21-05-10 17:44:17 | #11/54 : NK=311/1210, EK=9.947/18.33\n21-05-10 17:44:17 | #12/54 : NK=322/1172, EK=10.25/17.87\n21-05-10 17:44:17 | #13/54 : NK=315/1210, EK=10.09/18.32\n21-05-10 17:44:17 | #14/54 : NK=312/1184, EK=10.36/18.18\n21-05-10 17:44:17 | #15/54 : NK=300/1170, EK=10.15/18.49\n21-05-10 17:44:17 | #16/54 : NK=309/1124, EK=10.74/18.46\n21-05-10 17:44:17 | #17/54 : NK=325/1158, EK=10.85/18.96\n21-05-10 17:44:18 | #18/54 : NK=322/1218, EK=11.36/19.57\n21-05-10 17:44:18 | #19/54 : NK=320/1204, EK=11.26/19.6\n21-05-10 17:44:18 | #20/54 : NK=311/1192, EK=11.7/20.71\n21-05-10 17:44:18 | #21/54 : NK=306/1160, EK=11.51/20.05\n21-05-10 17:44:18 | #22/54 : NK=310/1136, EK=12.01/21.29\n21-05-10 17:44:18 | #23/54 : NK=306/1151, EK=11.71/20.59\n21-05-10 17:44:18 | #24/54 : NK=307/1136, EK=11.96/21.69\n21-05-10 17:44:18 | #25/54 : NK=306/1139, EK=11.8/20.11\n21-05-10 17:44:18 | #26/54 : NK=307/1136, EK=11.97/21.86\n21-05-10 17:44:18 | #27/54 : NK=306/1139, EK=11.83/20.16\n21-05-10 17:44:19 | #28/54 : NK=309/1136, EK=12.2/21.93\n21-05-10 17:44:19 | #29/54 : NK=306/1147, EK=11.85/20.88\n21-05-10 17:44:19 | #30/54 : NK=309/1136, EK=12.21/21.95\n21-05-10 17:44:19 | #31/54 : NK=306/1147, EK=11.85/20.89\n21-05-10 17:44:19 | #32/54 : NK=309/1136, EK=12.21/21.96\n21-05-10 17:44:19 | #33/54 : NK=306/1147, EK=11.86/20.89\n21-05-10 17:44:19 | #34/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:19 | #35/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:19 | #36/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:19 | #37/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:20 | #38/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:20 | #39/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:20 | #40/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:20 | #41/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:20 | #42/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:20 | #43/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:20 | #44/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:20 | #45/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:20 | #46/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:20 | #47/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:21 | #48/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:21 | #49/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:21 | #50/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:21 | #51/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:21 | #52/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:21 | #53/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:21 | #54/54 : NK=0/1136, EK=0/21.97\n21-05-10 17:44:21 | Memory usage : 3.38GiB\nElapsed time: 5.517s, CPU time: 12.89s, Avg # of cores: 2.336\n</code></pre> <pre><code>beta0 = 1; % parameter to define temperature values\n[T,Tchi,Sent] = getTDconvQS(Inrg,beta0);\n</code></pre> <p>Perform the iterative diagonalization for the bath only. We replace the Kondo impurity with vacuum.</p> <pre><code>A0_2 = getIdentity(setItag(getvac(EF,1),'L00'),2,EF,2,'K00',[1 3 2]); \nH0_2 = 1e-33*contract(A0_2,'!2*',A0_2);\nInrg2 = NRG_IterDiagQS(H0_2,A0_2,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <pre><code>21-05-10 17:44:22 | NRG: start\n21-05-10 17:44:22 | #00/54 : NK=3/3, EK=1e-33/1e-33\n21-05-10 17:44:22 | #01/54 : NK=10/10, EK=3.203/3.203\n21-05-10 17:44:22 | #02/54 : NK=35/35, EK=6.15/6.15\n21-05-10 17:44:22 | #03/54 : NK=126/126, EK=13/13\n21-05-10 17:44:22 | #04/54 : NK=310/462, EK=12.48/21.9\n21-05-10 17:44:22 | #05/54 : NK=309/1154, EK=12.22/23.03\n21-05-10 17:44:22 | #06/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:22 | #07/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:22 | #08/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:22 | #09/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:22 | #10/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:22 | #11/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:23 | #12/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:23 | #13/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:23 | #14/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:23 | #15/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:23 | #16/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:23 | #17/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:23 | #18/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:23 | #19/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:23 | #20/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:23 | #21/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:24 | #22/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:24 | #23/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:24 | #24/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:24 | #25/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:24 | #26/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:24 | #27/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:24 | #28/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:24 | #29/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:24 | #30/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:25 | #31/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:25 | #32/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:25 | #33/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:25 | #34/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:25 | #35/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:25 | #36/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:25 | #37/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:25 | #38/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:25 | #39/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:26 | #40/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:26 | #41/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:26 | #42/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:26 | #43/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:26 | #44/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:26 | #45/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:26 | #46/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:26 | #47/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:26 | #48/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:27 | #49/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:27 | #50/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:27 | #51/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:27 | #52/54 : NK=306/1147, EK=11.86/20.9\n21-05-10 17:44:27 | #53/54 : NK=309/1136, EK=12.21/21.97\n21-05-10 17:44:27 | #54/54 : NK=0/1147, EK=0/20.9\n21-05-10 17:44:27 | Memory usage : 3.39GiB\nElapsed time: 5.586s, CPU time: 12.79s, Avg # of cores: 2.29\n</code></pre> <pre><code>[~,Tchi2,Sent2] = getTDconvQS(Inrg2,beta0);\n</code></pre> <p>Then subtract the thermodynamic properties from the bath only from those from the whole impurity model, to obtain the impurity contribution.</p> <pre><code>% impurity contribution to the spin susceptibility (* temperature)\nTchi_imp = Tchi - Tchi2; \n% impurity contribution to the entropy\nSent_imp = Sent - Sent2;\n\nlogT = log(T);\n% impurity contribution to the specific heat C = T* dS/dT = dS / d(log T)\nC_imp = interp1((logT(1:end-1)+logT(2:end))/2, ...\n    diff(Sent_imp)./diff(logT),logT,'linear','extrap');\n\n% Sommerfeld-Wilson ratio\nWR = (Tchi_imp./C_imp)*(4*(pi^2)/3);\n</code></pre> <p>To rescale the temperature, we compute the Kondo temperature \\(T_{{\\mathrm{K}}}\\) . Here we use the formula from the second-order poor man's scaling calculation.</p> <pre><code>% Kondo temperature\nTK = sqrt(J) * exp(-1/J); % half-bandwidth D = 1\ndisp(TK);\n</code></pre> <pre><code>   7.7218e-04\n</code></pre> <p>Plot the result.</p> <pre><code>figure;\nsemilogx(T/TK,(Tchi_imp./T)*(4*TK), ...\n    T/TK,Sent_imp/log(2), ...\n    T/TK,WR,'LineWidth',1);\nset(gca,'LineWidth',1,'FontSize',13);\nxlabel(' $T / T_\\mathrm{K}$ ','Interpreter','latex');\nlegend({' $4 T_\\mathrm{K} \\chi_\\mathrm{imp}$ '; ...\n    ' $S_\\mathrm{imp} / \\ln 2$ '; ...\n    ' $R$ '}, ...\n    'Interpreter','latex','Location','northwest');\nylim([0 3]);\nxlim([min(T) max(T)]/TK);\ngrid on;\n</code></pre> <p> </p> <p>The curves of \\(R(T)\\) and \\(\\chi_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} (T)\\) for the SIKM exhibit similar behavior as those for the SIAM. Compare this plot with the demonstration plot. The kinks of \\(R\\) at the highest and the lowest temperatures come from numerical artifact.</p> <p>On the other hand, the curve of \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} (T)\\) for the SIKM shows different features from that for the SIAM. \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} (T)\\) for the SIAM has had three plateaus that represent three regimes: (i) \\(\\ln 4\\) for the free orbital regime, (ii) \\(\\ln 2\\) for the local moment regime, and (iii) \\(0\\) for the strong coupling regime. \\(S_{{\\mathrm{i}\\mathrm{m}\\mathrm{p}}} (T)\\) for the SIKM has only two plateaus: (i) \\(\\ln 2\\) for the local moment regime and (ii) \\(0\\) for the strong coupling regime.</p> <p>The absence of the free orbital regime is natural. In the derivation of the SIKM out of the SIAM, the doubly-occupied and the empty states of the impurity are \"integrated out.\" As the result, the impurity of the SIKM has only spin degrees of freedom. That is, there is no free orbital regime at all for the SIKM.</p>"},{"location":"examples/NRG/NRG3_ImpSpec/","title":"NRG-3: Impurity Spectral Function","text":"<p>Author: Seung-Sup Lee</p> <p>Date: 20.06.2020  (Minor update: 30.06.2020)</p> <p>Here we will compute the thermal expectation value of impurity operators and the impurity spectral function, by using the full-density-matrix NRG (fdmNRG).</p> <p>Consider an operator, say \\({\\hat{O} }_d\\) , that acts on the impurity. Then the spectral function of the retarded-time correlation function of \\({\\hat{O} }_d\\) is given by:</p> \\[   A(\\omega )=\\frac{-1}{\\pi }{\\mathrm{I}\\mathrm{m}}\\int {\\mathrm{d}}t\\,\\,e^{i\\omega t} \\left(-i\\Theta (t)\\langle [{\\hat{O} }_d (t),{\\hat{O} }_d^{\\dagger} ]_{\\pm } \\rangle \\right),~~~~~~~~(1)  \\] <p>where the superscript \\(\\pm\\) of the commutator means the anti-commutator \\([\\,\\,,\\,\\,]_+\\) for fermionic \\({\\hat{O} }_d\\) and the commutator \\([\\,\\,,\\,\\,]_-\\) for bosonic \\({\\hat{O} }_d\\) . With the energy eigenstates \\(\\lbrace |\\alpha \\rangle {\\rbrace}\\) and their corresponding eigenvalues \\(\\lbrace E_{\\alpha } \\rbrace\\) , we write the Lehmann representation of the spectral function as</p> \\[   A(\\omega )=\\sum_{\\alpha \\beta } \\langle \\alpha |{\\hat{O} }_d |\\beta \\rangle \\left(\\langle \\beta |{\\hat{O} }_d^{\\dagger} \\,\\hat{\\rho} |\\alpha \\rangle \\pm \\langle \\beta |\\hat{\\rho} \\,{\\hat{O} }_d^{\\dagger} |\\alpha \\rangle \\right)\\,\\,\\delta ( \\omega -(E_{\\beta } -E_{\\alpha } )), \\] <p>where \\(\\hat{\\rho}\\) is the density matrix of the system at thermal equilbrium,</p> \\[  \\langle \\alpha |\\hat{\\rho} |\\beta \\rangle =\\delta_{\\,\\,\\,\\beta }^{\\alpha } \\frac{\\exp (-E_{\\beta } /T)}{Z},  \\] <p>and \\(Z=\\sum_{\\alpha } \\exp (-E_{\\alpha } /T)\\) is the partition function. In this tutorial, we will use \\(\\beta\\) as an index, not as the inverse temperature.</p> <p>As explained in the lecture, the discarded eigenstates in the iterative diagonalization consitute the complete basis of (approximate) energy eigenstates \\(\\lbrace |\\alpha ,e\\rangle_{\\ell }^D \\rbrace\\) . However, it is hard to compute the spectral weight associated with \\(|\\alpha ,e\\rangle_{\\ell }^D\\) and \\(|\\beta ,e^{\\prime } \\rangle_{\\ell^{\\prime } }^D\\) that are at different iterations. Thus we employ the NRG approximation to compute spectral functions:</p> \\[  A(\\omega )=\\sum_{\\ell } \\sum_{X,Y\\not= KK} \\sum_{\\alpha \\beta } A_{\\alpha \\beta }^{\\ell XY} \\,\\,\\delta \\left(\\omega -(E_{\\beta }^{\\ell Y} -E_{\\alpha }^{\\ell X} )\\right)\\,,  \\] \\[  A_{\\alpha \\beta}^{\\ell X Y}=\\left[B_{[\\ell ]\\,\\,\\,Y}^{~~\\,X}\\right]^\\alpha{ }_\\beta \\left( {\\left\\lbrack C_{[\\ell ]\\,\\,\\,X}^{~~\\,Y} \\rho_{[\\ell] X}^{~~\\,X} \\right\\rbrack }_{\\,\\,\\,\\alpha }^{\\beta } \\pm \\left[ \\rho_{[\\ell] Y}^{~~\\,Y} C_{[\\ell ]\\,\\,\\,X}^{~~\\,Y} \\right]^{\\beta}_{\\,\\,\\,\\alpha} \\right) \\] \\[  {\\left\\lbrack B_{[\\ell ]\\,\\,\\,Y}^{~~\\,X} \\right\\rbrack }_{\\,\\,\\,\\beta }^{\\alpha } =_{\\ell }^X \\langle \\alpha |{\\hat{O} }_d |\\beta \\rangle_{\\ell }^Y \\,,  \\] \\[  {\\left\\lbrack C_{[\\ell ]\\,\\,\\,X}^{~~\\,Y} \\right\\rbrack }_{\\,\\,\\,\\alpha }^{\\beta } =_{\\ell }^Y \\langle \\beta |{\\hat{O} }_d^{\\dagger} |\\alpha \\rangle_{\\ell }^X ={\\left({\\left\\lbrack B_{[\\ell ]\\,\\,\\,Y}^{~~\\,X} \\right\\rbrack }_{\\,\\,\\,\\beta }^{\\alpha } \\right)}^* \\,.  \\] <p>Here \\(\\ell\\) is the iteration index, and \\(X\\) and \\(Y\\) are either \\(K\\) (kept) or \\(D\\) (discarded). The case \\(X=Y=K\\) is not considered to avoid double-counting.</p> <p>The density matrix in the discarded space is given by the diagonal matrix,</p> \\[  [\\rho_{[\\ell ]\\,\\,D}^{~~\\,D} ]_{\\,\\,\\,\\beta }^{\\alpha }= \\sum_e{ }_{\\ell}^D\\langle\\alpha, e|\\hat{\\rho}| \\beta, e\\rangle_{\\ell}^D=\\delta_\\beta^\\alpha \\frac{d^{N-\\ell} \\exp \\left(-E_\\alpha^{\\ell D} / T\\right)}{Z} \\] <p>where \\(d\\) is the dimension of the local Hilbert space of each chain site, and \\(N\\) is the index of the last chain site. In the construction of the complete basis \\(\\lbrace |\\alpha ,e\\rangle_{\\ell }^D \\rbrace =\\lbrace |\\alpha \\rangle_{\\ell }^D \\otimes |\\sigma_{\\ell +1} \\rangle \\otimes |\\sigma_{\\ell +2} \\rangle \\otimes \\cdots \\otimes |\\sigma_N \\rangle \\rbrace\\) , the \"environmental states\" \\(|e \\rangle =|\\sigma_{\\ell +1} \\rangle \\otimes |\\sigma_{\\ell +2} \\rangle \\otimes \\cdots \\otimes |\\sigma_N \\rangle\\) does not contribute to the energy; they only introduce the degeneracy. So \\(d^{N-\\ell }\\) counts the degeneracy introduced by the environmental states.</p> <p>On the other hand, the density matrix in the kept space is given by tracing out the Hilbert spaces of later chain sites,</p> \\[  \\rho_{[\\ell]}{ }_K^K=\\sum_e{ }_{\\ell}^K\\langle\\alpha, e|\\hat{\\rho}| \\beta, e\\rangle_{\\ell}^K  \\] \\[  =\\sum_{m&gt;\\ell } \\sum_{\\vec{\\sigma} } \\sum_{\\alpha } \\langle \\sigma_{\\ell +1} |\\cdots \\langle \\sigma_m |\\alpha \\rangle_m^D \\,\\,\\,{\\left\\lbrack \\rho_{[m]\\,\\,D}^{~~\\,D} \\right\\rbrack }_{\\,\\,\\,\\alpha }^{\\alpha } \\,\\,\\,_m^D \\langle \\alpha |\\sigma_m \\rangle \\cdots |\\sigma_{\\ell +1} \\rangle .  \\] <p>And there are no off-diagonal blocks, i.e., \\(\\rho_{[\\ell ]\\,\\,X}^{~~\\,Y} =0\\) if \\(X\\not= Y\\) . The name of the method, \"full density matrix\", is given by the fact that the density matrices from the all iterations (i.e., all energy scales) are considered.</p> <p>The Lehmann representation above represents the discrete spectral data of the spectral function; the result is the collection of the Dirac delta functions, rather than continuous curves. This discreteness originates from the logarithimic discretization of the originally continuous system. To return to the original continuity, we need to broaden the discrete data to obtain the continuous curves. For this, we use the broadening kernel that is the convolution of the symmetric logarithmic Gaussian (for broadening for high frequencies) and the derivative of the Fermi-Dirac distribution function (for broadening for low frequencies), as developed in [S.-S. B. Lee and A. Weichselbaum, Phys. Rev. B 94, 235127 (2016) or its arXiv version].</p> <p>Please review the following newly added functions:</p> <ul> <li>getRhoFDMQS.m: It is zipped together with this document. This function is designed to construct the density matrices \\(\\rho_{[\\ell ]\\,\\,D}^{~~\\,D}\\) and \\(\\rho_{[\\ell ]\\,\\,K}^{~~\\,K}\\) . This function should be completed, as Exercise 1. See below for details. </li> <li>getAdiscQS.m: It is zipped together with this document. This function computes the Lehmann representation of the spectral function. Its second input corresponds to \\({\\hat{O} }_d\\) above. The first output odisc is the frequency grid, and the second output Adisc is the histogram of the spectral weights \\(A_{\\alpha \\beta }^{\\ell XY}\\) according to the frequency grid. That is, the value of Adisc(n) is the sum of all the spectral weights \\(A_{\\alpha \\beta }^{\\ell XY}\\) whose corresponding frequency values \\(E_{\\beta }^{\\ell Y} -E_{\\alpha }^{\\ell X}\\) are close to the frequency bin value odisc(n). This function should be completed, as Exercise 2. See below for details. </li> <li>NRG/getAcont.m: Broaden the discrete data to obtain continuous curves. In this tutorial, we will not discuss the detail of the function. So take this function as granted. Interested readers may refer to [S.-S. B. Lee and A. Weichselbaum, Phys. Rev. B 94, 235127 (2016) or its arXiv version] for details. (Yes, it's a shameless self-advertisement...) </li> </ul>"},{"location":"examples/NRG/NRG3_ImpSpec/#iterative-diagonalization","title":"Iterative diagonalization","text":"<p>First, run the iterative diagonalization for the SIAM. Here we use the same parameters as those used in the last tutorial.</p> <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n</code></pre> <p>Note that we don't need to post-process the Wilson chain parameters as we did for the tutorial T11a, since the calculations in this tutorial are stable against the (very) small numerical noise that mattered in T11a.</p> <pre><code>% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <pre><code>21-05-11 17:03:32 | NRG: start\n21-05-11 17:03:32 | #00/55 : NK=3/3, EK=1e-33/1e-33\n21-05-11 17:03:32 | #01/55 : NK=10/10, EK=0.04894/0.04894\n21-05-11 17:03:32 | #02/55 : NK=35/35, EK=3.209/3.209\n21-05-11 17:03:32 | #03/55 : NK=126/126, EK=6.225/6.225\n21-05-11 17:03:32 | #04/55 : NK=310/462, EK=7.499/13.02\n21-05-11 17:03:32 | #05/55 : NK=310/1154, EK=7.033/13.08\n21-05-11 17:03:32 | #06/55 : NK=318/1150, EK=7.243/13.62\n21-05-11 17:03:32 | #07/55 : NK=310/1178, EK=7.047/13.09\n21-05-11 17:03:33 | #08/55 : NK=318/1150, EK=7.248/13.61\n21-05-11 17:03:33 | #09/55 : NK=310/1178, EK=7.073/13.13\n21-05-11 17:03:33 | #10/55 : NK=318/1150, EK=7.274/13.59\n21-05-11 17:03:33 | #11/55 : NK=310/1178, EK=7.117/13.19\n21-05-11 17:03:33 | #12/55 : NK=318/1150, EK=7.359/13.59\n21-05-11 17:03:33 | #13/55 : NK=310/1178, EK=7.207/13.33\n21-05-11 17:03:33 | #14/55 : NK=322/1150, EK=7.688/13.9\n21-05-11 17:03:34 | #15/55 : NK=312/1192, EK=7.46/13.82\n21-05-11 17:03:34 | #16/55 : NK=327/1166, EK=8.385/14.7\n21-05-11 17:03:34 | #17/55 : NK=304/1218, EK=8.45/14.98\n21-05-11 17:03:34 | #18/55 : NK=307/1136, EK=9.027/16.05\n21-05-11 17:03:34 | #19/55 : NK=312/1148, EK=9.33/16.02\n21-05-11 17:03:34 | #20/55 : NK=311/1170, EK=9.719/17.5\n21-05-11 17:03:34 | #21/55 : NK=327/1174, EK=9.804/17.18\n21-05-11 17:03:34 | #22/55 : NK=311/1231, EK=9.781/18.26\n21-05-11 17:03:35 | #23/55 : NK=302/1174, EK=9.751/17.32\n21-05-11 17:03:35 | #24/55 : NK=311/1134, EK=9.836/17.88\n21-05-11 17:03:35 | #25/55 : NK=322/1174, EK=9.979/17.46\n21-05-11 17:03:35 | #26/55 : NK=311/1210, EK=9.916/18.36\n21-05-11 17:03:35 | #27/55 : NK=322/1174, EK=10.13/17.64\n21-05-11 17:03:35 | #28/55 : NK=325/1210, EK=10.18/18.32\n21-05-11 17:03:35 | #29/55 : NK=322/1224, EK=10.34/18.23\n21-05-11 17:03:36 | #30/55 : NK=315/1210, EK=10.19/18.35\n21-05-11 17:03:36 | #31/55 : NK=322/1184, EK=10.65/18.36\n21-05-11 17:03:36 | #32/55 : NK=303/1210, EK=10.33/18.76\n21-05-11 17:03:36 | #33/55 : NK=300/1136, EK=10.79/18.81\n21-05-11 17:03:36 | #34/55 : NK=318/1122, EK=10.94/18.84\n21-05-11 17:03:36 | #35/55 : NK=300/1190, EK=11.33/19.89\n21-05-11 17:03:36 | #36/55 : NK=301/1119, EK=11.16/19.39\n21-05-11 17:03:36 | #37/55 : NK=316/1118, EK=11.94/20.4\n21-05-11 17:03:37 | #38/55 : NK=306/1175, EK=11.61/20.4\n21-05-11 17:03:37 | #39/55 : NK=310/1136, EK=12.08/21.49\n21-05-11 17:03:37 | #40/55 : NK=306/1151, EK=11.76/20.7\n21-05-11 17:03:37 | #41/55 : NK=307/1136, EK=11.97/21.78\n21-05-11 17:03:37 | #42/55 : NK=306/1139, EK=11.82/20.14\n21-05-11 17:03:37 | #43/55 : NK=309/1136, EK=12.2/21.9\n21-05-11 17:03:37 | #44/55 : NK=306/1147, EK=11.85/20.88\n21-05-11 17:03:38 | #45/55 : NK=309/1136, EK=12.21/21.95\n21-05-11 17:03:38 | #46/55 : NK=306/1147, EK=11.86/20.9\n21-05-11 17:03:38 | #47/55 : NK=309/1136, EK=12.22/21.97\n21-05-11 17:03:38 | #48/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:03:38 | #49/55 : NK=309/1136, EK=12.22/21.98\n21-05-11 17:03:38 | #50/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:03:38 | #51/55 : NK=309/1136, EK=12.22/21.98\n21-05-11 17:03:38 | #52/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:03:39 | #53/55 : NK=309/1136, EK=12.22/21.98\n21-05-11 17:03:39 | #54/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:03:39 | #55/55 : NK=0/1136, EK=0/21.98\n21-05-11 17:03:39 | Memory usage : 1.98GiB\nElapsed time: 7.017s, CPU time: 14.64s, Avg # of cores: 2.086\n</code></pre> <p>Plot the energy flow diagram.</p> <pre><code>% Energy flow diagram\nEshow = 3; % energy window to show (from 0 to Eshow)\n\n% determine energy levels, corresponding quantum numbers and degeneracies\n\nEs = cell(numel(Inrg.HK),1); % energies\nQs = cell(numel(Inrg.HK),1); % corresponding quantum numbers\n\nfor itN = 1:numel(Es)\n    if itN &lt; N\n        HN = Inrg.HK{itN}; % kept Hamiltonian at itN\n    else\n        HN = Inrg.HD{itN}; % only discarded states at the last iteration\n    end\n\n    if itN == 1 % impurity is not diagonalized in NRG_IterDiagQS\n        [~,I] = eigQS(HN);\n        HN = QSpace(I.EK);\n    end\n\n    for itq = 1:size(HN.Q{1},1)\n        Qs{itN}(itq,:) = HN.Q{1}(itq,:);\n        Es{itN}{itq,1} = sort((HN.data{itq}(HN.data{itq} &lt;= Eshow))','ascend');\n    end\nend\n\n% get maximum number of energy levels per symmetry sector\nnEmax = 0;\nfor iti = 1:numel(Es)\n    nEmax = max([nEmax;cellfun('prodofsize',Es{iti}(:))]);\nend\n\nQuniq = unique(cell2mat(Qs),'rows'); % unique sets of quantum numbers\nEs2 = cell(size(Quniq,1),1); % each Es2{n} is the collection of curves for each quantum number set Quniq(n,:)\nEeven = cell(size(Quniq,1),1); % even iterations\nEodd = cell(size(Quniq,1),1); % even iterations\n\nfor itq = (1:size(Quniq,1))\n    Es2{itq} = nan(numel(Es)+1,nEmax);\n\n    for iti = 1:numel(Es)\n        okq = ismember(Qs{iti},Quniq(itq,:),'rows');\n\n        if any(okq)\n            Etmp = Es{iti}{okq};\n            Es2{itq}(iti,(1:numel(Etmp))) = Etmp(:).';\n        end\n    end\n\n    Es2{itq}(:,(find(~all(isnan(Es2{itq}),1),1,'last')+1:end)) = [];\n\n    Eeven{itq} = Es2{itq}(1:2:end,:); % impurity is 0, i.e. even\n    Eodd{itq} = Es2{itq}(2:2:end,:);\n\nend\n\n% shorten Eeven and Eodd such that only a single row of NaN's remains\nNeven = 0; Nodd = 0;\nfor itq = 1:numel(Eeven)\n    Neven = max([Neven,find(~all(isnan(Eeven{itq}),2),1,'last')+1]); \n    Nodd = max([Nodd,find(~all(isnan(Eodd{itq}),2),1,'last')+1]);\nend\nfor itq = 1:numel(Eeven)\n\n    if size(Eeven{itq},1) &gt;= Neven\n        Eeven{itq} = Eeven{itq}(1:Neven,:);\n    else\n        Eeven{itq}(end+1,:) = nan;\n    end\n\n    if size(Eodd{itq},1) &gt;= Nodd\n        Eodd{itq} = Eodd{itq}(1:Nodd,:);\n    else\n        Eodd{itq}(end+1,:) = nan;\n    end\n\nend\n\n% quantum numbers for even and odd iterations\nQeven = Quniq;\nQodd = Quniq;\n\n% delete all NaN sectors\niQeven = cellfun(@(x) all(isnan(x(:))),Eeven);\nEeven = Eeven(~iQeven);\nQeven = Qeven(~iQeven,:);\n\niQodd = cellfun(@(x) all(isnan(x(:))),Eodd);\nEodd = Eodd(~iQodd);\nQodd = Qodd(~iQodd,:);\n\n% sort by lowest energy at last iteration\n[~,sid] = sort(cellfun(@(x) min(x(end-1,:)), Eeven),'ascend'); % for 'min' and 'sort', NaN is considered to be the largest\nQeven = Qeven(sid,:);\nEeven = Eeven(sid);\n\n[~,sid] = sort(cellfun(@(x) min(x(end-1,:)), Eodd),'ascend'); % for 'min' and 'sort', NaN is considered to be the largest\nQodd = Qodd(sid,:);\nEodd = Eodd(sid);\n\n% colors:\nclrs = [228,26,28;...\n    55,126,184;...\n    77,175,74;...\n    152,78,163;...\n    255,127,0]/256; % colors for lowest few energy levels\n                    % size(clrs,1) determines number of colored levels\n% default line color: gray\nclrs0 = [1 1 1]*0.7;\n\n% plot flow diagram:\nfigure;\n% upper panel\nsubplot(2,1,1);\nhold on;\nfor itq = (size(clrs,1)+1):size(Qeven,1) % first gray lines\n    plot(2*((1:size(Eeven{itq},1))-1),Eeven{itq},'LineWidth',1,'Color',clrs0);\nend\nhs = cell(1,size(clrs,1)); % lines\nleg = cell(1,size(clrs,1)); % legend\nfor itq = 1:size(clrs,1) % first gray lines\n    hs{itq} = plot(2*((1:size(Eeven{itq},1))-1),Eeven{itq},'LineWidth',1,'Color',clrs(itq,:));\n    leg{itq} = ['(',...\n        sprintf([repmat(['%i '],[1,size(Qeven(itq,:),2)-1]),'%i'],Qeven(itq,:))...\n        ,')'];\nend\nhs2 = [];\nfor it1 = (1:numel(hs)) % for legend\n    hs2(it1) = hs{it1}(1);\nend\nlegend(hs2,leg);\nxlabel('Even iterations');\nxlim([0 numel(Inrg.HK)-1]);\nylim([0, Eshow]);\nset(gca,'LineWidth',1,'FontSize',13);\nhold off;\n\n% lower panel\nsubplot(2,1,2);\nhold on;\nfor itq = (size(clrs,1)+1):size(Qodd,1) % first gray lines\n    plot(2*(1:size(Eodd{itq},1))-1,Eodd{itq},'LineWidth',1,'Color',clrs0);\nend\nhs = cell(1,size(clrs,1)); % lines\nleg = cell(1,size(clrs,1)); % legend\nfor itq = 1:size(clrs,1) % first gray lines\n    hs{itq} = plot(2*(1:size(Eodd{itq},1))-1,Eodd{itq},'LineWidth',1,'Color',clrs(itq,:));\n    leg{itq} = ['(',...\n        sprintf([repmat(['%i '],[1,size(Qodd(itq,:),2)-1]),'%i'],Qodd(itq,:))...\n        ,')'];\nend\nhs2 = [];\nfor it1 = (1:numel(hs)) % for legend\n    hs2(it1) = hs{it1}(1);\nend\nlegend(hs2,leg);\nxlabel('Odd iterations');\nxlim([0 numel(Inrg.HK)-1]);\nylim([0, Eshow]);\nset(gca,'LineWidth',1,'FontSize',13);\nhold off;\n</code></pre> <p> </p> <p>Below is the demonstration in which the completed function is used. In the next section (\"Double occupation vs. temperature\"), the reduced density matrix at the impurity, which is the part of the output (Inrg.RK{1}) of the function getRhoFDMQS.m, is computed and displayed for different temperatures.</p>"},{"location":"examples/NRG/NRG3_ImpSpec/#double-occupation-vs-temperature","title":"Double occupation vs. temperature","text":"<p>Let's compute the double occupation \\(\\langle {\\hat{n} }_{d\\uparrow } {\\hat{n} }_{d\\downarrow } \\rangle\\) at the impurity, where \\({\\hat{n} }_{d\\sigma }\\) is the number operator for spin- \\(\\sigma\\) electron at the impurity site. We obtain the reduced density matrix within the Hilbert space of the impurity (to be obtained as Inrg.RK{1}), where the bath sites are all traced out.</p> <pre><code>Dop = getsub(EF,[1 0],1); % operator measuring for double occupation\n% represent in kept basis at the impurity\nDop = contract(Inrg.AK{1},'!2*',{Dop,Inrg.AK{1}});\n\nT = 10.^(1:-1:-7); % temperature values\nDval = zeros(size(T)); % expectation value of Dop\n\nfor itT = (1:numel(T))\n    Inrg = getRhoFDMQS(Inrg,T(itT)); % construct FDM\n    % display the reduced density matrix at the impurity\n    Inrg.RK{1}\n    % contract the reduced density matrix at the impurity \n    % with the operator\n    Dval(itT) = trace(contract(Inrg.RK{1},Dop));\nend\n</code></pre> <pre><code>21-05-11 17:03:41 | Construct full density matrix @ T = 10 ...\nElapsed time: 2.374s, CPU time: 5.44s, Avg # of cores: 2.291\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]        0.25\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]        0.25  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]        0.25\n21-05-11 17:03:43 | Construct full density matrix @ T = 1 ...\nElapsed time: 2.408s, CPU time: 5.42s, Avg # of cores: 2.25\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]      0.2497\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.2503  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]      0.2497\n21-05-11 17:03:46 | Construct full density matrix @ T = 0.1 ...\nElapsed time: 2.406s, CPU time: 5.41s, Avg # of cores: 2.249\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]       0.247\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]       0.253  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]       0.247\n21-05-11 17:03:48 | Construct full density matrix @ T = 0.01 ...\nElapsed time: 2.194s, CPU time: 5.11s, Avg # of cores: 2.329\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]      0.2251\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.2749  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]      0.2251\n21-05-11 17:03:51 | Construct full density matrix @ T = 0.001 ...\nElapsed time: 2.169s, CPU time: 5.02s, Avg # of cores: 2.315\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]     0.09058\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.4094  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]     0.09058\n21-05-11 17:03:53 | Construct full density matrix @ T = 0.0001 ...\nElapsed time: 2.432s, CPU time: 5.51s, Avg # of cores: 2.265\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]     0.04448\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.4555  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]     0.04448\n21-05-11 17:03:55 | Construct full density matrix @ T = 1e-05 ...\nElapsed time: 2.061s, CPU time: 4.91s, Avg # of cores: 2.382\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]     0.04577\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.4542  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]     0.04577\n21-05-11 17:03:57 | Construct full density matrix @ T = 1e-06 ...\nElapsed time: 2.04s, CPU time: 4.79s, Avg # of cores: 2.348\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]     0.04655\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.4534  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]     0.04655\n21-05-11 17:03:59 | Construct full density matrix @ T = 1e-07 ...\nElapsed time: 2.081s, CPU time: 4.84s, Avg # of cores: 2.326\nans = \n     Q:  3x [2 2]  having 'A,SU2',   { K00, K00* }\n  data:  2-D double (336 bytes)      3 x 3 =&gt; 4 x 4\n1.  1x1        | 1x1        [ -1 0 ; -1 0 ]     0.04676\n     2.  1x1        | 2x2        [  0 1 ;  0 1 ]      0.4532  {1.414}\n     3.  1x1        | 1x1        [  1 0 ;  1 0 ]     0.04676\n</code></pre> <p>Plot the double occupation vs. temperature.</p> <pre><code>figure;\nsemilogx(T/U,Dval,'Marker','x','LineWidth',1);\nset(gca,'FontSize',13,'LineWidth',1);\nxlabel(' $T/U$ ','Interpreter','latex');\nylabel(' $\\langle \\hat{n}_{d \\uparrow} \\hat{n}_{d \\downarrow} \\rangle$ ', ...\n    'Interpreter','latex');\ngrid on;\n</code></pre> <p> </p> <p>We see that the double occupation \\(\\langle {\\hat{n} }_{d\\uparrow } {\\hat{n} }_{d\\downarrow } \\rangle\\) decreases with decreasing \\(T\\) with a crossover around \\(T\\sim U\\) . On the other hand, the double occupation saturates in the low-temperature regime \\(T\\ll U\\) : it means that the charge fluctuation is \"frozen\" by low temperature.</p> <p>To compute spectral function, getAdiscQS.m will be used.</p>"},{"location":"examples/NRG/NRG3_ImpSpec/#impurity-spectral-function-discrete-data","title":"Impurity spectral function: discrete data","text":"<p>We compute the spectral function \\(A_{ds} (\\omega )\\equiv (-1/\\pi ){\\mathrm{I}\\mathrm{m}}\\,G_{ds} (\\omega )\\) , where \\(G_{ds} (\\omega )\\) is the Green's function of spin- \\(s\\) electron at the impurity. That is, \\(A_{ds} (\\omega )\\) is obtained by substituting \\({\\hat{O} }_d ={\\hat{d} }_s\\) to the above Eq. (1).</p> <p>Choose the system temperature, and construct the density matrices in the kept and discarded spaces for every iteration.</p> <pre><code>T = 1e-8;\nInrg = getRhoFDMQS(Inrg,T); % construct full density matrix\n</code></pre> <pre><code>21-05-11 17:04:02 | Construct full density matrix @ T = 1e-08 ...\nElapsed time: 2.044s, CPU time: 4.76s, Avg # of cores: 2.328\n</code></pre> <p>Then compute the discrete spectal data for the impurity spectral function. </p> <pre><code>% discrete spectral function of spin-up electron at the impurity\n[odisc,Adisc] = getAdiscQS(Inrg,F(1),Z);\n</code></pre> <pre><code>21-05-11 17:04:04 | Correlation function for anti-commuting op.\n21-05-11 17:04:04 | #01/55 : sum(Adisc) = 0\n21-05-11 17:04:04 | #02/55 : sum(Adisc) = 0\n21-05-11 17:04:04 | #03/55 : sum(Adisc) = 0\n21-05-11 17:04:04 | #04/55 : sum(Adisc) = 9.292e-11\n21-05-11 17:04:04 | #05/55 : sum(Adisc) = 1.266e-07\n21-05-11 17:04:05 | #06/55 : sum(Adisc) = 1.202e-05\n21-05-11 17:04:05 | #07/55 : sum(Adisc) = 0.0004482\n21-05-11 17:04:05 | #08/55 : sum(Adisc) = 0.0004776\n21-05-11 17:04:05 | #09/55 : sum(Adisc) = 0.001568\n21-05-11 17:04:06 | #10/55 : sum(Adisc) = 0.001638\n21-05-11 17:04:06 | #11/55 : sum(Adisc) = 0.004369\n21-05-11 17:04:06 | #12/55 : sum(Adisc) = 0.004524\n21-05-11 17:04:06 | #13/55 : sum(Adisc) = 0.01142\n21-05-11 17:04:07 | #14/55 : sum(Adisc) = 0.0117\n21-05-11 17:04:07 | #15/55 : sum(Adisc) = 0.02998\n21-05-11 17:04:07 | #16/55 : sum(Adisc) = 0.03072\n21-05-11 17:04:07 | #17/55 : sum(Adisc) = 0.09208\n21-05-11 17:04:08 | #18/55 : sum(Adisc) = 0.1012\n21-05-11 17:04:08 | #19/55 : sum(Adisc) = 0.5312\n21-05-11 17:04:08 | #20/55 : sum(Adisc) = 1.461\n21-05-11 17:04:08 | #21/55 : sum(Adisc) = 1.545\n21-05-11 17:04:09 | #22/55 : sum(Adisc) = 1.756\n21-05-11 17:04:09 | #23/55 : sum(Adisc) = 1.801\n21-05-11 17:04:09 | #24/55 : sum(Adisc) = 1.865\n21-05-11 17:04:10 | #25/55 : sum(Adisc) = 1.895\n21-05-11 17:04:10 | #26/55 : sum(Adisc) = 1.921\n21-05-11 17:04:10 | #27/55 : sum(Adisc) = 1.941\n21-05-11 17:04:10 | #28/55 : sum(Adisc) = 1.952\n21-05-11 17:04:11 | #29/55 : sum(Adisc) = 1.965\n21-05-11 17:04:11 | #30/55 : sum(Adisc) = 1.97\n21-05-11 17:04:11 | #31/55 : sum(Adisc) = 1.979\n21-05-11 17:04:12 | #32/55 : sum(Adisc) = 1.981\n21-05-11 17:04:12 | #33/55 : sum(Adisc) = 1.988\n21-05-11 17:04:12 | #34/55 : sum(Adisc) = 1.989\n21-05-11 17:04:13 | #35/55 : sum(Adisc) = 1.994\n21-05-11 17:04:13 | #36/55 : sum(Adisc) = 1.994\n21-05-11 17:04:14 | #37/55 : sum(Adisc) = 1.997\n21-05-11 17:04:14 | #38/55 : sum(Adisc) = 1.997\n21-05-11 17:04:14 | #39/55 : sum(Adisc) = 1.999\n21-05-11 17:04:15 | #40/55 : sum(Adisc) = 1.999\n21-05-11 17:04:15 | #41/55 : sum(Adisc) = 1.999\n21-05-11 17:04:15 | #42/55 : sum(Adisc) = 2\n21-05-11 17:04:16 | #43/55 : sum(Adisc) = 2\n21-05-11 17:04:16 | #44/55 : sum(Adisc) = 2\n21-05-11 17:04:16 | #45/55 : sum(Adisc) = 2\n21-05-11 17:04:17 | #46/55 : sum(Adisc) = 2\n21-05-11 17:04:17 | #47/55 : sum(Adisc) = 2\n21-05-11 17:04:18 | #48/55 : sum(Adisc) = 2\n21-05-11 17:04:18 | #49/55 : sum(Adisc) = 2\n21-05-11 17:04:18 | #50/55 : sum(Adisc) = 2\n21-05-11 17:04:19 | #51/55 : sum(Adisc) = 2\n21-05-11 17:04:19 | #52/55 : sum(Adisc) = 2\n21-05-11 17:04:19 | #53/55 : sum(Adisc) = 2\n21-05-11 17:04:20 | #54/55 : sum(Adisc) = 2\n21-05-11 17:04:20 | #55/55 : sum(Adisc) = 2\nElapsed time: 15.71s, CPU time: 26.18s, Avg # of cores: 1.667\n21-05-11 17:04:20 | Memory usage : 2.01GiB\n</code></pre> <p>Note that sum(Adisc) means the sum of the discrete spectral weights. The sum of the spectral weights is given by</p> \\[  \\sum_{\\ell } \\sum_{X,Y\\not= KK} \\sum_{\\alpha \\beta } A_{\\alpha \\beta }^{\\ell XY}  \\] \\[  ={\\mathrm{T}\\mathrm{r}}\\left({\\hat{O} }_d {\\hat{O} }_d^{\\dagger} \\hat{\\rho} \\pm {\\hat{O} }_d \\hat{\\rho} {\\hat{O} }_d^{\\dagger} \\right)={\\mathrm{T}\\mathrm{r}}\\left([{\\hat{O} }_d ,{\\hat{O} }_d^{\\dagger} ]_{\\pm } \\hat{\\rho} \\right).  \\] <p>Here we have used the completeness of the basis \\(\\lbrace |\\alpha ,e\\rangle_{\\ell_0 }^D \\rbrace \\cup \\lbrace |\\alpha ,e\\rangle_{\\ell_0 +1}^D \\rbrace \\cup \\cdots \\lbrace |\\alpha ,e\\rangle_{\\ell }^D \\rbrace \\cup \\lbrace |\\alpha ,e\\rangle_{\\ell }^K \\rbrace\\) , where \\(\\ell_0\\) is the first iteration at which the truncation of the Hilbert space happened. Since the standard anti-commutation relation gives \\([{\\hat{d} }_s ,{\\hat{d} }_s^{\\dagger} ]_+ =1\\) , sum(Adisc) should be 1. The getAdiscQS result satisfies this \"spectral sum rule\" up to double precision.  Indeed, this sum-preserving property is one of the key merits of fdmNRG; see the title of [A. Weichselbaum and J. von Delft, Phys. Rev. Lett. 99, 076402 (2007)]. Note that in case of SU(2) spin rotation symmetry, we compute \\(A_{\\uparrow } (\\omega )+A_{\\downarrow } (\\omega )\\) . Therefore, sum(Adisc) is 2 in this case. </p> <p>We use a technique called \"rerouting Z-string\" in getAdiscQS.m. With this, we don't need to contract Z operator, i.e., fermionic sign operator, at every iteration. It is enough to contract the Z operator only at the first iteration! For the detail of the rerouting technique, see the Appendix of [A. Weichselbaum, Phys. Rev. B 86, 245124 (2012)] or its arXiv version.</p>"},{"location":"examples/NRG/NRG3_ImpSpec/#impurity-spectral-function-continuous-curve","title":"Impurity spectral function: continuous curve","text":"<p>The results odisc and Adisc represent the collection of discrete spectral weights given by the Lehmann representation. To obtain a smooth curve, we need to broaden them.</p> <pre><code>% broaden the discrete data to have a continuous curve\n[ocont,Acont] = getAcont(odisc,Adisc,log(Lambda),T/5);\nif strcmp(symstr,'Acharge,SU2spin')\n    Acont = Acont/2; % sum of spectral function for both spins is calculated\nend\n</code></pre> <p>Compute the Kondo temperature \\(T_{{\\mathrm{K}}}\\) to rescale frequencies.</p> <pre><code>% Kondo temperature from the Bethe ansatz\nTK = sqrt(U*Gamma/2)*exp(-pi*U/8/Gamma + pi*Gamma/2/U);\ndisp(TK); % Kondo temperature\n</code></pre> <pre><code>1.5106e-06\n</code></pre> <pre><code>figure;\nhold on;\n% positive frequency\nplot(ocont(ocont&gt;0)/TK,Acont(ocont&gt;0)*(pi*Gamma), ...\n    'LineWidth',1,'LineStyle','-');\n% negative frequency\nplot(-ocont(ocont&lt;0)/TK,Acont(ocont&lt;0)*(pi*Gamma), ...\n    'LineWidth',1,'LineStyle','--');\nplot(U/2/TK*[1 1],[0 1],'LineWidth',1,'LineStyle','-.', ...\n    'Color',[1 1 1]*0.5);\ntext(U/TK,0.3,' !!!EQ_80!!! ','FontSize',13, ...\n    'Interpreter','latex','HorizontalAlignment','left');\nhold off;\nset(gca,'FontSize',13,'LineWidth',1,'XScale','log');\nlegend({' !!!EQ_81!!! ', ...\n    ' !!!EQ_82!!! '},'Interpreter','latex');\nxlabel(' !!!EQ_83!!! ','Interpreter','latex');\nylabel(' !!!EQ_84!!! ','Interpreter','latex');\nylim([0 1.01]);\nxlim([1e-6 1e6]);\ngrid on;\n</code></pre> <p> </p> <p>We observe several important features.</p> <ol> <li>As the spin symmetry is not broken (due to the absence of magnetic field) and the particle-hole symmetry is preserved, blue and red curves for positive and negative frequencies, respectively, lie top of each other.</li> <li>There are side peaks at \\(\\omega =\\pm U/2\\) , as marked by vertical dash-dotted line. They come from local excitations from singly occupied states to the double occupied state for the peak at \\(\\omega =U/2\\) (to the empty state for the peak at \\(\\omega =-U/2\\) ).</li> <li>The full-width-half-maximum of the \"Kondo peak\" (peak centered at \\(\\omega =0\\) ) is roughly \\(T_{{\\mathrm{K}}}\\) .</li> <li>There is a plateau for \\(|\\omega |\\ll T_{{\\mathrm{K}}}\\) which corresponds to the top of the Kondo peak. The height of the Kondo peak satisfies the Friedel sum rule, \\(\\pi \\Gamma A_{d\\uparrow } (\\omega =0)=1\\) , up to a few percent error. Note that the Friedel sum rule is the exact relation holds at \\(T=0\\) .</li> </ol> <p>The quality of the curve (e.g., frequency resolution) can be improved by using so-called \\(z\\) -averaging, that is, by mixing the NRG results with the logarithmic discretization grid relatively shifted with respect to each other.</p> <p>Also, the accuracy with respect to the Friedel sum rule can be further improved by using more advanced logarithmic discretization schemes (see e.g., [R. Zitko and Th. Pruschke, Phys. Rev. B 79, 085106 (2009)]) and by using the \"self-energy trick\" (see [R. Bulla, A. C. Hewson, and Th. Pruschke, J. Phys.: Condens. Matter 10, 8365 (1998)]).</p>"},{"location":"examples/NRG/NRG3_ImpSpec/#dynamical-impurity-spin-susceptibility","title":"Dynamical impurity spin susceptibility","text":"<p>Some experimental probes such as neutron scattering can resolve the frequency dependence of the spin susceptibility. The frequency dependence encodes interesting information of the system.</p> <p>We will consider the dynamical impurity spin susceptibility, which depends on frequency \\(\\omega\\) . It is the retarded-time correlation function of spin operators \\({\\hat{S} }_{d,z}\\) . That is, the imaginary part of the dynamical impurity spin susceptibility, say \\(\\chi_s^{\\prime \\prime } (\\omega )\\) , is obtained by substituting \\({\\hat{O} }_d ={\\hat{S} }_{d,z}\\) to the above Eq. (1).</p> <p>Exercise: Compute \\(\\chi_s^{\\prime \\prime } (\\omega )\\) for the SIAM with the same choice of parameters as in the above demonstration of the impurity spectral function. How does the curve \\(\\chi_s^{\\prime \\prime } (\\omega )\\) look like? Can you interpret the location of the peak of the curve \\(\\chi_s^{\\prime \\prime } (\\omega )\\) ?</p> <p>(Hint 1: Use getAdiscQS_Ex by setting the third input Z as [] (empty).)</p> <p>(Hint 2: \\(\\chi_s^{\\prime \\prime } (\\omega )\\) is an odd function, having peaks as \\(\\omega \\simeq \\pm T_{{\\mathrm{K}}}\\) . Refer to Fig. 1 of [M. Hanl and A. Weichselbaum, Phys. Rev. B 89, 075130 (2014)] for the shape of \\(\\chi_s^{\\prime \\prime } (\\omega )\\) for \\(\\omega &gt;0\\) .)</p> <p>Solution to exercise: </p> <p>Perform the iterative diagonalization calculation, with the same parameters chosen in the demonstration of the tutorial.</p> <pre><code>clear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n</code></pre> <pre><code>21-05-11 17:09:20 | NRG: start\n21-05-11 17:09:20 | #00/55 : NK=3/3, EK=1e-33/1e-33\n21-05-11 17:09:20 | #01/55 : NK=10/10, EK=0.04894/0.04894\n21-05-11 17:09:20 | #02/55 : NK=35/35, EK=3.209/3.209\n21-05-11 17:09:20 | #03/55 : NK=126/126, EK=6.225/6.225\n21-05-11 17:09:20 | #04/55 : NK=310/462, EK=7.499/13.02\n21-05-11 17:09:20 | #05/55 : NK=310/1154, EK=7.033/13.08\n21-05-11 17:09:20 | #06/55 : NK=318/1150, EK=7.243/13.62\n21-05-11 17:09:20 | #07/55 : NK=310/1178, EK=7.047/13.09\n21-05-11 17:09:21 | #08/55 : NK=318/1150, EK=7.248/13.61\n21-05-11 17:09:21 | #09/55 : NK=310/1178, EK=7.073/13.13\n21-05-11 17:09:21 | #10/55 : NK=318/1150, EK=7.274/13.59\n21-05-11 17:09:21 | #11/55 : NK=310/1178, EK=7.117/13.19\n21-05-11 17:09:21 | #12/55 : NK=318/1150, EK=7.359/13.59\n21-05-11 17:09:21 | #13/55 : NK=310/1178, EK=7.207/13.33\n21-05-11 17:09:21 | #14/55 : NK=322/1150, EK=7.688/13.9\n21-05-11 17:09:21 | #15/55 : NK=312/1192, EK=7.46/13.82\n21-05-11 17:09:21 | #16/55 : NK=327/1166, EK=8.385/14.7\n21-05-11 17:09:22 | #17/55 : NK=304/1218, EK=8.45/14.98\n21-05-11 17:09:22 | #18/55 : NK=307/1136, EK=9.027/16.05\n21-05-11 17:09:22 | #19/55 : NK=312/1148, EK=9.33/16.02\n21-05-11 17:09:22 | #20/55 : NK=311/1170, EK=9.719/17.5\n21-05-11 17:09:22 | #21/55 : NK=327/1174, EK=9.804/17.18\n21-05-11 17:09:22 | #22/55 : NK=311/1231, EK=9.781/18.26\n21-05-11 17:09:22 | #23/55 : NK=302/1174, EK=9.751/17.32\n21-05-11 17:09:23 | #24/55 : NK=311/1134, EK=9.836/17.88\n21-05-11 17:09:23 | #25/55 : NK=322/1174, EK=9.979/17.46\n21-05-11 17:09:23 | #26/55 : NK=311/1210, EK=9.916/18.36\n21-05-11 17:09:23 | #27/55 : NK=322/1174, EK=10.13/17.64\n21-05-11 17:09:23 | #28/55 : NK=325/1210, EK=10.18/18.32\n21-05-11 17:09:23 | #29/55 : NK=322/1224, EK=10.34/18.23\n21-05-11 17:09:23 | #30/55 : NK=315/1210, EK=10.19/18.35\n21-05-11 17:09:23 | #31/55 : NK=322/1184, EK=10.65/18.36\n21-05-11 17:09:24 | #32/55 : NK=303/1210, EK=10.33/18.76\n21-05-11 17:09:24 | #33/55 : NK=300/1136, EK=10.79/18.81\n21-05-11 17:09:24 | #34/55 : NK=318/1122, EK=10.94/18.84\n21-05-11 17:09:24 | #35/55 : NK=300/1190, EK=11.33/19.89\n21-05-11 17:09:24 | #36/55 : NK=301/1119, EK=11.16/19.39\n21-05-11 17:09:24 | #37/55 : NK=316/1118, EK=11.94/20.4\n21-05-11 17:09:24 | #38/55 : NK=306/1175, EK=11.61/20.4\n21-05-11 17:09:24 | #39/55 : NK=310/1136, EK=12.08/21.49\n21-05-11 17:09:24 | #40/55 : NK=306/1151, EK=11.76/20.7\n21-05-11 17:09:25 | #41/55 : NK=307/1136, EK=11.97/21.78\n21-05-11 17:09:25 | #42/55 : NK=306/1139, EK=11.82/20.14\n21-05-11 17:09:25 | #43/55 : NK=309/1136, EK=12.2/21.9\n21-05-11 17:09:25 | #44/55 : NK=306/1147, EK=11.85/20.88\n21-05-11 17:09:25 | #45/55 : NK=309/1136, EK=12.21/21.95\n21-05-11 17:09:25 | #46/55 : NK=306/1147, EK=11.86/20.9\n21-05-11 17:09:25 | #47/55 : NK=309/1136, EK=12.22/21.97\n21-05-11 17:09:25 | #48/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:09:26 | #49/55 : NK=309/1136, EK=12.22/21.98\n21-05-11 17:09:26 | #50/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:09:26 | #51/55 : NK=309/1136, EK=12.22/21.98\n21-05-11 17:09:26 | #52/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:09:26 | #53/55 : NK=309/1136, EK=12.22/21.98\n21-05-11 17:09:26 | #54/55 : NK=306/1147, EK=11.86/20.91\n21-05-11 17:09:26 | #55/55 : NK=0/1136, EK=0/21.98\n21-05-11 17:09:26 | Memory usage : 3.00GiB\nElapsed time: 6.543s, CPU time: 13.86s, Avg # of cores: 2.118\n</code></pre> <pre><code>T = 1e-8;\nInrg = getRhoFDMQS(Inrg,T); % construct full density matrix\n</code></pre> <pre><code>21-05-11 17:09:26 | Construct full density matrix @ T = 1e-08 ...\nElapsed time: 1.907s, CPU time: 4.88s, Avg # of cores: 2.559\n</code></pre> <p>Compute the discrete spectral data of the dynamical impurity spin susceptibility \\(\\chi_s (\\omega )\\) . Here, we use the spin-z operator S(3) in case of U(1) spin symmetry or S in case of SU(2) spin symmetry. Note that in case of SU(2) spin symmetry, we compute the sum of spin correlations in all three spatial directions, which are all identical. To obtain only the z-component, we therefore have to divide by 3. By setting the third input as empty ([]), the getAdiscQS routine understands that the input operator is bosonic. For fermionic operators, the so-called Z string should be considered, and the sign factor between two terms in the anti-commutator is \\(+\\) . On the other hand, for bosonic operators, Z operators do not involve, and the sign factor is \\(-\\) due to commutator.</p> <pre><code>% dynamical impurity spin susceptibility\nif numel(S)&gt;1 % U(1) spin\n    [odisc,Adisc] = getAdiscQS(Inrg,S(3),[]);\nelse % SU(2) spin\n    [odisc,Adisc] = getAdiscQS(Inrg,S,[]);\n    Adisc = Adisc/3; % divide by 3 to consider only z-direction\nend\n</code></pre> <pre><code>21-05-11 17:09:28 | Correlation function for commuting op.\n21-05-11 17:09:28 | #01/55 : sum(Adisc) = 0\n21-05-11 17:09:28 | #02/55 : sum(Adisc) = 0\n21-05-11 17:09:28 | #03/55 : sum(Adisc) = 0\n21-05-11 17:09:28 | #04/55 : sum(Adisc) = 8.754e-24\n21-05-11 17:09:29 | #05/55 : sum(Adisc) = 4.048e-21\n21-05-11 17:09:29 | #06/55 : sum(Adisc) = -3.268e-20\n21-05-11 17:09:29 | #07/55 : sum(Adisc) = -5.5e-19\n21-05-11 17:09:30 | #08/55 : sum(Adisc) = -6.042e-19\n21-05-11 17:09:30 | #09/55 : sum(Adisc) = -3.233e-18\n21-05-11 17:09:30 | #10/55 : sum(Adisc) = -3.667e-18\n21-05-11 17:09:30 | #11/55 : sum(Adisc) = -6.703e-18\n21-05-11 17:09:31 | #12/55 : sum(Adisc) = -7.353e-18\n21-05-11 17:09:31 | #13/55 : sum(Adisc) = -7.57e-18\n21-05-11 17:09:31 | #14/55 : sum(Adisc) = -7.57e-18\n21-05-11 17:09:31 | #15/55 : sum(Adisc) = -3.706e-17\n21-05-11 17:09:32 | #16/55 : sum(Adisc) = -2.492e-17\n21-05-11 17:09:32 | #17/55 : sum(Adisc) = -1.971e-17\n21-05-11 17:09:32 | #18/55 : sum(Adisc) = -5.094e-17\n21-05-11 17:09:33 | #19/55 : sum(Adisc) = -8.563e-17\n21-05-11 17:09:33 | #20/55 : sum(Adisc) = -7.869e-17\n21-05-11 17:09:33 | #21/55 : sum(Adisc) = 9.478e-17\n21-05-11 17:09:34 | #22/55 : sum(Adisc) = 1.017e-16\n21-05-11 17:09:34 | #23/55 : sum(Adisc) = 7.396e-17\n21-05-11 17:09:34 | #24/55 : sum(Adisc) = -2.318e-17\n21-05-11 17:09:34 | #25/55 : sum(Adisc) = 1.85e-16\n21-05-11 17:09:35 | #26/55 : sum(Adisc) = -3.706e-17\n21-05-11 17:09:35 | #27/55 : sum(Adisc) = 7.396e-17\n21-05-11 17:09:35 | #28/55 : sum(Adisc) = 2.405e-16\n21-05-11 17:09:36 | #29/55 : sum(Adisc) = -9.257e-17\n21-05-11 17:09:36 | #30/55 : sum(Adisc) = 6.291e-16\n21-05-11 17:09:36 | #31/55 : sum(Adisc) = 2.405e-16\n21-05-11 17:09:36 | #32/55 : sum(Adisc) = 9.066e-16\n21-05-11 17:09:37 | #33/55 : sum(Adisc) = 4.625e-16\n21-05-11 17:09:37 | #34/55 : sum(Adisc) = 1.24e-15\n21-05-11 17:09:38 | #35/55 : sum(Adisc) = 1.85e-16\n21-05-11 17:09:38 | #36/55 : sum(Adisc) = -8.142e-16\n21-05-11 17:09:38 | #37/55 : sum(Adisc) = -9.252e-16\n21-05-11 17:09:39 | #38/55 : sum(Adisc) = -1.481e-16\n21-05-11 17:09:39 | #39/55 : sum(Adisc) = 5.181e-16\n21-05-11 17:09:40 | #40/55 : sum(Adisc) = -1.813e-15\n21-05-11 17:09:40 | #41/55 : sum(Adisc) = 1.85e-16\n21-05-11 17:09:40 | #42/55 : sum(Adisc) = -1.481e-16\n21-05-11 17:09:41 | #43/55 : sum(Adisc) = -3.706e-17\n21-05-11 17:09:41 | #44/55 : sum(Adisc) = -1.702e-15\n21-05-11 17:09:41 | #45/55 : sum(Adisc) = 8.511e-16\n21-05-11 17:09:42 | #46/55 : sum(Adisc) = -3.706e-17\n21-05-11 17:09:42 | #47/55 : sum(Adisc) = 1.295e-15\n21-05-11 17:09:42 | #48/55 : sum(Adisc) = 1.628e-15\n21-05-11 17:09:43 | #49/55 : sum(Adisc) = 7.396e-17\n21-05-11 17:09:43 | #50/55 : sum(Adisc) = 4.07e-16\n21-05-11 17:09:44 | #51/55 : sum(Adisc) = 5.181e-16\n21-05-11 17:09:44 | #52/55 : sum(Adisc) = 7.401e-16\n21-05-11 17:09:44 | #53/55 : sum(Adisc) = 9.621e-16\n21-05-11 17:09:45 | #54/55 : sum(Adisc) = 1.073e-15\n21-05-11 17:09:45 | #55/55 : sum(Adisc) = 9.621e-16\nElapsed time: 16.61s, CPU time: 28.66s, Avg # of cores: 1.725\n21-05-11 17:09:45 | Memory usage : 3.00GiB\n</code></pre> <p>Broaden the discrete data.</p> <pre><code>    % broaden the discrete data to have a continuous curve\n    [ocont,Acont] = getAcont(odisc,Adisc,log(Lambda),T/5);\n</code></pre> <p>Plot the result.</p> <pre><code>    figure;\n    hold on;\n    % positive frequency\n    plot(ocont(ocont&gt;0),Acont(ocont&gt;0), ...\n        'LineWidth',1,'LineStyle','-');\n    % negative frequency\n    plot(-ocont(ocont&lt;0),-Acont(ocont&lt;0), ...\n        'LineWidth',1,'LineStyle','--');\n    hold off;\n    set(gca,'FontSize',13,'LineWidth',1,'XScale','log','YScale','log');\n    legend({' $\\chi''''_s(\\omega &gt; 0)$ ',' $-\\chi''''_s(\\omega &lt; 0)$ '}, ...\n        'Interpreter','latex');\n    xlabel(' $| \\omega |$ ','Interpreter','latex');\n    ylabel(' $\\chi''''_s$ ','Interpreter','latex');\n    xlim([1e-11 1]);\n    grid on;\n</code></pre> <p> </p> <p>Note that the minus sign prefactor in \\(-\\chi_s^{\\prime \\prime } (\\omega &lt;0)\\) to visualize the data for negative frequency. We see that the curve is an odd function, i.e., \\(\\chi_s^{\\prime \\prime } (\\omega )=-\\chi_s^{\\prime \\prime } (-\\omega )\\) . It is the generic property of the imaginary part of the correlation functions of bosonic operators.</p> <p>Identify the peak position of the curve.</p> <pre><code>    [~,maxid] = max(Acont);\n    disp(ocont(maxid));\n</code></pre> <pre><code>   8.0353e-07\n</code></pre> <p>This value is similar to the Kondo temperature \\(T_{{\\mathrm{K}}}\\) that we obtained from the Bethe ansatz solution. (Note that there are various ways of computing the Kondo temperature, and these ways give similar but different values.)</p> <pre><code>    TK = sqrt(U*Gamma/2)*exp(-pi*U/8/Gamma + pi*Gamma/2/U);\n    disp(TK);\n</code></pre> <pre><code>1.5106e-06\n</code></pre> <pre><code>    disp(ocont(maxid)/TK); % ratio\n</code></pre> <pre><code>    0.5319\n</code></pre> <p>Indeed, the peak position of \\(\\chi_s^{\\prime \\prime } (\\omega )\\) is the method of choice to determine the Kondo temperature for general quantum impurity systems! This method is especially useful when analytical approaches (such as poor man's scaling and the Bethe ansatz) are not applicable due to the complexity of the system.</p>"},{"location":"examples/NRG/NRG_Eflow/","title":"NRG Eflow","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Reproduce lowest-lying energies in the strong-coupling regime by fixed-point Hamiltonians\n% Let's perform the iterative diagonalization first.\n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n\n% Energy flow diagram\nplotEQS(Inrg);\n%% \n% The lowest-lying energies at iteration 54 are:\n\nE = eigQS(diag(Inrg.HK{54}));\nEKodd = [];\nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKodd = [EKodd;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKodd = E;\nend\nfprintf([sprintf('%.4f, ',EKodd(1:5).'),'\\n', ...\n    sprintf('%.4f, ',EKodd(6:11).'),'...\\n']);\n%% \n% The fixed-point description for this iteration is that the impurity (site \n% 1) and the first bath site (site 2) are strongly bound and the rest of the chain \n% (from site 3 to site 54) are decoupled from the dimer. So the excitation spectrum \n% is obtained by considering the lowest excitations of the single-particle Hamiltonian \n% for the part from site 3 to site 54, having even number of sites.\n\nHsp = diag(ff(3:53),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:53)]);\nHsp = Hsp/Inrg.EScale(54); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\n\n% many-body energy values\nEvs = [0; ... % ground-state\n    Esp(end/2+1); Esp(end/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp(end/2); -Esp(end/2); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    Esp(end/2+1)-Esp(end/2); Esp(end/2+1)-Esp(end/2); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp(end/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp(end/2)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n%% \n% On the other hand, the lowest-lying energies for iteration 55 have more degeneracies,\n\nE = eigQS(diag(Inrg.HK{55}));\nEKeven = []; \nif size(E,2) &gt; 1\n    for itE = 1:size(E,1)\n        EKeven = [EKeven;repmat(E(itE,1),[E(itE,2),1])];\n    end\nelse\n    EKeven = E;\nend\nfprintf([sprintf('%.4f, ',EKeven(1:4).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(5:12).'),'\\n', ...\n    sprintf('%.4f, ',EKeven(13:20).'),'...\\n']);\n%% \n% The 4-fold and 16-fold degeneracies can be seen as that extra factor 4 is \n% multiplied to the degeneracies of the 1-fold and 4-fold degeneratices in the \n% case of iteration 54, putting aside different values of energies. This factor \n% 4 can be understood by the fixed-point Hamiltonian as well. The part of the \n% chain decoupled from the strongly coupled dimer has odd number of sites. So \n% it has a zero mode:\n\nHsp = diag(ff(3:54),1);\nHsp = Hsp + Hsp' + diag([0;gg(3:54)]);\nHsp = Hsp/Inrg.EScale(55); % rescale energy scale\nEsp = eig((Hsp+Hsp')/2);\nEsp = sort(Esp,'ascend');\nfprintf('%.4f\\n',Esp((end+1)/2));\n%% \n% There are four Fock states regarding the zero mode (empty, spin-up, spin-down, \n% doubly occupied), having all the same zero energy. So it introduces factor 4 \n% to the degeneracies. Factoring out the degrees of freedom of this zero mode, \n% we construct the lowest-lying energies at iteration 55 as for iteration 54:\n\n% many-body energy values\nEvs = [0; ... % ground-state\n    Esp((end+1)/2+1); Esp((end+1)/2+1); ...\n    % lowest one-particle excitation, spin-up/down\n    -Esp((end+1)/2-1); -Esp((end+1)/2-1); ...\n    % lowest one-hole excitation, spin-up/down\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    Esp((end+1)/2+1)-Esp((end+1)/2-1); ...\n    % particle-hole pair excitation, up/down * up/down\n    Esp((end+1)/2+1)*2; ...\n    % two-particle exciation (up + down)\n    -Esp((end+1)/2-1)*2];\n    % two-hole exciation (up + down)\nfprintf([sprintf('%.4f, ',Evs(1:5).'),'\\n', ...\n    sprintf('%.4f, ',Evs(6:11).'),'...\\n']);\n</code></pre>"},{"location":"examples/NRG/NRG_Kondo/","title":"NRG for SIKM","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Single-impurity Kondo model\n% In the example of the SIAM, we set the first leg (i.e., left leg) of |A0| \n% as a dummy leg for vacuum and the second leg (i.e., bottom leg) for the Anderson \n% impurity. The impurity Hamiltonian $H_\\mathrm{imp}$ involves only one fermionic \n% site (i.e., $d$ level). The rest of the chain Hamiltonian is the hopping and \n% on-site terms that are generated within |NRG_IterDiagQS|.\n% \n% On the other hand, in the SIKM, the exchange interaction $H_\\mathrm{exc}$ \n% acts on two sites: a spin site for $\\hat{\\vec{S}}_d$ and a spinful fermionic \n% site for $\\hat{\\vec{S}}_0$. The latter site is the first bath site, and coupled \n% with the other fermionic sites via particle hopping that can be generated inside \n% |NRG_IterDiagQS|.\n% \n% Therefore, to use the same function |NRG_IterDiagQS| for the SIKM, we associate \n% the first leg of |A0| with the spin site for $\\hat{\\vec{S}}_d$ and its second \n% leg with the spinful fermionic site for $\\hat{\\vec{S}}_0$. Accordingly, we shift \n% the hopping amplitudes and on-site energies by one site to the left, as the \n% second leg of |A0| involves the first bath site.\n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n%% \n% Here |ff(1)|, |ff(2)|, |ff(3)|, ... are equal to |ff(2)|, |ff(3)|, |ff(4)|, \n% ... for the |ff| vector in the SIAM case. Note that the first element |ff(1)| \n% in the SIAM case depends on the hybridization strength $\\Gamma$; it is absorbed \n% into the definition of $J$ after the Schrieffer-Wolff transformation.\n% \n% Then run the iterative diagonalization, and plot the energy flow diagram.\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n\n% Energy flow diagram\nplotEQS(Inrg);\n%% \n% The energy flow diagram looks similar with the diagram for the SIAM, especially \n% the last crossovers and the spectrum at the last iterations in the strong-coupling \n% fixed-point regime. There are two differences as well:\n%% \n% * The panel for even (odd) iterations in the SIKM case look similar to the \n% panel for odd (even) iterations in the SIAM. It is because we have shifted the \n% chain sites by one to the left.\n% * While there are two crossovers in the SIAM, here in the SIKM there is only \n% one crossover, which is from the local moment regime to the Kondo regime.\n</code></pre>"},{"location":"examples/NRG/NRG_Kondo_Thermal/","title":"SIKM Thermal Properties","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Single-impurity Kondo model\n% Perform the iterative diagonalization for the whole Kondo model (SIKM). \n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\nJ = 8*Gamma/pi/U; % Kondo coupling strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,~] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,30);\n% post-processing\nff = [ff;ff(end).*(Lambda.^(-(1:(N-numel(ff))).'/2))];\ngg = zeros(size(ff));\nff = ff(2:end); % shift to the left by one site\ngg = gg(2:end);\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS','Acharge,SU2spin','NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n[Ss,Is] = getLocalSpace('Spin',1/2);\n[Ss,Is] = setItag('L00','op',Ss,Is.E);\n\n% attach U(1) charge symmetry label to spin\nSs = appendScalarSymmetry(Ss,'A','pos',1);\nIs = appendScalarSymmetry(Is,'A','pos',1);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = 2*J*contract(Ss,S,'*');\n\n% ket tensor for the impurity\nA0 = getIdentity(Is,1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0}) + 1e-33*contract(A0,'!2*',A0);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\nbeta0 = 1; % parameter to define temperature values\n[T,Tchi,Sent] = getTDconvQS(Inrg,beta0);\n%% \n% Perform the iterative diagonalization for the bath only. *We replace the Kondo \n% impurity with vacuum*.\n\nA0_2 = getIdentity(setItag(getvac(EF,1),'L00'),2,EF,2,'K00',[1 3 2]); \nH0_2 = 1e-33*contract(A0_2,'!2*',A0_2);\nInrg2 = NRG_IterDiagQS(H0_2,A0_2,Lambda,ff,F,gg,NF,Z,Nkeep);\n[~,Tchi2,Sent2] = getTDconvQS(Inrg2,beta0);\n%% \n% Then subtract the thermodynamic properties from the bath only from those from \n% the whole impurity model, to obtain the impurity contribution.\n\n% impurity contribution to the spin susceptibility (* temperature)\nTchi_imp = Tchi - Tchi2; \n% impurity contribution to the entropy\nSent_imp = Sent - Sent2;\n\nlogT = log(T);\n% impurity contribution to the specific heat C = T* dS/dT = dS / d(log T)\nC_imp = interp1((logT(1:end-1)+logT(2:end))/2, ...\n    diff(Sent_imp)./diff(logT),logT,'linear','extrap');\n\n% Sommerfeld-Wilson ratio\nWR = (Tchi_imp./C_imp)*(4*(pi^2)/3);\n%% \n% To rescale the temperature, we compute the Kondo temperature $T_\\mathrm{K}$. \n% Here we use the formula from the second-order poor man's scaling calculation.\n\n% Kondo temperature\nTK = sqrt(J) * exp(-1/J); % half-bandwidth D = 1\ndisp(TK);\n%% \n% Plot the result.\n\nfigure;\nsemilogx(T/TK,(Tchi_imp./T)*(4*TK), ...\n    T/TK,Sent_imp/log(2), ...\n    T/TK,WR,'LineWidth',1);\nset(gca,'LineWidth',1,'FontSize',13);\nxlabel('$T / T_\\mathrm{K}$','Interpreter','latex');\nlegend({'$4 T_\\mathrm{K} \\chi_\\mathrm{imp}$'; ...\n    '$S_\\mathrm{imp} / \\ln 2$'; ...\n    '$R$'}, ...\n    'Interpreter','latex','Location','northwest');\nylim([0 3]);\nxlim([min(T) max(T)]/TK);\ngrid on;\n%% \n% The curves of $R(T)$ and $\\chi_\\mathrm{imp}(T)$ for the SIKM exhibit similar \n% behavior as those for the SIAM. Compare this plot with the demonstration plot. \n% The kinks of $R$ at the highest and the lowest temperatures come from numerical \n% artifact.\n% \n% On the other hand, the curve of $S_\\mathrm{imp}(T)$ for the SIKM shows different \n% features from that for the SIAM. $S_\\mathrm{imp} (T)$ for the SIAM has had three \n% plateaus that represent three regimes: (i) $\\ln 4$ for the free orbital regime, \n% (ii) $\\ln 2$ for the local moment regime, and (iii) $0$ for the strong coupling \n% regime. $S_\\mathrm{imp} (T)$ for the SIKM has only two plateaus: (i) $\\ln 2$ \n% for the local moment regime and (ii) $0$ for the strong coupling regime.\n% \n% The absence of the free orbital regime is natural. In the derivation of the \n% SIKM out of the SIAM, the doubly-occupied and the empty states of the impurity \n% are \"integrated out.\" As the result, the impurity of the SIKM has only spin \n% degrees of freedom. That is, there is no free orbital regime at all for the \n% SIKM.\n</code></pre>"},{"location":"examples/NRG/NRG_SpecFunc/","title":"NRG for Spectral Functions","text":"<p>Please download the dependencies for the following example here.</p> <pre><code>%% Dynamical impurity spin susceptibility\n% Perform the iterative diagonalization calculation, with the same parameters \n% chosen in the demonstration of the previous examples.\n\nclear\n\n% Hamiltonian parameters\nU = 4e-3; % Coulomb interaction at the impurity\nepsd = -U/2; % impurity on-site energy\nGamma = 8e-5*pi; % hybridization strength\n\n% NRG parameters\nLambda = 2.5; % discretization parameter\nN = 55; % length of the Wilson chain\nNkeep = 300;\n\n% Wilson chain\n[ff,gg] = doCLD([-1 1],[1 1]*Gamma/pi,Lambda,N);\n\n% symmetries\nsymstr = 'Acharge,SU2spin'; % U(1) charge and SU(2) spin\n% symstr = 'Acharge,Aspin'; % U(1) charge and U(1) spin\n\n% Construct local operators\n[F,Z,S,I] = getLocalSpace('FermionS',symstr,'NC',1);\n[F,Z,S,EF] = setItag('s00','op',F,Z,S,I.E);\n\n% particle number operator\nNF = QSpace;\nfor itF = 1:numel(F)\n    NF(itF) = contract(F(itF),'!2*',F(itF));\nend\n\n% Impurity Hamiltonian\nH0 = U/2*sum(NF)*(sum(NF)-1) + epsd*sum(NF) + 1e-33*EF;\n\n% ket tensor for the impurity\nA0 = getIdentity(setItag('L00',getvac(EF,1)),1,EF,1,'K00',[1,3,2]);\n\nH0 = contract(A0,'!2*',{A0,H0});\n\n% same hopping amplitude and on-site energies for all flavors\nff = repmat(ff,[1,numel(F)]);\ngg = repmat(gg,[1,numel(F)]);\n\n% iterative diagonalization\nInrg = NRG_IterDiagQS(H0,A0,Lambda,ff,F,gg,NF,Z,Nkeep);\n\nT = 1e-8;\nInrg = getRhoFDMQS(Inrg,T); % construct full density matrix\n%% \n% Compute the discrete spectral data of the dynamical impurity spin susceptibility \n% $\\chi_s (\\omega)$. Here, we use the spin-z operator |S(3)| in case of U(1) spin \n% symmetry or |S| in case of SU(2) spin symmetry. Note that in case of SU(2) spin \n% symmetry, we compute the sum of spin correlations in all three spatial directions, \n% which are all identical. To obtain only the z-component, we therefore have to \n% divide by 3. By setting the third input as empty (|[]|), the |getAdiscQS| routine \n% understands that the input operator is *bosonic*. For fermionic operators, the \n% so-called Z string should be considered, and the sign factor between two terms \n% in the anti-commutator is $+$. On the other hand, for bosonic operators, Z operators \n% do not involve, and the sign factor is $-$ due to commutator.\n\n% dynamical impurity spin susceptibility\nif numel(S)&gt;1 % U(1) spin\n    [odisc,Adisc] = getAdiscQS(Inrg,S(3),[]);\nelse % SU(2) spin\n    [odisc,Adisc] = getAdiscQS(Inrg,S,[]);\n    Adisc = Adisc/3; % divide by 3 to consider only z-direction\nend\n%% \n% Broaden the discrete data.\n\n    % broaden the discrete data to have a continuous curve\n    [ocont,Acont] = getAcont(odisc,Adisc,log(Lambda),T/5);\n%% \n% Plot the result.\n\n    figure;\n    hold on;\n    % positive frequency\n    plot(ocont(ocont&gt;0),Acont(ocont&gt;0), ...\n        'LineWidth',1,'LineStyle','-');\n    % negative frequency\n    plot(-ocont(ocont&lt;0),-Acont(ocont&lt;0), ...\n        'LineWidth',1,'LineStyle','--');\n    hold off;\n    set(gca,'FontSize',13,'LineWidth',1,'XScale','log','YScale','log');\n    legend({'$\\chi''''_s(\\omega &gt; 0)$','$-\\chi''''_s(\\omega &lt; 0)$'}, ...\n        'Interpreter','latex');\n    xlabel('$| \\omega |$','Interpreter','latex');\n    ylabel('$\\chi''''_s$','Interpreter','latex');\n    xlim([1e-11 1]);\n    grid on;\n%% \n% Note that the minus sign prefactor in $- \\chi''_s (\\omega &lt; 0)$ to visualize \n% the data for negative frequency. We see that the curve is an odd function, i.e., \n% $\\chi''_s (\\omega) = - \\chi''_s (-\\omega)$. It is the generic property of the \n% imaginary part of the correlation functions of bosonic operators.\n%% \n% Identify the peak position of the curve.\n\n    [~,maxid] = max(Acont);\n    disp(ocont(maxid));\n%% \n% This value is similar to the Kondo temperature $T_\\mathrm{K}$ that we obtained \n% from the Bethe ansatz solution. (Note that there are various ways of computing \n% the Kondo temperature, and these ways give similar but different values.)\n\n    TK = sqrt(U*Gamma/2)*exp(-pi*U/8/Gamma + pi*Gamma/2/U);\n    disp(TK);\n    disp(ocont(maxid)/TK); % ratio\n%% \n% Indeed, the peak position of $\\chi''_s (\\omega)$ is the method of choice to \n% determine the Kondo temperature for general quantum impurity systems! This method \n% is especially useful when analytical approaches (such as poor man's scaling \n% and the Bethe ansatz) are not applicable due to the complexity of the system.\n</code></pre>"},{"location":"installation/Linux/","title":"Installation on Linux Platforms","text":"<p>This document provides a detailed guide to installing the QSpace library on Linux systems, tailored to support users with varying levels of programming expertise. The installation process includes setting up MATLAB, ensuring the appropriate version of gcc is used, managing dependencies, cloning the QSpace repository, and compiling the library. For advanced customizations or troubleshooting, please refer to [TODO]</p> <p>Note</p> <p>This installation guide is specific for community edition (OSQSpace). For the installation of the standard edition, please refer to the README and relevant setup scripts under system directory of the QSpace4u project.</p>"},{"location":"installation/Linux/#install-matlab-version-2020b-or-above","title":"Install MATLAB (Version 2020b or Above)","text":"<p>MATLAB is critical for QSpace as it provides an interface through which the library's routines are executed. It is recommended to install MATLAB version 2020b or newer to guarantee compatibility with QSpace\u2019s functions. MATLAB 2018a to 2020a may also work, but no active support is provided for these versions.</p> <p>To install MATLAB on Linux, download the appropriate version of MATLAB from the MATLAB download page. Ensure you are downloading a version for Linux platform.</p> <p>Next, navigate to your download folder, make the downloaded script executable, and initiate the installation process. You may follow the commands:</p> <p><pre><code>chmod +x matlab_R20XXx_glnxa64.bin\n./matlab_R20XXx_glnxa64.bin\n</code></pre> Then, follow the on-screen instructions to complete the installation. If MATLAB environment is managed through a module system, you can typically load the MATLAB module using:</p> <pre><code>module load matlab/R20XXx\n</code></pre> <p>In this scenario, please ensure that the appropriate module is loaded before proceeding with any QSpace related workflow. To verify a successful installation, open your terminal and execute:</p> <pre><code>which matlab\n</code></pre> <p>This should return the path to the MATLAB executable, confirming that MATLAB is ready for use. This path will be set as the <code>MATLAB_ROOT</code> environment variable and is vital for the QSpace installation and workflows.</p>"},{"location":"installation/Linux/#prepare-gcc-compiler-version-9x-or-below","title":"Prepare gcc Compiler (Version 9.x or Below)","text":"<p>QSpace requires gcc for compilation. The version of gcc should be compatible with MATLAB. MATLAB 2020b and later versions support gcc 9.x and previous versions. An old MATLAB and an overly new gcc may cause unexpected compatibility issues. Please refer to Supported Compilers page for the supported gcc versions for a specific MATLAB version.</p> <p>Before proceeding with the installation, ensure that the correct version of gcc is installed on your system. Check your current gcc version by running:</p> <pre><code>gcc --version\n</code></pre> <p>If the installed version is not supported by MATLAB, you may need to install the appropriate version. For instance, you can install gcc-9.5.0 using your Linux distribution's package manager. For distributions using <code>apt</code>, such as Ubuntu, run the following commands:</p> <pre><code>sudo apt install gcc-9 g++-9\n</code></pre> <p>To avoid version conflicts, especially if other versions of gcc are already installed, configure your system to use gcc-9.5.0 as the default for this installation session:</p> <pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 60 --slave /usr/bin/g++ g++ /usr/bin/g++-9\n</code></pre> <p>The command includes <code>60</code> to assign a priority to the <code>gcc-9</code> version, making it a preferred choice if multiple GCC versions are installed. The <code>--slave</code> part ensures that when <code>gcc-9</code> is selected as the default GCC compiler, <code>g++-9</code> automatically becomes the default G++ compiler, maintaining consistency between the C and C++ compilers.</p>"},{"location":"installation/Linux/#manage-dependencies","title":"Manage Dependencies","text":"<p>QSpace depends on several libraries, including GMP, MPFR, and OpenMP, which are essential for high-precision arithmetic and efficient multi-threading.</p> <p>Dependency Installation: Install these libraries through your package manager:   <pre><code>sudo apt install libgmp-dev libmpfr-dev libomp-dev\n</code></pre></p> <p>Checking Library Installation: Verify the installation of these libraries by querying the package manager. For instance:   <pre><code>dpkg -l | grep libgmp\n</code></pre></p> <p>These libraries should rest in the default system directories, such as <code>/usr/lib</code> or <code>/usr/local/lib</code>. Otherwise, you may need to adjust <code>LD_LIBRARY_PATH</code> environment variable to include the directories where the libraries are installed.</p>"},{"location":"installation/Linux/#clone-the-qspace-repository","title":"Clone the QSpace Repository","text":"<p>Clone the repository to acquire the source code necessary for installation:</p> <pre><code>git clone git@github.com:Open-Source-QSpace/OSQSpace.git\n</code></pre> <p>Ensure that your SSH keys are configured correctly with GitHub for a smooth cloning process.</p>"},{"location":"installation/Linux/#compile-the-qspace-library","title":"Compile the QSpace Library","text":"<p>Navigate to the repository directory and execute the configuration and compilation scripts:</p> <pre><code>cd system &amp;&amp; source configure &amp;&amp; ./compile.sh\n</code></pre> <p>The <code>configure</code> script sets up a command line tool <code>osqs</code> and the installation directory of QSpace library. The compile script calls the environment setup script before compiling the QSpace library. Customizations are available via setting <code>QS_CONFIG_ML_SH</code> environment variable pointing to a custom environment setup script.</p>"},{"location":"installation/Linux_old/","title":"Installation on Linux","text":""},{"location":"installation/Linux_old/#sec:linux_ml","title":"Install MATLAB","text":"<p>QSpace is a library running on MATLAB, so one needs a MATLAB installation. For the current QSpace distribution (v4.0), we recommend to use MATLAB R2020b or later, because of MEX compilers. Older MATLAB versions might work, but no guarantee.</p>"},{"location":"installation/Linux_old/#sec:linux_gmp_mpfr","title":"Install <code>gmp</code> and <code>mpfr</code>","text":"<p>QSpace uses <code>gmp</code> and <code>mpfr</code>, multiprecision arithmetics libraries, in generating and manipulating the Clebsch-Gordan coefficient tensors. However, a standard installation of Linux may not have <code>gmp</code> and <code>mpfr</code> installed.</p>"},{"location":"installation/Linux_old/#sec:linux_gmp","title":"Install <code>gmp</code>","text":"<p>If you are not sure whether <code>gmp</code> is installed in your device, type in the terminal:</p> <pre><code>dpkg -s libgmp-dev\n</code></pre> <p>If the command works, showing the installed version of <code>gmp</code>, then you can skip the rest of this subsection and move forward to Install <code>mpfr</code>.</p> <p>When the terminal says <code>package 'libgmp-dev' is not installed</code>, then you can install <code>gmp</code> by typing the following command.</p> <pre><code>sudo apt-get install libgmp-dev\n</code></pre>"},{"location":"installation/Linux_old/#sec:linux_mpfr","title":"Install <code>mpfr</code>","text":"<p>If you are not sure whether <code>mpfr</code> is installed in your device, type in the terminal:</p> <pre><code>dpkg -s libmpfr-dev\n</code></pre> <p>If the command works, showing the installed version of <code>mpfr</code>, then you can skip the rest of this subsection and move forward to Retrieve QSpace files.</p> <p>When the terminal says <code>package 'libmpfr-dev' is not installed</code>, then you can install <code>mpfr</code> by typing the following command.</p> <pre><code>sudo apt-get install libmpfr-dev\n</code></pre>"},{"location":"installation/Linux_old/#sec:linux_qs","title":"Retrieve QSpace files","text":"<p>There is a separate Git repository for the QSpace codes for Linux. If you know how to use Git, then you can proceed with cloning the repository. If you don't know, then visit the repository webpage and click Clone, which will lead you a dialogue window showing the command:</p> <pre><code>git clone https://bitbucket.org/qspace4u/qspace-v4-pub.git\n</code></pre> <p>Then go to a directory under which the copied Git repository data will be stored. Move to the directory, and run the command above in your terminal. Then the repository will be cloned to a sub-directory under your current working directory.</p>"},{"location":"installation/Linux_old/#mex-compile-source-codes","title":"MEX-compile source codes","text":"<p>The QSpace distribution for Linux does not include MEX binaries, contrary to that for macOS, so one needs to compile C++ source codes. For this one needs to install <code>gcc</code> or, if your system uses a module system, load a <code>gcc</code> module. One can check which versions of <code>gcc</code> are supported by a specific MATLAB version here.</p> <p>If you are not sure whether <code>gcc</code> is installed in your device, type in the terminal:</p> <pre><code>gcc \u2013version\n</code></pre> <p>If the command works, showing the installed version of <code>gcc</code>, then move forward to the next paragraph. If the command does not show the installed version of <code>gcc</code>, then you can install <code>gcc</code> by typing the following command.</p> <pre><code>sudo apt install gcc\n</code></pre> <p>If the <code>gcc</code> version installed in your device is not supported by MATLAB, you have to install the supported version of <code>gcc</code>. As an example, If the <code>gcc</code> of version 11 is installed and MATLAB supports only the <code>gcc</code> of version 9, you can install <code>gcc</code> of version 9 by typing following commands.</p> <pre><code>sudo apt install build-essential\nsudo apt-get install -y gcc-9\ncd /usr/bin\nsudo rm gcc\nsudo ln -s gcc-9 gcc\n</code></pre> <p>To check the current version of <code>gcc</code>, type in the terminal:</p> <pre><code>gcc \u2013version\n</code></pre> <p>If you want to roll back to the <code>gcc</code> of version 11, type in the terminal:</p> <pre><code>cd /usr/bin\nsudo rm gcc\nsudo ln -s gcc-11 gcc\n</code></pre> <p>To check the current version of <code>gcc</code>, type in the terminal:</p> <pre><code>gcc \u2013version\n</code></pre> <p>Our QSpaceTutorial package offers a simple way to compile the source codes. First, open a MATLAB session. Then run the function <code>Util/compile.m</code>. That's it!</p> <p>The remaining step before using the <code>QSpace</code> library is to set environment variables and paths; see Set environment variables and paths.</p>"},{"location":"installation/Linux_old/#sec:startup","title":"Set environment variables and paths","text":""},{"location":"installation/Linux_old/#set-rc_store","title":"Set <code>RC_STORE</code>","text":"<p><code>RC_STORE</code> is the only environment variable that needs to be set by users, to execute the QSpace functions (both <code>.m</code> and <code>MEX</code>). This variable specifies the paths to place the database of Clebsch--Gordan coefficient tensor (CGT) data, which is generated and read on the fly during calculations. Those CGT data can be reused for different calculations, which provides a great computational advantage.</p> <p><code>RC_STORE</code> can be defined by multiple paths glued with <code>:</code>, e.g., <code>path1:path2:path3</code>. When there are \\(n\\) paths, then the functions look up CGT data from the first path, then the second, and so on. If the CGT data of interest are not created yet, then QSpace generates and store them in the last path. When \\(n &gt; 1\\), the paths except for the last are read-only.</p> <p>Since CGTs are used to define the symmetry multiplet basis to represent physical tensors, it is important to have consistent CGT database. Especially, when running on a computing cluster, the database consistency among different jobs is essential. Therefore, a recommended choice of <code>RC_STORE</code> for clusters is <code>path1:path2</code>, where <code>path1</code> is the path for the \"global\" database to be looked up by all cluster jobs and <code>path2</code> is a job-dependent path that refers to the \"local\" increment specific to a job. If the global database is large enough, the local increment will remain small. On the other hand, for laptops and desktops, such distinction might be an overkill; one can simply set <code>RC_STORE</code> as a single path.</p>"},{"location":"installation/Linux_old/#modify-startupm","title":"Modify <code>startup.m</code>","text":"<p><code>startup.m</code> is a script that is first executed upon starting up a MATLAB session, so that important environment variables and paths are set before use. This <code>QSpaceTutorial</code> as well as <code>MuNRG</code> have own <code>startup.m</code> that should be modified by users regarding those environment variables. Mostly such variables are for paths that depend on computing systems. Please follow the instruction in <code>startup.m</code> to set the environment variables properly.</p>"},{"location":"installation/Linux_old/#troubleshooting","title":"Troubleshooting","text":"<p>In the following, some known issues regarding QSpace and their workarounds are given.</p>"},{"location":"installation/Linux_old/#make-command-not-found","title":"make: command not found","text":"<p>When you try to compile QSpace, MATLAB might show the following error message.</p> <pre><code>/bin/bash: line 1: make: command not found\n</code></pre> <p>This error occurs if Linux does not have <code>make</code>, a tool which controls the generation of executables from source files, installed.</p> <p>To resolve this error, install <code>make</code> by typing the following command.</p> <pre><code>sudo apt install make\n</code></pre>"},{"location":"installation/Linux_old/#invalid-mex-file-glibcxx-not-found","title":"Invalid MEX file, GLIBCXX not found","text":"<p>When you try to use QSpace, MATLAB might complain that the MEX files are not valid and show the following error message.</p> <pre><code>Invalid MEX-file\n\u2018/home/Document/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64\u2019:\n/usr/local/MATLAB/R2022a/bin/glnxa64/../../sys/os/glnxa64/libstdc++.so.6: version\n\u2018GLIBCXX_3.4.29\u2019 not found (required by\n/home/Document/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64)\n</code></pre> <p>To resolve this error, try following commands in the terminal.</p> <pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test`\nsudo apt-get update\nsudo apt-get install gcc-4.9\nsudo apt-get upgrade libstdc++6\n</code></pre> <p>Then, recomplie the sourse code by running the function <code>Util/compile.m</code> again.</p> <p>If MATLAB still complains, then copy and paste the file <code>libstdc++.so.6</code> at the directory <code>/usr/local/MATLAB/R2022a/sys/os/glnxa64</code> by using the following a single command.</p> <pre><code>sudo cp /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/local/MATLAB/R2022a/sys/os/glnxa64/\n</code></pre> <p>Note that the directory depends on your MATLAB version, e.g., if you are using MATLAB R2021b, then type the following single command instead.</p> <pre><code>sudo cp /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/local/MATLAB/R2021b/sys/os/glnxa64/\n</code></pre> <p>Then, recomplie the sourse code by running the function <code>Util/compile.m</code> again.</p> <p> </p>"},{"location":"installation/customize/","title":"Customization of Environment Variables","text":"<p>This document provides detailed explanations of the environment variables used in the QSpace library, outlining their purposes and how to properly configure them. These environment variables are crucial for ensuring that the QSpace library functions correctly and integrates seamlessly with MATLAB and system-specific resources. Preconfigured settings are available for users on High-Performance Computing (HPC) clusters at the Arnold-Sommerfeld Center and macOS systems. Users on other platforms should configure these variables manually using <code>env_custom.sh</code> prior to compilation.</p>"},{"location":"installation/customize/#environment-variables-explanation","title":"Environment Variables Explanation","text":""},{"location":"installation/customize/#osqs-qspace-installation-directory","title":"<code>OSQS</code>: QSpace Installation Directory","text":"<ul> <li>Description: This variable specifies the installation directory of the QSpace library where the main library files are located.</li> <li>Typical Usage: Set this to the directory where you have cloned or extracted QSpace.</li> </ul>"},{"location":"installation/customize/#matlab_root-matlab-installation-directory","title":"<code>MATLAB_ROOT</code>: MATLAB Installation Directory","text":"<ul> <li>Description: This points to the installation directory of the MATLAB installation on your system.</li> <li>Notes: On systems where MATLAB is managed through environment modules, this variable might be set automatically when you load a MATLAB module.</li> </ul>"},{"location":"installation/customize/#startup-qspace-startup-location","title":"<code>STARTUP</code>: QSpace Startup Location","text":"<ul> <li>Description: This environment variable indicates the location of the <code>startup.m</code> file, which is a MATLAB script that sets up paths and initialization settings necessary for QSpace.</li> <li>Typical Usage: It is typically set to the same directory as <code>OSQS</code>, as the <code>startup.m</code> file is usually located within the root directory of QSpace.</li> </ul>"},{"location":"installation/customize/#lma-local-matlab-data-directory","title":"<code>LMA</code>: Local MATLAB Data Directory","text":"<ul> <li>Description: Specifies the directory for local MATLAB data used by QSpace.</li> <li>Purpose: This directory is used to store MATLAB-specific data that needs to be accessed frequently by the QSpace library.</li> </ul>"},{"location":"installation/customize/#rc_store-clebsch-gordan-coefficient-storage","title":"<code>RC_STORE</code>: Clebsch-Gordan Coefficient Storage","text":"<ul> <li>Importance: This is a crucial variable for the operation of QSpace, particularly for computations involving SU(N) groups where N&gt;1.</li> <li>Description: Specifies the location where the Clebsch-Gordan coefficients are stored. These coefficients are essential for the mathematical operations performed by QSpace.</li> <li>Configuration Note: Ensure that this directory is properly set to a location where the system has read and write permissions, as these coefficients may need to be updated or modified.</li> </ul>"},{"location":"installation/customize/#rc_sync-clebsch-gordan-coefficient-lock-files","title":"<code>RC_SYNC</code>: Clebsch-Gordan Coefficient Lock Files","text":"<ul> <li>Description: Indicates the directory where lock files associated with the Clebsch-Gordan coefficients are stored.</li> <li>Purpose: These lock files prevent multiple instances of QSpace from interfering with each other when accessing the Clebsch-Gordan coefficients, thus ensuring data integrity and consistency.</li> </ul>"},{"location":"installation/customize/#platform-specific-presets","title":"Platform-Specific Presets","text":"<ul> <li>HPC Clusters at Arnold-Sommerfeld Center: For users operating within these HPC environments, preset configurations are provided which automatically set these environment variables appropriately. Users should refer to the specific cluster documentation or system admin for details.</li> <li>macOS Systems: There are also presets available for macOS users which simplify the setup process by automatically configuring these environment variables to work optimally with typical macOS setups.</li> </ul>"},{"location":"installation/customize/#setting-up-on-other-platforms","title":"Setting Up on Other Platforms","text":"<p>For users operating on platforms other than those mentioned, the <code>env_custom.sh</code> script should be utilized to set up these environment variables before compiling the QSpace library. This script allows users to manually specify the values of these variables tailored to their specific system configuration and preferences.</p>"},{"location":"installation/macOS/","title":"Installation on macOS System","text":"<p>This document provides a detailed guide to installing the QSpace library on macOS, tailored to support users with varying levels of programming expertise. The installation process includes setting up MATLAB, configuring the appropriate compiler via Xcode, installing Homebrew, and cloning the QSpace repository before compiling the library. For advanced customizations or troubleshooting, please refer to [TODO].</p> <p>Note</p> <p>This installation guide is specific for the community edition (OSQSpace). For the installation of the standard edition, please refer to the README and relevant setup scripts under the system directory of the QSpace4u project.</p>"},{"location":"installation/macOS/#install-matlab-version-2020b-or-above","title":"Install MATLAB (Version 2020b or Above)","text":"<p>MATLAB is essential for QSpace as it interfaces with the library's routines. It is advised to install MATLAB version 2020b or newer to ensure compatibility with QSpace's functionalities. Versions from 2018a to 2020a may work but are not actively supported.</p> <p>To install MATLAB on macOS: 1. Visit the MATLAB download page and select the version suitable for macOS. Download the installer. 2. Open the downloaded file and follow the on-screen instructions to complete the installation.</p>"},{"location":"installation/macOS/#choose-matlab-architecture-based-on-cpu-architecture","title":"Choose MATLAB Architecture Based on CPU Architecture","text":"<p>With macOS, it is important to match MATLAB's architecture with your CPU architecture to ensure optimal performance and compatibility:</p> <ul> <li>For Intel-based Macs, use the standard MATLAB installer for macOS.</li> <li>For Apple Silicon (M-series chips), choose the MATLAB version compiled for ARM architecture, available starting from the 2023b release.</li> </ul> <p>Note</p> <p>It is also possible to run the Intel version of MATLAB (e.g. versions earlier than 2023b) on Apple Silicon Macs using Rosetta 2 emulation. QSpace presets support this functionality. However, it is still recommended to use the native ARM version for best compatibility and performance.</p>"},{"location":"installation/macOS/#setup-clang-compiler-via-xcode","title":"Setup Clang Compiler via Xcode","text":"<p>QSpace requires a C/C++ compiler, and on macOS, Clang is the standard. To set up Clang, install Xcode from the Mac App Store. After installation, open Xcode and install additional required components when prompted, which includes the Clang compiler. To verify that the Clang compiler is ready, open a terminal and run:</p> <pre><code>clang --version\n</code></pre> <p>This will display the Clang version, indicating that it is installed and ready to use.</p>"},{"location":"installation/macOS/#install-homebrew","title":"Install Homebrew","text":"<p>Homebrew is a package manager for macOS that simplifies the installation of software and libraries. It is important to ensure that Homebrew is installed correctly according to your Mac's CPU architecture to manage dependencies efficiently.</p> <p>To install Homebrew on macOS, open a terminal and run the following commands:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Regardless of your CPU architecture (Intel or Apple Silicon), the installation command for Homebrew is the same. This script will automatically detect your macOS architecture and install the correct version of Homebrew.</p> <p>The installer will guide you through the necessary steps to complete the installation. If additional actions are required (such as adding Homebrew to your path), the installer will provide the specific commands. After installation, you can verify that Homebrew is installed correctly via:</p> <pre><code>brew --version\n</code></pre> <p>This command will display the installed version of Homebrew, confirming that it is ready to use.</p> <p>If you are using an Apple Silicon Mac and need to run software that is only available for Intel architecture, you can set up an additional Homebrew installation under the Rosetta 2 emulation layer. This is necessary if you hope to run Intel-compiled MATLAB with Intel-compiled QSpace binaries on an Apple Silicon Mac.</p> <p>To do this, you need to prefix your Homebrew commands with <code>arch -x86_64</code> to switch to the Intel architecture environment:</p> <pre><code>arch -x86_64 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>This allows you to manage and install packages specifically for Intel architecture on Apple Silicon Macs.</p> <p>The compilation scripts carried by QSpace will handle the dependencies as long as Homebrew is installed correctly.</p>"},{"location":"installation/macOS/#clone-the-qspace-repository","title":"Clone the QSpace Repository","text":"<p>Clone the repository to acquire the source code necessary for installation:</p> <pre><code>git clone git@github.com:Open-Source-QSpace/OSQSpace.git\n</code></pre> <p>Ensure that your SSH keys are configured correctly with GitHub for a smooth cloning process.</p>"},{"location":"installation/macOS/#compile-the-qspace-library","title":"Compile the QSpace Library","text":"<p>Navigate to the repository directory and execute the configuration and compilation scripts:</p> <pre><code>cd system &amp;&amp; source configure &amp;&amp; ./compile.sh\n</code></pre> <p>The <code>configure</code> script sets up a command line tool <code>osqs</code> and the installation directory of QSpace library. The compile script calls the environment setup script before compiling the QSpace library. Customizations are available via setting <code>QS_CONFIG_ML_SH</code> environment variable pointing to a custom environment setup script.</p>"},{"location":"installation/macOS_old/","title":"Installation on macOS","text":""},{"location":"installation/macOS_old/#sec:mac_ml","title":"Install MATLAB","text":"<p>QSpace is a library running on MATLAB, so we need a MATLAB installation. For the current QSpace distribution (v4.0), we recommend to use MATLAB R2020b or later, since the provided binaries are compiled with R2020b. Older MATLAB versions might work, but no guarantee.</p> <p>Note</p> <p>MATLAB has a native Apple Silicon version since 2023b. However, the QSpace  binaries for macOS are compiled with intel x86_64 architechture. Therefore, QSpace is currently incompatible with the native Apple Silicon MATLAB. For users of MATLAB 2023b or newer, please install the version  compiled for intel processors and run the MATLAB over Rosetta 2.</p>"},{"location":"installation/macOS_old/#sec:mac_gmp","title":"Install <code>gmp</code>","text":"<p>QSpace uses <code>gmp</code>, a multiprecision arithmetics library, in generating and manipulating the Clebsch-Gordan coefficient tensors. However, a standard installation of macOS may not have <code>gmp</code> installed. If you are not sure whether it's installed in your device, type in the terminal:</p> <pre><code>brew info gmp\n</code></pre> <p>If the command works, showing the installed version of <code>gmp</code>, then you can skip the rest of this subsection and move forward to Retrieve QSpace files.</p> <p>When the command above fails, there are two possibilities.</p> <ul> <li> <p>If the terminal says <code>command not found: brew</code>, then <code>homebrew</code> is     missing. You can install <code>homebrew</code> by typing the following as a     single command in the terminal.</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Then take the next step to install <code>gmp</code>.</p> </li> <li> <p>If the terminal says \"Error: No available formula or cask\", then     <code>homebrew</code> is installed, while <code>gmp</code> is not. You can simply install     <code>gmp</code> by the terminal command</p> <pre><code>brew install gmp\n</code></pre> <p>For more information, refer to here.</p> </li> </ul>"},{"location":"installation/macOS_old/#sec:mac_qs","title":"Retrieve QSpace files","text":"<p>There is a separate Git repository for the QSpace codes for macOS. If you know how to use Git, then you can proceed with cloning the repository. If you don't know, then visit the repository webpage and click \"Clone\", which will lead you a dialogue window showing the command:</p> <pre><code>git clone https://bitbucket.org/qspace4u/qspace-v4-osx12-monterey.git\n</code></pre> <p>Then go to a directory under which the copied Git repository data will be stored. Move to the directory, and run the command above in your terminal. Then the repository will be cloned to a sub-directory under your current working directory.</p> <p>The QSpace distribution for macOS already includes pre-compiled MEX binaries (<code>.mexmaci64</code>), so the current QSpace installation is almost ready to use. (Since the MEX-compilation in macOS is a bit more involved compared to Linux, Andreas W.\u00a0kindly provides the binaries together.) The remaining step is to set environment variables and paths; see Set environment variables and paths.</p>"},{"location":"installation/macOS_old/#sec:startup","title":"Set environment variables and paths","text":""},{"location":"installation/macOS_old/#set-rc_store","title":"Set <code>RC_STORE</code>","text":"<p><code>RC_STORE</code> is the only environment variable that needs to be set by users, to execute the QSpace functions (both <code>.m</code> and <code>MEX</code>). This variable specifies the paths to place the database of Clebsch--Gordan coefficient tensor (CGT) data, which is generated and read on the fly during calculations. Those CGT data can be reused for different calculations, which provides a great computational advantage.</p> <p><code>RC_STORE</code> can be defined by multiple paths glued with <code>:</code>, e.g., <code>path1:path2:path3</code>. When there are \\(n\\) paths, then the functions look up CGT data from the first path, then the second, and so on. If the CGT data of interest are not created yet, then QSpace generates and store them in the last path. When \\(n &gt; 1\\), the paths except for the last are read-only.</p> <p>Since CGTs are used to define the symmetry multiplet basis to represent physical tensors, it is important to have consistent CGT database. Especially, when running on a computing cluster, the database consistency among different jobs is essential. Therefore, a recommended choice of <code>RC_STORE</code> for clusters is <code>path1:path2</code>, where <code>path1</code> is the path for the \"global\" database to be looked up by all cluster jobs and <code>path2</code> is a job-dependent path that refers to the \"local\" increment specific to a job. If the global database is large enough, the local increment will remain small. On the other hand, for laptops and desktops, such distinction might be an overkill; one can simply set <code>RC_STORE</code> as a single path.</p>"},{"location":"installation/macOS_old/#modify-startupm","title":"Modify <code>startup.m</code>","text":"<p><code>startup.m</code> is a script that is first executed upon starting up a MATLAB session, so that important environment variables and paths are set before use. This <code>QSpaceTutorial</code> as well as <code>MuNRG</code> have own <code>startup.m</code> that should be modified by users regarding those environment variables. Mostly such variables are for paths that depend on computing systems. Please follow the instruction in <code>startup.m</code> to set the environment variables properly.</p>"},{"location":"installation/macOS_old/#troubleshooting","title":"Troubleshooting","text":"<p>In the following, some known issues regarding QSpace and their workarounds are given.</p>"},{"location":"installation/macOS_old/#mex-files-cannot-be-opened-because-the-developer-cannot-be-verified","title":"MEX files cannot be opened because the developer cannot be verified","text":"<p>When you try to use QSpace, some higher version of macOS might complain that the developer of the MEX function binaries not verified, so it cannot run them. One can solve this issue as follows. First, type the command</p> <pre><code>sudo xattr -r -d com.apple.quarantine ~/Documents/MATLAB/QSpace_v4.0\nsudo find ~/Documents/MATLAB/QSpace_v4.0 -name \\`$\\ast$`.mexmaci64 -exec spctl \u2013add {} \\;\n</code></pre> <p>Note that the last command line is a single line so make the command as a single line if it is divided. For more information, refer to here.</p>"},{"location":"installation/macOS_old/#invalid-mex-file-library-not-loaded","title":"Invalid MEX file, Library not loaded","text":"<p>If your Mac uses the Apple silicon chip, such as the M1 or M2 chips, MATLAB might complain that the MEX files are not valid and show the following error message.</p> <pre><code>Invalid MEX-file\n\u2018~/Documents/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64\u2019:\ndlopen(~/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64, 0x0006): Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib\nReferenced from: ~/Documents/MATLAB/QSpace_v4.0/bin/getSymStates.mexa64\nReason: tried: \u2019/usr/local/opt/gmp/lib/libgmp.10.dylib\u2019 (mach-o file, but is an incompatible architecture (have \u2019arm64\u2019, need \u2019x86_64\u2019)), \u2019/usr/local/lib/libgmp.10.dylib\u2019 (mach-o file, but is an incompatible architecture (have \u2019arm64\u2019, need \u2019x86_64\u2019)), \u2019/usr/lib/libgmp.10.dylib\u2019 (no such file)`\n</code></pre> <p>It happens because the Apple silicon chips are ARM64 CPUs while the <code>MEX</code> file is compiled for a x86-64 CPU.</p> <p>To resolve this error, download the <code>gmp.zip</code> here and move the folder <code>gmp</code> to <code>~/Documents</code>. Then, type the following command.</p> <pre><code>ln -s ~/Documents/gmp /usr/local/opt/\n</code></pre> <p>This command generates a symbolic link to <code>gmp</code>. To remove the link, type the following command.</p> <pre><code>rm /usr/local/opt/gmp\n</code></pre> <p>If macOS complains that <code>libgmp.10.dylib</code> is not verified, then try the following commands on the terminal:</p> <pre><code>sudo xattr -r -d com.apple.quarantine /usr/local/opt/gmp/lib/\nsudo find /usr/local/opt/gmp/lib/ -name \\`$\\ast$`.dylib -exec spctl \u2013add {} \\;\n</code></pre> <p>If macOS still complains, go to <code>System Settings...</code> \\(\\rightarrow\\) <code>Security &amp; Privacy</code> \\(\\rightarrow\\) click 'Open Anyway' for <code>libgmp.10.dylib</code>.</p> <p> </p>"},{"location":"installation/troublesh/","title":"Frequently Encountered Errors","text":""},{"location":"installation/troublesh/#libstdcso6-version-glibcxx_3429-not-found","title":"libstdc++.so.6: version \u2018GLIBCXX_3.4.29\u2019 not found","text":"<p>This error typically indicates a mismatch between the version of the libstdc++ library included with MATLAB and the version required by the gcc compiler used. The symbol \u2018GLIBCXX_3.4.29\u2019 specifically belongs to gcc version 11, which is incompatible with the version of libstdc++ that MATLAB bundles, as it only supports up to gcc version 9. To resolve this issue, it is advised to switch to gcc version 9 when compiling the QSpace library. This ensures compatibility between MATLAB's libstdc++ and the gcc compiler, avoiding such version-related errors.</p>"},{"location":"installation/troublesh/#mex-files-cannot-be-opened-developer-cannot-be-verified","title":"MEX files cannot be opened, developer cannot be verified","text":"<p>On newer versions of macOS, you may encounter an error stating that the developer of the MEX function binaries used by QSpace cannot be verified, preventing them from running. This is due to macOS security measures that block unverified software. To resolve this, use the following terminal commands to remove the quarantine attribute from the QSpace MEX files and add them to the approved list:</p> <pre><code>sudo xattr -r -d com.apple.quarantine $OSQS\n# Use the following for intel-based Macs\nsudo find $OSQS -name '*.mexmaci64' -exec spctl --add {} \\;\n# Use the following for Apple Silicon Macs\nsudo find $OSQS -name '*.mexmaca64' -exec spctl --add {} \\;\n</code></pre> <p>Ensure that the second command is entered as a single line. This approach modifies system security settings to trust the MEX files, allowing them to be executed without further prompts. For detailed guidance and additional information, please refer to this FAQ page.</p>"},{"location":"installation/troublesh/#invalid-mex-file-library-not-loaded","title":"Invalid MEX file, Library not loaded","text":"<p>If you encountered the error showing \"Invalid MEX-file [...] Library not loaded: /path/to/libgmp.10.dylib\", followed by \"mach-o file, but is an incompatible architecture (have \u2019arm64\u2019, need \u2019x86_64\u2019)\", this indicates that QSpace is compiled for x86_64 architecture, while the gmp library is compiled for arm64 architecture.</p> <p>This issue typically happens when running intel-compiled MATLAB on an Apple Silicon Mac. The MATLAB and QSpace binaries are compiled for x86_64 architecture, while the gmp library is installed by default for arm64 architecture. In this scenario, it is recommended to install arm64-compiled MATLAB (available from MATLAB 2023b onwards) to ensure compatibility with the system architecture.</p> <p>If you still wish to use the intel-compiled MATLAB on an Apple Silicon Mac, you need to follow these steps to set up an additional Homebrew installation under the Rosetta 2 emulation layer. This allows you to manage and install packages specifically for the intel architecture on Apple Silicon Macs. Make sure that the HOMEBREW_PREFIX is set to /usr/local, otherwise you need to adjust the path to the gmp library accordingly in the compile.sh script.</p>"},{"location":"reference/NRGWilsonQS/","title":"NRGWilsonQS","text":"<pre><code>Usage: [[NRG_DATA,] info] = ...\n         NRGWilsonQS(H0, A0, Lambda, ff, FC, Z, [, gg, FL, OPTS])\n\nNRG run using (non-)Abelian symmetries for a Wilson chain of length L\nbased on the standard iterative diagonalization prescription.\n\nThe routine perfoms a quick check whether any of the inputs is complex.\nThis includes the QSpaces H0, A0, FC, FL (if preseent), or the hopping\namplitudes ff. If so, NRGWilsonQS runs in full complex arithmetic,\nthus returning complex AK and AD. The subsequent fdmNRG_QS also can\ndeal with either case. All routines use double precision throughout.\n\n   H0      impurity / starting Hamiltonian (rank-2 QSpace)\n           H0 will be diagonalized upon initialization hence does not\n           have to be diagonal on input. The resulting basis\n           transformation is multiplied onto A0.\n\n   A0      basis used for H0 in LRs order (rank-3 QSpace)\n           where the local space s(igma) must already have the\n           (equivalent) space of a Wilson site (note that A0 is used\n           to obtain the matrix elements of FC at the first iteration.\n\n   Lambda  used to rescale H_k by sqrt(Lambda); therefore this should be\n           consistent with the Lambda used to obtain ff and gg below\n\n   ff      strength of couplings along Wilson chain as they appear in\n           the physical Hamiltonian, i.e. they must not be rescaled yet,\n           as this is done automaticely based on Lambda! if ff is a vector\n           of length L-1, the coupling applies for all nearest-neighbor\n           hoppings via the FC operators in a diagonal fashion.     ^1)\n           If ff is a matrix of dimension (L-1) x Nf, the diagonal\n           hopping matrix elements can differ across the FC operators.\n           If ff is a matrix of dimension (L-1) x (Nf*Nf), this also\n           permits to encode cross-couplings FC(i)'*FC(j) in between\n           nearest-neighbor shells.\n\n           NB! The length L of the Wilson chain is deterimend by the\n           length of ff, i.e. L=length(ff)+1 by including A0.\n\n   FC      set of Nf annihilation operators used for coupling (QSpace)\n           e.g. in case of all-abelian symmetries (default) this becomes\n           H = F1'*ZF2 + F1*(ZF2)' + h.conj. (zflag=1, see below)\n           with F1=F2=FC such that this operator alway appears as \n           a bilinear together with its hermitian conjugate.  ^2)\n\n   Z       (diagonal) operator required for the calculation of the\n           fermionic hopping matrix elements (QSpace). It is defined by\n           ferminonic signs (-1)^ns required in the context as described\n           for FC above, where ns is the number of fermionic particles\n           for the local states s(igma).\nOptions\n\n   zflag   variation of how to apply the fermionic signs Z on the\n           hopping terms in the Hamilonian determined by the operators\n           FC (default: 1 e.g. as described for FC above in the context\n           of all-abelian quantum numbers). Valid settings:\n\n           0: ignore Z alltogether\n           1: H = F1'*(Z*F2) + F1*(Z*F2)' + hermitian conjugate (default)\n           2: intended for particle-hole-symmetric cases only:\n              H = (ZF1)'*(ZF2) at every second iteration only, WITHOUT\n              adding a further hermitian conjugate (already included!)\n              starting with NO Z-operators applied to A0.local (i.e.\n              same as for zflag==1), therefore starting with F1'*F1\n              at first iteration (i.e. using F1 to update operators,\n              and again F1 when building enlarged Hamiltonian.\n              For every other iteration, H = (Z*F1)'*(Z*F2) is applied\n              using Z with BOTH operators, consistent with particle-\n              hole symmetry!\n           3: same as zflag=2, but Z is applied at every other iteration\n              already starting with the very first iteration.\n\n   FL      set of Nl local operators along the chain (QSpaces [Nl])\n\n   gg      strength of local operators FL along the chain similar to ff\n           i.e. not rescaled! (double, (L-1) x Nl, not including H0)  ^1)\n           Note that local operators can always be expressed as\n           Hermitian operators, with real amplitudes gg. Hence gg is\n           always expected to be real.\n\n^1) NB! if the couplings ff (or also gg) are the same for all FC and FL,\n    they may be represented by a single vector only.\n\n^2) FC and FL are considered the same for every interation throughout\n    the Wilson chain, yet there strength is modified by ff and gg,\n    respectively.\n\nFurther options / flags\n\n 'Nkeep',. max number of states to keep at every NRG iteration (512)\n 'NKEEP',. vector that specifies Nkeep individually for first few sites\n\n 'Etrunc', use given energy threshold rather than Nkeep to trunctate\n           unless Nkeep is reached (&lt;=0 uses Nkeep only; default: 0).\n 'ETRUNC', vector that specifies Etrunc individually for first few sites\n 'ET1'     Etrunc for 1st with trunctation (default: 1.2*Etrunc)\n           if ET1&lt;0, then ET1=Etrunc is used.\n\n 'FNfac',. global factor on energy scale, i.e.\n           EScale(n) = Lambda^(-n/2) * 0.5*(Lambda+1) * FNfac.\n           (by default, FNfac is chosen such that ff(N-1)/EScale(N)=1;\n           see returned info.EScale below)\n\n 'Estop',. stop dynamically once stable fixed point is reached, i.e.\n           energies EK(1:Nkept/4) for iterations k and k+2 are the same\n           to within given value for Estop (default: 0, i.e. not used).\n '-Estop'  same as 'Estop',1E-4\n\n 'NEE',..  number of states to store for energy flow diagram (Nkeep*Ns)\n 'fout',.  store data for every site into output file &lt;fout&gt;_##.mat\n           if specified, the first RETURN argument is skipped (./NRG/NRG).\n 'deps',.. restore degeneracy within eps (1E-12)\n 'db',..   require minimum distance towards discarded energies (-1)\n           (db&lt;0 searches for maximum distance in vicinity of Nkeep)\n 'dmax'..  maximum number of extra states to include for db (Nkeep/10)\n           (mostly a safeguard in case db has been set too large).\n '-IdF'    build local Id from F-ops, fully ignoring A0 (NB! by default,\n           sigma-space of A0 is considered a proper Wilson bath site!)\n 'ionly'   info only (incl. Eflow) i.e. do not store iterative NRG data\n '-v'      verbose mode\n\nOutput\n\n NRG_DATA  MPS data (only if 'fout' was not specified; otherwise this\n           data is stored into specified file structure):\n\n  .A[KD]   states K(ept) / D(iscarded) at current NRG iteration\n           according to NRG truncation scheme (rank-3 QSpaces in LRs order)\n  .H[KD]   eigenenergies corresponding to the eigenbasis of AK/AD;\n           stored in diagonal format.\n\n info      info structure containing the following fields:\n\n  .istr    info string\n  .usage   (struct) info such as time stamp, etc.\n  .HK      rescaled energy data for energy flow diagram (QSpace vector)\n  .EE      collected eig(HK) data (purely numerical array)\n  .E0      substracted ground state energy at energy scale of iteration\n  .EK      [largest kept, lowest and largest discarded] energy for each iteration\n  .EScale  NRG energy scale used along the Wilson chain (see FNfac above)\n  .Lambda  Lambda used in the calculation (same as input)\n  .ops     (struct) operator specific data for Wilson chain (FC,Z,ff,gg,etc.)\n  .paras   (struct) technical NRG specific internal parameters\n\nAlternative usage: NRGWilsonQS('MATfilename')\nNRGWilsonQS('setup.mat' [, 'fout_tag'])\n\n   This allows to read all input parameters from given setup.mat file\n   (MatLab binary) which allows pure standalone run of NRG without\n   requiring MatLab (except for the API for binary *.mat I/O).\n\n   This way all variables and options MUST be defined by their names\n   shown above; moreover, this usage must include a specification\n   for fout_tag as all output data will be written there.\n   fout_tag is either specified as 2nd argument above, else it should\n   be defined in terms of the variable 'fout' in the parameter file\n   setup.mat (default for fout_tag: './NRG/NRG').\n\nAW (C) Apr 2006 ; May 2010 ; Nov 2014\n</code></pre>"},{"location":"reference/compactQS/","title":"compactQS","text":"<pre><code>Usage: S=compactQS([opts],'qtype',Q1,Q2,Q,A [,perm]);\n\n   reduce matrix elements of the rank-3 IROP.\n   Here A is still specified in full (dense) tensor format\n   with matrix elements given by\n\n      A(i1,i2,io) := &lt;i1|A(io)|i2&gt;\n\n   NB! this assumes the index (1,2,op) specified on the lhs!\n   The symmetry types are specified by qtype. Moreover,\n   all states i1 and i2 must be already cast into symmetry\n   eigenstate grouped into multiplets (see getSymStates.cc)\n   with q- and z-labels both present and interleaved in\n   each input state label sets Q*.\n\n   The state spaces are combined in the order (Q2+Q =&gt;Q1),\n   thus using the Clebsch Gordan coefficients (Q1,Q|Q2).\n   This is a natural order in that, Q=-1 annihilates a\n   particle on a |ket&gt; state (the annihilation operator\n   on a ket state increases charge, i.e. Q would be +1,\n   in case Q1 and Q had been combined into Q!).\n   This therefore represents a natural index order.\n\nOptions\n\n   perm  permutation to be applied to {Q1,Q2,Q} and A\n         prior to combining first two indizes into third.\n\n   '-h'  display this usage and exit\n\n(C) AW : Apr 2010 ; Jul 2011 ; Oct 2014\n</code></pre>"},{"location":"reference/contractQS/","title":"contractQS","text":"<pre><code>% function contractQS()\n\n   Contract set of QSpace tensors in a pairwise fashion\n   as described with usage #1 and #2 below. This automatically\n   also takes care of the underlying Clebsch Gordan coefficient\n   spaces if present based on X-symbols.\n\n   Each QSpace can be used as is, or as its 'conjugate' where the\n   conjugate of a QSpace A, i.e. conj(A) is defined as the QSpace\n\n    1) with all `arrows' reversed\n    2) keeping the SAME qlabels on all legs\n    3) and complex conjugation of all data{} if applicable,\n       i.e., if the (reduced) matrix elements are complex.\n\n   Because of (1), the specification of conjugate flags (`conj-flags')\n   is also important for QSpaces with all-real matrix elements.\n   For reversing individual arrows, see getIdentitQS(..,'-0').\n\nUsage #1: S=contractQS(A, ica, B, icb [, perm, OPTS ]);\n\n   Plain contraction of a single pair of QSpaces, A and B,\n   with respect to given explicitly specified  sets of\n   contraction indices ica and icb, which can be specified\n\n     - numerically (e.g. [1 2]),\n     - or as strings (e.g. '1,2', or '1 2')\n     - or as compact strings (e.g. '1,2', or '12')\n\n   The last 'compact format' is only possible / unique,\n   of course, if the tensors A and B do not have more than\n   9 legs (which basically never occurs), such that the\n   contraction indices reamin in the single digits\n   (this can be further relaxed, though, by extending the\n   digital range to letter, i.e. using a-z after 0-9).\n\n   The recommended way to specify conj-flag with usage #1\n   is together with the contraction indices in string notation!\n   For example,\n\n     contractQS(A,[1 3],B,[1 3],'conjA')  is equivalent to\n     contractQS(A,'1,3;*',B,[1 3])        is equivalent to\n     contractQS(A,'13*',B,'13')\n\n   (deprecated) options specific to usage #1:\n\n     'conjA'  use complex conjugate of A for contraction\n     'conjB'  use complex conjugate of B for contraction\n\nUsage #2: S=contractQS(A,..,{B,..,{C,..}},.. [, perm, OPTS ]);\n\n   Generalized 'cell-contraction' of tensors: when encountering\n   a cell, the content of that cell is contracted first, before\n   using its result. This allows the specification of an entire\n   patter of pairwise contractions based on a nested cell structure\n   where the lowest-level contractions are performed first.\n   An optional fully enveloping outer cell bracket at `base' level\n   as in S=contractQS({A,..,{B,..,{C,..}},..} [, perm, OPTS ])\n   is permitted, which may be used e.g., when debugging nested\n   parts of cell-contractions.\n\n   Cell contractions are furthermore based on QSpace `itags'\n   i.e. string labels for indices with up to 8chars, and which\n   are specified in QSpace.info.itags. This offers automated\n   contraction ('auto-contraction') of pairs of tensors solely\n   based on matching itags! Uusage #2 therefore does not (also)\n   allow explicit specification of contraction indices as in\n   usage #1.  Therefore itags (plus conj-flags) must be unique.\n\n   itags must always also contain individual conjugate flags\n   (this represent the bare minimum that must be specified with\n   each QSpacein v3): the conjugate flags on individual indices\n   (legs) of a tensor determine  whether that index (leg) is\n   in- or out-going, with the convention that\n\n       all out-going indices have a trailing * in their itags!\n\n   For example, an A-tensor with L(eft), R(ight), s(=local)\n   indices may have itags A.info.itags={'L','R*',s'}\n   assuming (L,R,s) index order.\n\n   In usage #2, for every operator additional optional strings\n   can be specified, appearing right after the affected tensor\n   e.g. QSpace A:\n\n     A,'*'    apply overall (complex) conjugation on given input\n              tensor A (see early comments above)\n     A,'!ij'  do not contract indices specified by ij (in compact\n              format) despite they share common matching itags.\n     A,'!ij*' both of the above in a single instruction\n              the conjugate flag '*' always trailing.\n\n     A,'ij'   [07/2023]\n     A,'ij*'  explicitly specify indices to contract\n              this is intended only for the case of degenerate itags\n              i.e., when identical itags appear on multiple legs\n              including the same conjugate flag.\n\n   itags may be set or adapted on the fly (this is performed\n   prior to the auto-contraction together wit the above directions)\n\n     X,'--op:&lt;tag&gt;[:&lt;opl=op&gt;]'\n        specify itags for given (e.g. local) operator.\n\n        The last option considers X an operator, and hence assumes\n        operator itags '&lt;tag&gt;;&lt;tag&gt;*[;opl*]' for QSpace X;\n        the default operator label is `op', but may be changed\n        by specifying a trailing ':&lt;opl&gt;' as indicated above.\n        As a safeguard, this issues a warning, if existing itags are\n        overwritten. This is relevant e.g. for local operators that\n        are applied to a very specific site with associated itag.\n\n        [11/2018] the specified &lt;tag&gt; may now also represent\n        a regular expression (regexp), recognized by non-alphabetic\n        special characters, while ignoring conj-flags (without\n        special characters, the specified &lt;tag&gt; is taken as is!).\n        This usage then searches for a matching itag in the paired\n        up QSpace (cell) in the contraction.\n\n        Ex. Consider A some QSpace with a single local index\n        that starts with `s', e.g., like 's010' for site 10;\n        then contract(A,Xloc,'-op:^s') will autocontract\n        the local operator Xloc to the correct local index in A\n        (here the regex `^s' indicates `starts with s');\n        An alternative operator itag may still be specified\n        by adding a trailing ':opl' as indicated earlier.\n\n     A,'--itag:s/pat/rep/[gi]   [07/2023]\n\n        replace/modify existing itags on the fly for a particular\n        recursive level of a cell contraction based on regular\n        expressions (regex; using ECMAScript grammar, cf. C++/regex).\n        The syntax is much analogous to perl regex.\n\n        The trailing flags enable case insensitive replacement [i]\n        and global replacement [g] of all possible matches\n        (by default, only the first match is replaced).\n\n   An adaptation of usage #2 can also be used\n   for plain sequential contractions\n\n       S=contractQS(A [,flagsA],B [,flagsB],C,... [, perm, OPTS ])\n\n   which is equivalent to\n   S=contractQS({A [,flagsA],{B [,flagsB], {C,...}}}, [,perm,OPTS ]).\n   That is, by grouping A*(B*(C*...)), sequential contractions start\n   from the right end onwards to the beginning of the specified set.\n   This structure is also permitted at any lower level inside cell\n   contractions. Non-contracted indices are always collected in the\n   order they appear in the input.\n\nThe remaining trailing OPTS are\n\n   perm  optional permutation (non-string) on the final object;\n         this permutation can be shorter than the actual rank\n         of the resulting QSpace, which then is completed as\n         an identity permutation on the remainder of indices.\n\n         By permitting the specification of indices to contract\n         also in contractions based on itags (cell-contractions)\n         there is a potential ambiguity of whether perm should\n         be interpreted as indices on the last specified tensor\n         (the latter may also be represented in compact string\n         format for better differentiation).\n\n         Hence the rules for perm to be interpreted as permutation\n         requires that (i) it is a valid permutation of length\n         r&gt;=2 to start with, and (ii) that it is in numeric format,\n         i.e., not written as compact string. Valid examples are\n         [2 1], [2 3 1], but not, e.g., 1, [2 3], or '21'.\n\n         The ambiguity above is fully circumvented when also\n         wrapping the last contraction at base level into a cell,\n         such as contractQS({A,...},perm [,'-v']) [see above],\n         in which case perm is always interpreted as permutation\n         on the overall result, irrespective of rank or whether\n         specified as numeric or compact string index. In case\n         of a string, this then also permits to specify an optional\n         conjugate flag to be applied on the overall result.\n\n   '-v'  debug mode that shows all levels of a cell contraction\n         together with the actual contractions performed\n         based on shown itags. Internally, degenerate itags are\n         frequently flagged by making use of signed characters,\n         which makes them unique and thus differentiate them.\n         When printed, flagged itags are formatted as \"&lt;itag&gt;|b\"\n         where the character `|' separates the actual itag string\n         from number b (int8 decimal) which in its binary form\n         reflects the internal flags.\n\nMixed usage of #2 and #1 is not possible.\nUsage #2 is typically recommended because auto-contraction\nmakes it far easier to contract entire networks in a single go\nwithout having to manually track and specify index locations.\n\nAW (C) May 2010-2023\n\n% -------------------------------------------------------------------- \n% CHANGE LOG\n% -------------------------------------------------------------------- \n% [07/2023] cell-contraction now also permits\n   explicit specification of index to contract for particular\n   QSpace on compact notation such as '12' equivalent to [1 2]\n   rather than just excluding indices that could be contracted\n   based on matching itags.\n\n% [07/2023] introduced '--itag:s/pat/rep/[gi]\n\n% [07/2023] replaced '-op: by '--op:'\n   yet with '-op:' still permitted for backward compatibility\n\n% -------------------------------------------------------------------- \n</code></pre>"},{"location":"reference/diagQS/","title":"diagQS","text":"<pre><code>Usage: dd=diagQS(A)\n\n   Get diagonal data of given QSpace (for rank-2 QSpaces only).\n\nWb (C) Aug 2016\n</code></pre>"},{"location":"reference/eigQS/","title":"eigQS","text":"<pre><code>Usage: [E [,I]]= eigQS(H [,opts])\n\n    Obtain eigenspectrum and eigenbasis of input 'Hamiltonian' H\n    in QSpace represenation. The eigendecomposition is split into\n    kept (K) and discarded (D) state space, as governed by the\n    truncation parameters Nkeep and Etrunc (for actual Hamiltonians)\n    or Rtrunc (for density matrices R:=H).\n\nOptions\n\n   'Nkeep',..  max. number of states to keep (default: -1 = keep all)\n   'Etrunc',.. keep states according to energy truncation criteria\n               with E&lt;=E0+Etrunc (default: &lt;=0 = ignore; note that\n               Etrunc is interpreted relative to lowest eigenvalue\n               E0 = min[eig(H)]).\n   'Rtrunc',.. keep states according to truncation criteria of\n               reduced density matrix with eig(R)&gt;Rtrunc with R:=H\n               (this is alternative to Etrunc and thus ignored by\n               default; note, furthermore, that here Rtrunc is\n               interpreted absolute, i.e. as is).\n   'deps',..   allow to keep (close to) degenerate spaces together\n               (default: 0, i.e. sharp truncation e.g. with Nkeep)\n\nOutput\n\n    E contains the full sorted eigenspectrum (1st column),\n    and in the presence of non-abelian symmetries, the overall\n    multiplet degeneracy as a 2nd column.\n\n    The output/info structure I contains the fields\n\n     .AK, .AD  for kept and discarded state space\n     .EK, .ED, for kept and discarded eigen spectrum (diag)\n     .DB       block dimension of input Hamiltonian H in terms\n               of multiplets (1st col) and states (last col).\n     .NK       actual number of kept multiplets / states.\n     .Etrunc or\n     .Rtrunc   actual truncation treshold used\n\nAWb (C) Sep 2006 ; Mar 2013 ; Aug 2015\n</code></pre>"},{"location":"reference/fdmNRG_QS/","title":"fdmNRG_QS","text":"<pre><code>Usage: [omega, A0 [,Info]] = ...\n       fdmNRG(NRG_DATA [,Inrg], B, C, Z0, [,opts])\n\n  This routine calculates arbitrary correlation function (CF)\n  in the full density matrix Numerical Renormalization Group\n  (fdm-NRG) framework at arbitrary temperature T for arbitrary\n  abelian or non-abelian symmetries.\n\n     A(w) = &lt;B||C'&gt;_w = FFT(&lt;{B(t),C'}&gt;).  (' equiv ^dagger)\n\n  If B is specified as empty [], it will be automatically assumed\n  equal to C, i.e. B=C as is the case for spectral functions;\n  anti-commutator (default) or commutator will be chosen according\n  to cflags below (see also zflags for Fermionic signs).\n\n  This routine uses data from a previous standard NRG run with\n  the result written as a matrix product state in QSpace format.\n  It must contain the state space kept (AK) as well as the one\n  thrown / discarded (AD) at every NRG iteration.\n\nSee also: NRGWilsonQS\n\nInput:\n\n  NRG_DATA   structure containing data of previous NRG run; if this\n             contains path/file, then the data will be read from the\n             files path/file_##.mat for every site (see NRGWilsonQS)\n\n   .AK       MPS state of k(ept) space (regular NRG, QSpace)\n   .AD       MPS state of t(runcated) NRG space (QSpace)\n   .HK       effective NRG eigenspectra (kept, QSpace)\n   .HD       effective NRG eigenspectra (truncated, QSpace)\n\n  Inrg       NRG info structure (required if NRG_DATA contains\n             structure; otherwise &lt;NRG_DATA&gt;_info.mat will be accessed.\n             required elements within Inrg structure / data:\n\n   .Lambda   NRG discretization parameter for the conduction band.\n             Lambda is needed to undo the energy scaling permformed\n             in obtaining the NRG data at the first place.\n\n   .EScale   energy scale fore each Wilson shell\n\n   .E0       (relative) ground state energy offsets in the same\n             energy scales as H[KD]; this is needed for evaluating\n             the correct weights of the density matrix\n\n  B,C        operators acting on the impurity used to calculate the\n             correlation between them as in A(w)=FFT(&lt;{B(t),C'}&gt;).\n\n             If the operators B or C are specified by name, they\n             will be read from workspace, and stored in NRG_DATA\n             together with the other NRG MPS data (the latter is\n             disabled by the flag `nostore')\n\n             The operators in B and C are paired up for correlation\n             functions. They are applied in the order of priority\n             (whichever fits first): L, then s, then R onto A0\n             as in &lt;NRGDATA&gt;_00 with index order LRs where L = left,\n             R = right = combined, s = local state space sigma).\n\n  Z0         Z0 operator for the space described by B and C\n             required for fermionic setup where must represent\n             Z0=(-1)^(number of particles); Z0 is directly\n             contracted onto the B and C where 'zflags' is set.\n\nOptions / Flags (default method: fDM)\n\n 'fDM'       full-density-matrix approach to CFs (default)\n 'NRho',k,   build density matrix from single iteration k\n             (for testing purposes, only)\n\n 'T',...     temperature at which correlation function is calculated;\n             default: about an order of magnitude larger than the\n             energy scale at the end of the Wilson chain\n\n 'vflag',..  more detailed output with increasing value (default: 1)\n 'partial'   store G1 and G2 separatly (e.g. for detailed balance\n             or the calculation of expectation values)\n 'nostore'   do not store operator elements of B or C with NRG_DATA\n 'locRho'    if Rho needs to be calculated it is stored in RAM only\n             and will be deleted after the program is finished\n 'noRHO'     do not calculate Rho, eg. calculate partition function\n             only (relevant with empty ops B and C only)\n 'rhoNorm',. allows to specify the weights rhoNorm explicitely\n             as input (intended for testing purposes only)\n\n 'zflags'    on which operators in &lt;B||C&gt; to apply fermionic signs Z0\n             ex. 'zflags', [ 1 0 ... ]  would apply Z0 to the first\n             but not to the second operator (default: all 0 if Z0\n             is empty, 1 otherwise).\n\n 'nlog',...  number of bins per decade for log. discretization (256)\n 'emin',...  minimum energy for omega binning (TN/1000)  ^1)\n 'emax',...  maximum energy for omega binning (10.)      ^1)\n\n^1) NB! first (last) bin contains all data below (above) emin (emax)\n\nOutput\n\n  om         omega corresponding to the energy binning [-emax,+emax]\n  A0         raw data for spectral function (i.e. discrete in om)\n\n  Info       info structure: specific fields are\n    .ver     version / mode of code\n    .T       actual temperature used\n    .rho     FDM weight distribution for given temperature\n    .RHO     reduced thermal density matrix for A0 (R-basis).\n    .Om      Omega(T) = -T*log(Z), (grand)canonical potential.\n\n    .A4      individual spectral data for each of the two\n             contributions to the (anti)commutator (hence A4 has\n             twice as many  columns as A0 above).\n\n    .a4      (1st row) integrated spectral integrals over the two\n             individual contributions to the (anti)commutator of\n             given correlator (2nd row may be ignored; it refers\n             to check w.r.t. detailed balance).\n\n    .reA0    contains Re(G(omega-&gt;0)) for the calculated correlation\n             functions. Importantly for finite temperatues, the\n             correlators with cflags!=0, i.e. susceptibilities,\n             acquire in addition to the Kramers Kronig transformation\n             (principal value integral!) also a Matsubara correction\n             for Ea==Eb, which would be skipped in the principal\n             value integral; this correction [see Hanl and AW, PRB 2014]\n             is added to the first term in the commutator.\n\n    .symfac  IROP factors for given spectral functions.\n\nALTERNATIVE USAGE\n\nfdmNRG('--mat','nrgdata', 'setup.mat' [,'B'], 'C')\n\n  B and C are the same as above (B=C if B is not specified).\n  This usage allows to read all input parameters from given MAT files\n  (MatLab binaries); all variables and options MUST be defined in\n  &lt;setup.mat&gt; by their names shown above; e.g. the operators B and\n  C are specified by their names as defined in &lt;setup.mat&gt;.\n\n  The output will be written / updated to the file set\n  `&lt;nrgdata&gt;_##.mat' and `&lt;nrgdata&gt;_info.mat'.\n\n  Output will be appended to setup.mat.\n\nSee also NRGWilsonQS.\n\nAW (C) May 2006 ; May 2010 ; Nov 2014\n</code></pre>"},{"location":"reference/fgrNRG/","title":"fgrNRG","text":"<pre><code>Usage: [[[om,] a0], Ifgr] = fgrNRG(NRG0, NRG2, Lambda, B [,C], [,opts])\n\n   full density matrix (FDM) Numerical Renormalization Group (NRG)\n   calculation for Fermi Golden Rule (FGR) rates, with extension\n   to resonanant ineleastic x-ray scattering (RIXS).\n\nFGR mode (default)\n\n   This computes the FGR spectral data (om,a0) witin the fdm-NRG\n   framework at arbitrary temperature (default T=TN^+ with N the\n   length of the Wilson chain). When Fourier tansformed, it corresponds\n   to the time-dependent correlation function [see Ifgr.Itdm.at]\n\n      a(t) = &lt; B(t)C'&gt; = tr[ rho_0 * B(t) C' ]\n\n   Here B and C are local operators acting at or in close vicinity\n   of the impurity. They are assumed to switch back and forth\n   between two disconnected sectors of Hilbert space (e.g. by the\n   presence of an (otherwise unaccounted for) valence core hole.\n   The time evolution C(t) = exp(iH0*t) C exp(-iH*t) therefore becomes\n   `mixed' with `initial' Hamiltonian H0 and final Hamiltonian,\n   iteratively diagonalized for both, NRG0 and NRG2, respetively.\n   The frequency correponds to om=E_final-E_initial.\n\n   If C is not specified or empy, it is automatically assumed\n   equal to B. This is the typical situation in FGR.\n   The inital state is determined by the full density matrix (FDM)\n   rho_0 of NRG0 at given temperature (default T ~ T_N ~ 0^+K).\n   The dynamics occurs within NRG2.\n\nInput\n\n   NRG*       (string pointer to) data of previous NRG runs;\n              if this contains &lt;path/file&gt;, then the data will be\n              read from the files &lt;path/file&gt;_##.mat files as\n              generated by NRGWilsonQS.\n\n   Lambda     NRG discretization parameter used in NRG*.\n              While EScale and E0 will be read from NRG0_info,\n              Lambda is needed for simple estimates of energy scales.\n\n   B,C        local operators, e.g. acting on the impurity.  *)\n              If operators B or C are specified by name, they will be\n              read from workspace and stored in NRG2_info\n              (this is disabled by `nostore').\n\n   NB! Note that exchanging NRG0 &lt;&gt; NRG2 and B&lt;&gt;C corresponds\n   to changing from emission to absorption spectra or vice versa.\n\nOptions / Flags\n\n  'Eoffset',. additional energy offset which affects the omega\n              binning (om-binning) only. Eoffset acts *on top* of\n              E0_final-E0_initial, which ensures that by default,\n              (Eoffset=0) omega=0 corresponds to minimal excitation\n              energy for a transition from groundstate in NRG0\n              to groundstate in NRG2 (with NRG2 considered (much)\n              higher in energy in x-ray absorption).\n\n  'T',...     temperature at which correlation function is calculated (0.)\n  'NRho', k   builds density matrix from iteration k only (cf. `DM-NRG')\n\n  'emin',...  min. energy for omega binning (TN/1000)  **)\n  'emax',...  max. energy for omega binning (10.)\n  'nlog',...  number of bins per decade for om-binning (256)\n\n  'nostore'   do not store operator matrix elements of C[12] with NRG data\n  'locRho'    if Rho needs to be calculated it is stored in RAM only\n              and will be deleted after the program is finished\n\n  'sigma',..  applies broadening in frequency domain (log.gauss)\n              NB! either alpha or sigma can be specified but not both.\n              default sigma=0.3 (with alpha ignored)\n  'alpha',..  exponential decay of energies exp(-alpha dE) [0.]\n              this applies alpha in time domain (F. Anders 2005)\n\n  'partial'   return partial data from every NRG iteration\n  'raw'       raw data only, i.e. no smoothing of data\n  'RAW'       calculates time dependent data from exact frequency data\n              i.e. without binning of energies on log. scale\n  'disp'      more detaild output (0)\n\n  'Z0',..     Z0 operator for first site (impurity) required for\n              fermionic setup where Z0=(-1)^(number of particles)\n  'zflags',.. on which operators in B.*C to apply fermionic signs Z0\n              ex. 'zflags', [ 1 0 ... ]  would apply Z0 to the first\n              but not to the second operator  (default: all 1s,\n              as typically the case for absorption/emission setups.\n\nRIXS mode\n\n   With the flag '--rixs', this routine computes disrete, i.e., binned,\n   RIXS (resonant ineleastic x-ray scattering) energy loss spetra\n   for given incomming photon energy E_inc.\n   This uses the Kramers-Heisenberg higher-order generalization of\n   Fermi golden rule.\n\n   Note on semantics: within RIXS, i(nitial) and f(inal) refer to the\n   *same* Hamiltonian, wheras it is the intermediate Hamiltonian takes\n   the role of the former H2:=H_final. With\n\n       V_if := &lt;i| B 1/[E_inc^* + E_i - H2] C' |f&gt;\n\n   the RIXS specral data would correspond, when Fourier transformed\n   into time-domain, to\n\n       R(t) = &lt; V(t)*V'&gt; = tr[ rho_0 * V(t) V' ]\n\n   thus recovering the same final form as for absorption/emission\n   spectra above. The RIXS mode requires the additional parameter\n\n   'E_inc',.. incoming photon energy E_inc = complex(omega_in, gamma);\n              this must already also include the broadening gamma\n              related to finite life-time of the core-hole due to other\n              unaccounted for relaxation processes such as Auger etc.\n\n   The returned spectra correspond to the RIXS intensity,\n   i.e., spectral intensity a0 vs. energy loss om.\n\nOutput\n\n   om, a0     binned spectral data (according to emin,emax,nlog)\n   Ifgr       info structure\n\nNotes / comments\n\n *) Alternatively, if B and C have composite structure that oct on\n    multiple sites/indices simultaneously, the operators B and C can\n    also be specified as cell arrays of QSpace vectors.\n    A given QSpace vector then, e.g., B{i}, is interpreted as the\n    sequence of operators that act like a tensor product on indices\n    L00,s00,s01,... where L00 and s00 are the `left' and local (`sigma)\n    indices of A0, respectively, and s01, etc. the local indices\n    of A01, etc. In this usage, Z0 must be already properly included\n    in B and C upon input, i.e. Z0 and zflags cannot be used.\n\n**) The bin a0(end) collects all data with omega &gt;= om(end) = emax.\n    For emin, the smallest bin a0(1) (given the logarthmic grid!)\n    contains all data where omega is exactly zero (e.g. for diagonal\n    contributions in Lehmann representation). The next smallest bin\n    a0(2) then contains all data for 0 &lt; omega &lt;= om(2).\n% \nAlternative usage:\nfgrNRG('nrgdata0','nrgdata2','setup.mat','B','C')\n\n    This reads all input parameters and options from given setup.mat\n    file. Hence the operators B and C must be specified by their name.\n    Output will be written / updated to NRG0 and NRG2,\n    with results also appended to setup.mat.\n\nSee also NRGWilsonQS, fdmNRG_QS, tdmNRG\n\nAW (C) 2008 ; RIXS 2019\n</code></pre>"},{"location":"reference/getDimQS/","title":"getDimQS","text":"<pre><code>Usage: [D[,D2]] = getDimQS(A)\n\n    get full dimension of given QSpace object.\n\n    In case of non-abelian symmetries, usage #2 returns\n    number of multipets as D, and the full state space\n    dimension as 2nd argument D2.\n\n    NB! if no second output argument (D2) is requested,\n    this routine returns D if D==D2 (e.g. which is always\n    the case of abelian symmetries) but [D;D2] if D!=D2.\n\n(C) AW : May 2006 ; Oct 2014\n</code></pre>"},{"location":"reference/getIdentityQS/","title":"getIdentityQS","text":"<pre><code>Usage 1: E=getIdentityQS(A [,i1, perm,'-[0z]']);\n\n   get plain identity operator from given QSpace.\n   corresponding to the state space on index i1 with A.\n\nOptions\n\n '-0'  this generates the 1J symbol, i.e. an identity operator\n       with all indices inward. This can be used to \"revert arrows\",\n       with the effect that the second index on E carries the\n       *dual* state space with respect to the first index.\n\n       For this reason, the respective itag, as inherited from A @ i1,\n       if non-empty, is also changed by flagging it with a trailing\n       prime ('). Therefore in order to accommodate for this additional\n       character, the itag in A @ i1 must have less than 8 chars in length.\n       This flag is considered part of the itag, hence overall\n       such a flagged itag is considered different from the original.\n       The flagging also acts like a toggle, i.e., marking an\n       itag that is flagged already, removes the trailing prime.\n\n       For readability, the QSpace display shows such `marked'\n       itags in color gray while hiding the trailing prime.\n       This behavior can be turned off by setting the environmental\n       variable QS_LOG_COLOR to zero (default: 1).\n\n '-z'  same as '-0' but without flagging the itag in E @ index 2.\n\nUsage 2: A=getIdentityQS(A [,i1 [,ta]], B [,i2 [,tb], t3, perm]);\n\n   get tensor product space of input spaces defined by\n   A and B. If i[12] is not specified, rank-2 objects\n   are assumed taking (the first) two indizes.\n\n   Default index order of the output space is (1,2,12*)\n   with the itags of A and B inherited if present.\n   An itag t3 for the combined output space (dim3) may be\n   specified. By default, a conj flag if present in t3\n   will be ignored, with the following exception:\n\n   [06/01/2019] In addition, for an input A-tensor with LRs\n   index order convention, its itags may be inherited to C\n   by specifying &lt;ta&gt; xor &lt;tb&gt; (see usage above) in the format\n   '-A[:..]' where `..' indicates extra characters to be\n   concatenated at the end of the itag for the *un*fused [LR]\n   index in A or B for &lt;ta&gt; xor &lt;tb&gt;, respectively.\n\n   For example, consider an A-tensor with itags {K01,K02*,s02},\n   and E a local identity operator without itags; then in order\n   to ensure a complete local state space, one may use\n   &gt;&gt; getIdentityQS(A,1,'-A:~',E)\n   which generates a QSpace with itags {K01,s02,K02~*}.\n   K01 is inherited from A via `A@1'; the remaining two itags\n   are derived from the remaining two itags in A;\n   therefore `A,i' must have i=1 or 2 with in LRs index order.\n   conj-flags are properly adjusted as needed.\n   Conversely, getIdentityQS(A,2,'-A:~',E)\n   generates itags {K02,s02,K01~*}, e.g. used for R-&gt;L sweep.\n\n   [08/2023] The itag t3 on the fused index may be written\n   in the flagged format '...' -&gt; '-m:...'  or  '-m!...'\n   which interprets trailing marker (') and conj (*) flags\n   in the sense described for '-m:..' here (the behavior is\n   simply reversed w.r.t. to the conjugate flag for '-m!..'):\n   When inserting an identity the fused space may already\n   refer to a particular existing itag for that leg.\n   From the perspective of the rank-3 identity A-tensor\n   generated here, if t3 has a trailing conj marker, it already\n   reflects an outgoing index, and hence can be kept. However,\n   if t3 does not have a trailing conj flag, then the identity\n   generated here effectively reverts the arrow. As such\n   it rather refers to the dual space. In order to reflect\n   this in the fused space, the itag t3 will `marked' as\n   dual state space which by QSpace convention is indicated\n   by a trailing prime (') as part of the itag, hence before\n   the conj flag. This acts as a toggle, i.e., if a trailing\n   prime is already present in t3, adding another one\n   rather removes it, instead.\n\nFinally, the output index order may be changed by specifying\na permutation perm to be applied on the final object.\nIf itag is not specified, perm must be in numerical format,\notherwise a (compact) string format is also accepted.\n\nFurther options\n\n  '-h'  display this usage and exit\n  '-v'  verbose\n\nNote that mex files do not allow to return class objects,\nhence A is returned as a QSpace structure. To get a class\nobject, use QSpace(getIdentityQS(...)), or equivalently,\nif getIdentity() is properly defined as a wrapper routine\nwithin matlab's Class/@QSpace (see MPS Pack), having a QSpace\ninput A, this may be shortended to getIdentity(A,...).\n\n(C) AW : Apr 2010 ; Oct 2014 ; May 2017\n</code></pre>"},{"location":"reference/getLocalSpace/","title":"getLocalSpace","text":"<pre><code>function [FF,..,Iout]=getLocalSpace(model [,'sym1,sym2,...',varargin])\n\n  build local model state space as specified by means of the typical\n  associated operators such as spin (S), annihilation (F), or\n  charge parity operator (Z).\n\n  The residual info structure Iout contains further operators\n  (if applicable), such as the identity operator (E), the spinor for\n  particle-hole symmetry (C3), its equivalent to the Casimir operator\n  S^2 (C2), or Q2 := (N-1)^2, with N the total particle number summed\n  over all channels, as required for isotropic Coulomb interaction.\n\nModels available\n\n   [F,Z,S,I]=getLocalSpace('FermionS',sym [,opts]);   spinful fermions\n   [F,Z,  I]=getLocalSpace('Fermion', sym [,opts]);   spinless fermions\n   [S,    I]=getLocalSpace('Spin', S      [,opts]);   spin-S operators [SU(2)]\n   [S,    I]=getLocalSpace('SUN',N        [,opts]);   SU(N) site\n   [S,    I]=getLocalSpace('SU&lt;N&gt;',       [,opts]);   same as previous\n   [S,    I]=getLocalSpace('SON',5,       [,opts]);   SO(N) site\n   [S,    I]=getLocalSpace('SO&lt;N&gt;',       [,opts]);   SO(N) site\n   [S,    I]=getLocalSpace('Sp&lt;2N&gt;',      [,opts]);   Sp(SN) site\n\nOptions\n\n  'NC',..  number of channels (fermionic systems only)\n  '-A',..  use abelian symmetry (in 'Spin' mode only)\n  '-v'     verbose mode\n\nSymmetries for sym (single string, separated by commas)\n\n  'Acharge'      abelian total charge;        Acharge(:)  *)\n  'SU2charge'    SU(2) total particle-hole;   SU2charge(:) *)\n  'Aspin'        abelian total spin\n  'SU2spin'      SU(2) total spin (S)\n  'SU2spinJ'     SU(2) total spin (J=L+S)\n  'AspinJ'       U(1) total spin (J=L+S)_z\n  'SUNchannel'   SU(N) channel symmetry\n  'SONchannel'   SO(N) channel symmetry\n  'SpNchannel'   Sp(N) particle/hole (charge) * channel symmetry\n\n*) sym(:) indicates to use given symmetry &lt;sym&gt; for each\n   of the NC channels individually.\n\nExamples\n\n three channels with particle-hole SU(2) in each channel and total spin SU(2)\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','SU2charge(:),SU2spin','NC',3,'-v');\n\n three channels with abelian charge, SU(2) spin and SU(2) channel\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin,SUNchannel','NC',3,'-v');\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin,SU3channel','-v'); same\n\n three channels with SO(N) symmetry\n so far NC=3 only since this reduces to SU(2) with integer spins\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin,SO3channel','-v');\n   --&gt; IS.L3 contains L=1 `spin opertors' in orbital space\n\n three channels with SU2spinJ symmetry (total J=L+S)\n   [FF,Z,JJ,IS]=getLocalSpace('FermionS','Acharge,SU2spinJ','NC',3,'-v');\n\n three spinless channels with SU(3) channel symmetry\n   [FF,Z,IS]=getLocalSpace('Fermion','SUNchannel','NC',3,'-v');\n\n single spin-S site\n   [S,IS]=getLocalSpace('Spin',1,'-v'); \n\n   [S,IS]=getLocalSpace('SUN',3,'-v');  same as ...\n   [S,IS]=getLocalSpace('SU3','-v');\n\nExamples with flavor groups / split channels // Wb,Feb16,18\n\n   [FF,Z,SS,IS]=getLocalSpace('FermionS','SU2spin,Acharge,SUNchannel','NC',[2 1],'-v');\n\n   [FF,Z,IS]=getLocalSpace('Fermion','Acharge,SUNchannel','NC',[2 1],'-v');\n\n   note that in the spinless case for an odd number of flavors,\n   their total charge label is taken to half-filling;\n   therefor if a group in NC has odd number nc of flavors,x\n   then the total charge labels are given by (2*nc-1).\n   getLocalSpace issues a NB/WRN in that respect.\n\nWb,Jul09,11 ; Wb,Jul30,12\n</code></pre>"},{"location":"reference/getQDimQS/","title":"getQDimQS","text":"<pre><code>Usage: [q,dd,dc] = getQDimQS(A,dim)\n\n    get dimension for every Q in QIDX for given QSpace object\n    dim is dimension to check (dim=='op' can be used to\n    consider both dimensions of an operator simultaneously)\n\nData returned\n\n    q    symmetry labels present (unique; n x nsymlabels)\n    dd   corresponding dimension of reduced data (n)\n    dc   corresponding dimension of Clebsch-Gordan (n x nsym)\n\nAW (C) Jun 2007 ; Oct 2010\n</code></pre>"},{"location":"reference/getRC/","title":"getRC","text":"<pre><code>% Usage: C=getRC(cgr [,opt])\n\n   get RCStore data as specified by input\n   Options:\n      -f  returns CGC data in double format (by default just CG reference)\n      -F  returns CGC data in multiprecision format\n\nUsage: C=getRC(&lt;sym&gt;,'--info');\n\n   return currently loaded RC data\n   specifically also &lt;sym&gt;.\n\nWb,Oct 2015 ; Nov 2016\n</code></pre>"},{"location":"reference/getSmoothSpec/","title":"getSmoothSpec","text":"<pre><code>Usage: [omega, As [,Info]] = getSmoothSpec(om, Araw, 'eps',.. [, opts])\n\n  om         omega (bins) for Araw\n  Araw       raw discrete spectral data; it may contain several set\n             in separate columns, e.g. like data for different spins\n\nOptions / Flags\n\n 'om',..     new discretized set of omega values (also returned as omega)\n 'sigma',..  sigma used in log-Gauss broadening (0.6)\n 'eps',...   smoothly replaces log-Gauss with regular Gaussian;\n             in absolute units since this routine does not know\n             anything about temperature(!). For the same reason,\n             eps must be specified (typically may choose eps=T).\n\n 'sigma2',.. Gaussian width sigma2*eps for w&lt;&lt;eps (0.5)\n 'alpha',..  shift in log-Gauss broadening\n             sigma/4: norm (=height) preserving (default)\n             sigma/2: width preserving\n\n 'func'      input data is not discrete but already function of omega\n 'nlog',..   number of bins per decade of omega scale\n             for logarithmic discretization   (128 = nlog_fdmNRG/2!)\n 'emin',..   minimum energy for omega binning (1E-8)\n 'emax',..   maximum energy for omega binning (10.)\n\n 'disp',..   verbose for disp&gt;0 (1)\n\n             Note that the first (last) bin contains all data below\n             (above) emin (emax).\nOutput\n\n   om        omega corresponding to the energy binning [-emax,+emax]\n   As        smoothened spectral function\n\nsee also fdmNRG.\nAWb (C) May 2006\n</code></pre>"},{"location":"reference/getSmoothTDM/","title":"getSmoothTDM","text":"<pre><code>Usage: [ At [,Info]] = getSmoothTDM(tt, om, Adisc [, opts])\n       [ At [,Info]] = getSmoothTDM(tt, ARAW, [, opts])\n\n  tt         discretized set of time dependent data\n  om         omega binning for Araw\n  Adisc      raw TDM data with dimensions [ nom, nop [,nnrg]]\n             with nom=length(om), nop=number of operators and,\n             optionally, nnrg the number of NRG iterations\n  ARAW       alternativly, instead of om and Adisc, the RAW data\n             returned by tdmNRG() in partial mode can be specified\n             as input\n\nOptions / Flags\n\n 'disc'      discrete data (i.e. does not require d(om) weight; default)\n 'func'      functional data (i.e. DOES require d(om) weight)\n             default: disc for rank(A)==3 and func for rank(A)==2\n '-q'        quiet mode (reduce number of log output)\n\n 'alpha',..  exponential decay of energies exp(-alpha dE) [0.]\n             this applies alpha in time domain (F. Anders 2005)\n 'sigma',..  applies broadening in frequency domain (log.gauss)\n             NB! either alpha or sigma can be specified but not both\n             default: sigma=0.1 (with alpha ignored)\n 'Lambda',.  Lambda from Wilson disretization (required with alpha)\n 'eps',...   smoothly replaces log-Gauss with regular Gaussian;\n             in absolute units since this routine does not know\n             anything about temperature(!). For the same reason,\n             eps must be specified (typically may choose eps=T).\n\n 'nlog',..   number of bins per decade of omega scale\n             for logarithmic discretization   (100)\n 'emin',..   minimum energy for omega binning (1E-8)\n 'emax',..   maximum energy for omega binning (10.)\n\n             Note that the first (last) bin contains all data below\n             (above) emin (emax).\nOutput\n\n   At        input spectral information transformed into time\n             dependent data.\n   Info      structure with additional information\n\nsee also tdmNRG.\nAW (C) Jan 2007\n</code></pre>"},{"location":"reference/getSymStates/","title":"getSymStates","text":"<pre><code>Usage #1: [U,I]=getSymStates(Sp,Sz);\n\n  get symmetry eigenstates for symmetry operations given by\n  rising operators Sp and (diagonal) z-operators Sz.\n  The order of the Sz operators determines the order of the\n  z-labels to be determined.\n\nUsage #2: [U,I]=getSymStates(SOP)\n\n  Moreover, Sp and Sz can be grouped according to each symmetry\n  by using a single vector structure Is with the mandatory\n  fields .Sp and .Sz. In this case, an empty Sp is interpreted\n  as Abelian quantum number. Eventually Sp and Sz are combined\n  into a single sequence as in usage #1.\n\n  Further optional fields\n    .type   symmetry type (in QSpace convention)\n    .qfac   applied to all z- and q-labels (scalar or vector)\n    .jmap   subsequently to qfac, applies linear transform\n            of q-labels (square matrix)\n\nOutput: symmetry eigenstates written as full matrix in U,\nand info structure I with the fields\n\n  basically reiterating the input\n    .R0    input .Sp and .Sz data\n    .type  symmetry type\n    .JMap  J-transformation used (identity if not specified)\n    .dz    number of z-operators for each symmetry\n\n  actual output data\n    .dd    dimension of irreduible multiplets generated\n    .RR    irreducible representations with qfac and jmap applied\n    .QZ    interleaved q- and z-labels.\n    .d2    dimensions of setup in QZ (non-abelian number have\n           the same number appearing twice)\n\n(C) Wb,Jul05,10\n</code></pre>"},{"location":"reference/isHConjQS/","title":"isHConjQS","text":"<pre><code>% Usage: [i,istr]=isHConjQS(A [,eps]);\n\n  check whether QSpace is hermitian within threshold eps (1E-12).\n  A must be even-rank object as hyperindex is allowed.\n\n% Wb,Aug17,06\n</code></pre>"},{"location":"reference/isIdentityCG/","title":"isIdentityCG","text":"<pre><code>Usage: i = isIdentityCG(A)\n\n    check whether QSpace A has indentity Clebsch-Gordan spaces.\n    Note that for full abelian spaces, this is always true.\n\nWb,Jan12,12\n</code></pre>"},{"location":"reference/isIdentityQS/","title":"isIdentityQS","text":"<pre><code>Usage: i = isIdentityQS(A [,eps])\n\n    check whether QSpace A represents a block-diagonal\n    identity matrix. This also checks the corresponding\n    Clebsch-Gordon spaces if any (default: eps=1E-12).\n\n(C) AW : May 2006 ; Oct 2010 ; Oct 2014\n</code></pre>"},{"location":"reference/makeUniqueQS/","title":"makeUniqueQS","text":"<pre><code>Usage: A = makeUniqueQS(A [,opts])\n\n    MEX wrapper routine for QSpace::makeUnique()\n\nOptions\n\n    -[qQ]    quite mode\n    -[vV]    verbose mode (wrt. outer multiplicity)\n\nAWb (C) Nov 2007 ; 2012\n</code></pre>"},{"location":"reference/normQS/","title":"normQS","text":"<pre><code>Usage: nrm = normQS(A)\n\n    calculates the (Frobenius) norm of given QSpace,\n    i.e. |A|^2 = norm(A)^2 = trace(A'*A), and appropriately\n    generalized to arbitray rank. In the presence of CGCs, this\n    implies |A|^2 = sum_i (|data{i}|^2 * prod_j(|cgs(i,j)|^2)).\n\n (C) AW : Jun 2010 ; Oct 2014\n</code></pre>"},{"location":"reference/orthoQS/","title":"orthoQS","text":"<pre><code>Usage #1:\n[A1,A2,[,info]] = orthoQS(PSI,idx, [,OPTS]);\n\n   Orthonormalize QSpace PSI w.r.t. given SINGLE index idx,\n   which is split off into tensor A1, connected via a trailing\n   new intermediate index with A2, i.e. PSI=A1*A2, where\n   A2 keeps its index order (i.e. index idx stays in place).\n\n   Note that the new intermediate index will typically be\n   truncated w.r.t. to singular values (see stol below).\n\n   Convention on orthonormalization direction (cf. lrdir below,\n   which is NOT specified here): A1 is ALWAYS an isometry/unitary\n   that has one in- and one out-index. This allows the new\n   intermediate index to carry the same itag as idx in PSI.\n\nUsage #2 (abelian symmetries only)\n[A1,A2,[,info]] = orthoQS(PSI,idx, lrdir [,OPTS]);\n\n   Similar to usage #1 above, except that for abelian symmetries,\n   idx may contain any number of indices consistent with PSI\n   (in constrast, for non-abelian symmetries, idx can only\n   specify a single index (or equivalently r-1 indices with\n   r the rank of PSI.\n\nUsage #3 (abelian symmetries only)\n[A1,A2,[,info]] = orthoQS(A1,A2,ic1,ic2, lrdir [,OPTS]);\n\n   Orthonormalize QSpace A1 towards index ic1 using SVD,\n   where the resulting tensor, split off from A1, is right\n   away merged with A2 at index ic2 (having lrdir='&gt;&gt;';\n   vice versa for lrdir='&lt;&lt;').\n\n   This internally connects to usage #2, in that the input tensors\n   A1 and A2 are right away contracted; e.g. for lrdir='&gt;&gt;':\n   PSI = contractQS(A1,ic1,A2,ic2);\n\nINPUT\n\n   PSI      or PSI=A1*A2, where\n   A[12]    are two nearest neighbor tensor\n   ic[12]   that share the common index specified by ic1 and ic2.\n\n   lrdir    direction of orthonormalization; this accepts the\n            following equivalent values:\n            '&gt;&gt;', 'LR', or +1 for \"left-to-right\"\n            '&lt;&lt;', 'RL', or -1 for \"right-to-left\"\nOPTIONS\n\n  'Nkeep',.. max. number of states/multiplets to keep (-1: all)\n  'Nkmin',.. min. number of states/multiplets to keep on index\n             connecting A1 to A2 (default: 0, i.e. no lower bound)\n  'stol',... absolute tolerance on SVD i.e. on sqrt(rho)\n             default: 1E-8 if Nkeep is not set, 0 otherwise.\n  'itag',... itag on newly generated index\n  '-v'       print info\n\nOUTPUT\n\n   A1[2]   orthonormalized A1[2]\n   info      info structure containing (amongst other fields)\n     .svd    vectorized sorted complete singular value data;\n             multiplicity (i.e. multiplet dimension) is specified\n             in svd(:,2) in the presence of non-abelian symmetries.\n     .svd2tr truncated weight (singular values squared).\n     .sfac   factor to reestablish the orginal norm(PSI).\n     .flag   !=0 indicating potential trouble (see .info field).\n     .DD     (multiplet) dimension of original PSI.\n     .D1     (multiplet) dimension of A1.\n\nSee also svdQS.\nAW (C) Jun 2006; Jun 2009; Aug 2015\n</code></pre>"},{"location":"reference/permuteQS/","title":"permuteQS","text":"<pre><code>Usage: A = permuteQS(A, P [,'conj'])\n\n    permute input QSpace using given permutation P.\n\n    Optional trailing 'conj' also applies (complex) conjugation\n    (note that this also affects real QSpaces in that qdir and\n    itags are altered!).\n\n    For convenience, P [,'conj'] may also be represented as\n    single string, e.g. [2 1],'conj' is equivalent to '2,1;*'\n    or '21*' where the convention on string notation\n    follows that of contraction indices [ctrIdx].\n\n    NB! [06/02/2019] the provided permutation can be shorter\n    than the rank of the QSpace; in this case it only affects the\n    leading range of indices, i.e., acts like an identity\n    on the remainder of indices.\n\nAW (C) Aug 2006 ; May 2010 ; Oct 2014\n</code></pre>"},{"location":"reference/plusQS/","title":"plusQS","text":"<pre><code>Usage: C = plusQS(A, B [, bfac, opts])\n\n    adds one QSpace to another as in C = A+bfac*B ([bfac=1])\n    block-diagonal identity matrix.\n\nOptions\n\n   '-v'  verbose mode (e.g. on remaining outer multiplicity)\n\n(C) AW : Jun 2006 ; Oct 2014\n</code></pre>"},{"location":"reference/setupRCStore/","title":"setupRCStore","text":"<pre><code>Usage #1: setupRCStore(sym [,opts])\n\n    Setup CGC container for given symmetry,\n    with the data stored in directory specified by the\n    environmental variable $RC_STORE.\n\nUsage #2: setupRCStore(sym,q1,q2 [,opts])\n\n    explicitely request to generate tensor product\n    decomposition q1*q2\n\nOptions\n\n   'npass',... number of passes through gCG data (3).\n   'dmax',...  specify max. average multiplet dimension sqrt(d1*d2)\n               in tensor product decomposition (10*qlen).\n   '-a'        generate all, yet compatible with dmax (by default,\n               multiplets with 2-digit qlabels are no longer used\n               in decomposition)\n\nWb (C) Aug 2014 ; Apr 2015\n</code></pre>"},{"location":"reference/skipZerosQS/","title":"skipZerosQS","text":"<pre><code>Usage: [A,n] = skipZerosQS(A [,eps,opts]);\n\n   skip data blocks that have all-zero entries to within eps\n   (default eps=1E-14). The total number of skipped blocks\n   is returned as 2nd argument.\n\n   For scalar (i.e. rank-2 block-diagonal) operators zero-\n   blocks are kept, by default (e.g. relevant for Hamiltonians\n   where states with energy zero are relevant states.\n   This can be disable by using the option '--all'.\n\nWb,May14,10\n</code></pre>"},{"location":"reference/svdQS/","title":"svdQS","text":"<pre><code>Usage #1:\n[U,S,Vd,[,info]] = svdQS(PSI,idx [,OPTS]);\n\n   Compute SVD decomposition of QSpace object PSI, where the\n   indices idx are split off into Vd, and the remaining indices\n   into U, which are '&gt;&gt;' and '&lt;&lt;'  orthonormalized, respectively\n   (i.e. are unitaries or isometries generated from the SVD.\n   Typically, the indices in PSI are 'all-in'.\n\n   Note that the 3rd argument returns Vd:=V' and not V,\n   i.e. already includes the dagger such that PSI = U*S*Vd\n   e.g., similar to the LAPACK convention, cf. zgesdd.\n\n   By convention, if a single index is split off, U maintains\n   the index order of PSI. For rank r=2 then, the case idx=2\n   behaves the expected way. However, for idx=1 the transpose\n   Ut=U^t is returned for U, having PSI = [Ut*S*Vd]^t =\n   contract(S*Vd,1,U,1).\n\n   For non-abelian symmetries, idx is required to be a single\n   index (or conversely, all indices but one). If PSI is grouped\n   into two sets of indices each of which has more than one index,\n   then indices need to be fused prior to calling svdQS.\n   Also, in this case of a single index specified, U always\n   resembles PSI, i.e. has the same rank and index order.\n\nUsage #2 (deprecated):\n[U,S,V',[,info]] = svdQS(A1, A2, ic1, ic2 [,OPTS]);\n\n   Compute SVD decomposition of QSpace object PSI=A1*A2,\n   where '*' stands for the contraction (A1,ic1,A2,ic2).\n   The split occurs between the remaining indices in A1\n   and the remaining indices in A2. This indices are typically\n   'all-in', while the index/indices ic1 to be contracted\n   with ic2 can have any initial orientation. There will\n   always be a single new intermediate connecting index\n   between A1 and A2.\n\nInput\n\n   PSI      or PSI=A1*A2, where\n   A[12]    are two nearest neighbor tensor\n   ic[12]   that share the common index specified by ic1 and ic2.\n\nOPTIONS\n\n  'Nkeep',.. max. number of states/multiplets to keep (-1: all)\n  'Nkmin',.. min. number of states/multiplets to keep on index\n             connecting A1 to A2 (default: 0, i.e. no lower bound)\n  'stol',... absolute tolerance on SVD i.e. on sqrt(rho)\n             default: 1E-8 if Nkeep is not set, 0 otherwise.\n  'itag',... itag on newly generated index\n  'disp'     display info to stdout\n\nOUTPUT\n\n  A1(2)   updated and properly orthonormalized A1(2)\n  info      info structure containing\n   .SVD     singular value data blocked within QS symmetry space\n   .svd     vectorized singular value data\n\nSee also orthoQS.\nAW (C) Sep 2008 ; Aug 2015\n</code></pre>"},{"location":"reference/tdmNRG/","title":"tdmNRG","text":"<pre><code>Usage: [cc [,Info]] = ...\ntdmNRG(NRG0, NRG2, Lambda, C1 [,C2], tt, [,opts])\n\n   time-dependent numerical renormalization group (NRG)\n   using the full thermal density matrix of the initial system\n   (FDM), rho_0, as starting configuration at time t=0.\n\nThis routine calculates the time evolution of local operators\nC1(t)*C2 in fDM-NRG framework at given temperature T.\n\n   cc(t) = &lt; C1(t)C2'&gt;_0 = trace( rho_0 * C1(t) * C2')\n\nWith option -fgr the initial density matrix is modified\nby the operator C2 (e.g. creation / deletion of a particle\nas in absorption / emission processes) with the\nresulting modified time evolution being\n\n   cc(t) = trace( (C2' rho_0 C2) * C1(t) )\n\nHence the operator C2 appears twice. Note, however, that\nthe projected density matrix C2' rho_0 C2 is no longer\nnormalized.\n\nThis routine uses data from two previous NRG runs with\nthe result written as matrix product state in QSpace format.\nIt must contain the state space kept (AK) as well as the one\ndiscarded (AD) at every NRG iteration.\n\nThe inital state is determined by the density matrix rho_0 of\nNRG0 at given temperature T. The time evolution is determined\nwithin NRG2.\n\nSee also: NRGWilsonQS, dmNRG, fgrNRG\n\nInput:\n\n  NRG[02]    specifies previously calclulated NRG data; if this\n             contains path/file, then the data will be read from the\n             files path/file_##.mat for every site (see NRGWilsonQS)\n\n     .AK     MPS state of k(ept) space (regular NRG, QSpace)\n     .AD     MPS state of t(runcated) NRG space (QSpace)\n     .HK     effective NRG eigenspectra (kept, QSpace)\n     .HD     effective NRG eigenspectra (truncated, QSpace)\n\n  Lambda     NRG discretization parameter for the conduction band.\n             Lambda is needed to undo the energy scaling permformed\n             in obtaining the NRG data at the first place.\n\n  C[12]      local operators, e.g. acting on the impurity\n\n  If C2 is not specified or specified as empty [], it will be\n  automatically assumed equal to the identity operator.\n\n  NB! If operators C[12] are specified by name, they will be\n  read from workspace and stored in NRG_DATA together with\n  the other NRG data (can be disabled by flag `nostore').\n\nOptions / Flags (default method: tDM)\n\n 'alpha',..  exponential decay of energies exp(-alpha dE) [0.]\n             this applies alpha in time domain (F. Anders 2005)\n 'sigma',..  applies broadening in frequency domain (log. gauss)\n             NB! either alpha or sigma can be specified but not both.\n             default: sigma=0.3 with alpha ignored.\n\n 'NRho', k   builds density matrix from iteration k only.\n 'T',...     temperature at which correlation function is calculated.\n             If not specified, the temperature T is given by the\n             energy scale towards the end of the Wilson chain.\n\n '-fgr'      run in FGR modus applying C2 twice (see above).\n\n 'nlog',...  number of bins per decade for logarithmic discretization (256)\n 'emin',...  minimum energy for omega binning (TN/1000)\n 'emax',...  maximum energy for omega binning (10.)\n\n 'nostore'   do not store operator elements of C[12] with NRG_DATA\n 'locRho'    if Rho needs to be calculated it is stored in RAM only\n             and will be deleted after the program is finished\n 'partial'   return partial data from every NRG iteration\n 'raw'       raw data only, i.e. no smoothing of data\n 'RAW'       calculates time dependent data from exact frequency data\n             i.e. without binning of energies on log. scale\n 'disp'      more detaild output (0)\n\n  Z0         Z0 operator for first site (impurity) required for\n             fermionic setup where Z0=(-1)^(number of particles)\n 'zflags'    on which operators C[12] to apply fermionic signs Z0\n             ex. 'zflags', [ 1 0 ... ]  would apply Z0 to the first\n             but not to the second operator  (default: none).\n\nNB! The first (last) bin contains all data below (above) emin (emax)\n\nOutput\n\n  cc         expectation value at times specified in tt\n  Info       info structure\n\nSee also NRGWilsonQS, fdmNRG_QS, fgrNRG\nAWb (C) Jan 2007\n</code></pre>"},{"location":"reference/traceQS/","title":"traceQS","text":"<pre><code>Usage: x = traceQS(A [,i1,i2])\n\n    trace out index set i1 with i2 of given QSpace object;\n    for even-rank A, missing index sets is interpreted as\n    full trace of indices i1=1:r/2 with iw=r/2+1:r.\n    if all indices of A are traced out, the returned x is\n    a number (QSpace otherwise).\n\nAW (C) 2006 ; 2018\n</code></pre>"},{"location":"tutorial/BasicOps/","title":"Basic Operations","text":"<p>QSpace library provides an efficient way of manipulating the tensors, in a similar way as the standard numerical arrays of MATLAB.</p> <p>First, one can generate the array of empty QSpace objects, similarly as zeros. <pre><code>M = QSpace\n</code></pre></p> M = (empty QSpace)  <pre><code>M = QSpace(3,1)\n</code></pre> M = (empty QSpace) ... M(3) = (empty QSpace)  <pre><code>size(M)\n</code></pre> ans = 1x2 \u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a01  <p>And we can add and subtract QSpace objects. <pre><code>Z\n</code></pre></p> Z =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. <pre><code>I.E\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. <pre><code>Z - I.E % minus\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. <p>Multiply a number to QSpace object. <pre><code>Z*3 % multiply number\n</code></pre></p> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ;\u00a0 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ;\u00a0 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. <p>Take complex conjugation. <pre><code>F\n</code></pre></p> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ , *, *  } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; \u00a01 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. <pre><code>conj(F) % complex conjugation\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ *, ,  } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. <pre><code>F1 = F;\nF1.data{1} = 1i;\nconj(F1)\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ *, ,  }\u00a0\u00a0\u00a0complex \u00a0data: 3-D double (232 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1i \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>We see that the complex conjugation of QSpace object flips all the leg directions (inward vs. outward) and takes the complex conjugate to the reduced matrix elements (numerical arrays in .data{..}).</p> <p>The permutation of the legs can be done by permute, which is the wrap-up routine for the binary MEX function permuteQS.</p> <pre><code>permute(F,[2 1 3]) % permute top and bottom legs \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ * , ,* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <pre><code>permute(F,'213') % equivalent expression to the above \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ * , ,* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>Also the complex conjugation can be done together with permutation, by setting the option 'conj' in the syntax of permute. Then the Hermitian conjugate, which is the combination of the complex conjugate and transpose, to the particle annihilation operator F is obtained by:</p> <pre><code>permute(F, [2 1 3],'conj') % creation operator \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *, }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <pre><code>permute(F,'213*') % equivalent expression to the above \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *, }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>That is, it becomes the particle creation operator. The tensor network diagram for this is:</p> <p> </p> <p>The Hermitian conjugation for rank-2 operator is:</p> <pre><code>permute(I.E,[2 1],'conj') \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. <p>We see that the identity operator is Hermtian:</p> <pre><code>I.E - permute(I.E,[2 1],'conj') \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. <p>Interestingly, the wrap-up function has the same name as the MATLAB bulit-in permute. Will it be a problem? Answer is no. MATLAB finds and executes a proper routine depending on the type of input variables. When it detects QSpace objects as input, it calls the routine QSpace/Class/@QSpace/permute which is the wrap-up of the MEX function QSpace/bin/permuteQS .</p> <pre><code>which permute(F) \n</code></pre> /Users/S.Lee/Documents/MATLAB/QSpace_v3/Class/@QSpace/permute.m \u00a0 % QSpace method <p>On the other hand, if we give a numeric array, then MATLAB calls the built-in function.</p> <pre><code>M = [1,2;3,4];\nwhich permute(F) \n</code></pre> built-in (/Applications/MATLAB_R220a.app/toolbox/matlab/elmat/@double/permute) \u00a0 % double method <pre><code>permute(M,[2 1]) % transpose \n</code></pre> ans =  2 x 2 \u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a0\u00a02 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a04  <p>To see the documentations for MEX functions (which are binary files stored in QSpace/bin), type in the MATLAB Command Window:</p> &gt;&gt;Name_of_MEX_function -? <p>For example, for permuteQS, type:</p> <pre><code>permuteQS   -? \n</code></pre> Usage: A = **permuteQS**(A, P [,'conj']) \u00a0\u00a0\u00a0\u00a0\u00a0permute input QSpace using given permutation P.  \u00a0\u00a0\u00a0\u00a0\u00a0Optional trailing 'conj' also applies (complex) conjugation \u00a0\u00a0\u00a0\u00a0\u00a0(note that this also affects real QSpaces in that qdir and \u00a0\u00a0\u00a0\u00a0\u00a0itags are altered!).  \u00a0\u00a0\u00a0\u00a0\u00a0For convenience, P[,'conj'] may also be represented as \u00a0\u00a0\u00a0\u00a0\u00a0single string, e.e. [2 1],'conj' is equivalent to '2,1;*' \u00a0\u00a0\u00a0\u00a0\u00a0or '21*' where the convention on string notation \u00a0\u00a0\u00a0\u00a0\u00a0follows that of contraction indices [ctrIdx]  \u00a0\u00a0\u00a0\u00a0\u00a0NB! [06/02/2019] the provided permutation can be shorter \u00a0\u00a0\u00a0\u00a0\u00a0than the rank of the QSpace; in this case it only affects the \u00a0\u00a0\u00a0\u00a0\u00a0leading range of indices, i.e., acts like an identity \u00a0\u00a0\u00a0\u00a0\u00a0on the remainder of indices.  AW (C) Aug 2006 ; May 2010 ; Oct 2014"},{"location":"tutorial/CGCoeff/","title":"Clebsch-Gordan Coefficients","text":"<p>The key idea of QSpace is to decompose the tensor into two parts, Clebsch-Gordan coefficients and reduced matrix elements, and to treat them separately. The reduced matrix elements may change depending on the system parameters, while the Clebsch-Gordan coefficients are generic. For example, two spin-1/2's should be always combined anti-symmetrically to make the spin singlet, independent of system parameters. So, once the coefficients are generated, they can be recycled for the next calculations.</p> <p>In this regard, the QSpace library generates Clebsch-Gordan coefficient data on the fly, e.g., when tensors are manipulated. The Clebsch-Gordan coefficients are tensors by themselves, and stored in a disk drive. The path to the directory in which the data is stored is saved as a MATLAB environment variable (not a shell variable) RC_STORE. To see the path, type in the MATLAB Command Window:</p> <pre><code>getenv('RC_STORE')\n</code></pre> ans = '/Users/S.Lee/data/RCStore'  <p>startup.m which we provided automatically sets the path and creates the corresponding directory, if not exists.</p> <p>The Clebsch-Gordan data generated on the fly are indexed depending on their order of appearance. Therefore, it is possible that the same Clebsch-Gordan coefficients are indexed differently, or vice versa. So manipulating (e.g., contracting) one QSpace object generated from the calculation on one machine and another QSpace objected generated from the other calculation on the other machine can lead to the inconsistency of the Clebsch-Gordan coefficients. Therefore, it is advised to generate large enough set of the Clebsch-Gordan data and use the data set for different calculations. However, for the tutorial here, this is not important: The Clebsch-Gordan coefficients relevant to this tutorial can be generated from scratch with very small computational cost.</p>"},{"location":"tutorial/Contraction/","title":"Contraction","text":"<p>The contraction of tensors can be done by contract (which is the wrap-up of MEX function contractQS). By exploiting symmetries, the contraction of QSpace objects is done for every symmetry sectors. Only the sectors of two tensors, whose quantum numbers are identical, are to be contracted. And the QSpace library automatically and seamlessly treats the contraction of the Clebsch-Gordan coefficients; we users need to only care about reduced matrix elements.</p> <p>For example, the particle number operator \\(\\hat{n} =\\sum_{\\sigma } {\\hat{f} }_{\\sigma }^{\\dagger } {\\hat{f} }_{\\sigma }\\) can be obtained by:</p> <pre><code>NF = contract(F, '1,3;*',F, '1,3') \n</code></pre> NF =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. <p>We see that the sector of quantum number [0 1]has one particle (see .data{1} is 1) and the sector of [1 0] has two (see .data{2} is 2).</p> <p>In the usage of contract, * at the end of the second input '1,3;*'means that the first input F is complex conjugated before contraction. And '1,3' in the second and fourth inputs mean that the first legs ('1' and '1' each) and the third legs ('3' and '3'each) are contracted, respectively. The tensor network diagram for this is:</p> <p> </p> <p>Here F* means the complex conjugate to F.</p> <p>By using itags, the contraction can be made simpler. For example, the number operator can be obtained by: <pre><code>F1 = F;\nF1.info.itags = { 's00', 's00*', 'op*'};\nNF = contract(F1,'!2*',F1) \n</code></pre></p> NF =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. <p>In the usage of contract here, '*' at the end of the second input  '!2*' means that the first input F is complex conjugated, and '!2' in the second input means that all the legs of the first input except the second leg are contracted to the legs of the third input, as long as their itags match. Only the pair of outward leg (e.g., with itag 's00*') and inward leg (e.g., with itag 's00') of the same name can be contracted.** Here, the first legs and the third legs have compatible itags, so they are contracted.</p> <p>Also, the contract function supports multiple contractions in a single line syntax. For example, the squared number operator \\(\\sum_{\\sigma \\sigma^{\\prime } } {\\hat{f} }_{\\sigma }^{\\dagger } {\\hat{f} }_{\\sigma } {\\hat{f} }_{\\sigma^{\\prime } }^{\\dagger } {\\hat{f} }_{\\sigma^{\\prime } }\\) can be obtained by:</p> <pre><code>N2 = contract(F1, '!2*',{F1, '!1',{F1,  '!2*',F1}});\n</code></pre> N2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. <p>In such syntax, the contraction inside the inner-most parenthesis { } is performed first, and then the contraction for the next inner-most parenthesis is done, and so on. In the above example, the parenthesis are given so that the contraction is performed over two right-most tensors, and contract the left ones iteratively. For details, type:</p> &gt;&gt; contractQS -?"},{"location":"tutorial/DrctSum/","title":"Direct Sum","text":"<p>Author: Changkai Zhang</p> <p>The direct sum of two tensors can be performed via oplus (originate from the LaTeX command for direct sum \\oplus) function. This is a QSpace built-in function available since QSpace 4.0. The oplus function takes in two tensors and an array of indices as arguments, and generate the direct sum of the two input tensors along the indices in the array.</p> <p>Next, let's take an example of the direct sum of operator \\(S_z\\) and the identity \\(I\\). This is a common operation in constructing the Matrix Product Operator for the Hamiltonian of some spin model. Operator \\(S_z\\) is a rank-3 tensor with the first two indices being physical and the last index auxiliary:</p>  Sz\u00a0=\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q:\u00a0\u00a03x\u00a0{\u00a02\u00a0x\u00a01\u00a0}\u00a0\u00a0abelian\u00a0U(1)\u00a0\u00a0operator,\u00a0\u00a0{\u00a0+--\u00a0}\u00a0\u00a0data:\u00a0\u00a03-D\u00a0double\u00a0(224)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0x\u00a02\u00a0x\u00a01\u00a0\u00a0@\u00a0norm\u00a0=\u00a00.7071\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a01x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a01\u00a0;\u00a0\u00a01\u00a0;\u00a0\u00a00\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.5\u00a0\u00a0\u00a0\u00a0\u00a02.\u00a0\u00a01x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0-1\u00a0;\u00a0-1\u00a0;\u00a0\u00a00\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-0.5  <p>The identity tensor \\(I\\) has similar structure:</p>  Id\u00a0=\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q:\u00a0\u00a03x\u00a0{\u00a02\u00a0x\u00a01\u00a0}\u00a0\u00a0abelian\u00a0U(1)\u00a0\u00a0{\u00a0+--\u00a0}\u00a0\u00a0data:\u00a0\u00a03-D\u00a0double\u00a0(224)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0x\u00a02\u00a0x\u00a01\u00a0\u00a0@\u00a0norm\u00a0=\u00a0\u221a2\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a01x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0-1\u00a0;\u00a0-1\u00a0;\u00a0\u00a00\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a0\u00a02.\u00a0\u00a01x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a01\u00a0;\u00a0\u00a01\u00a0;\u00a0\u00a00\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.  <p>Now, we can perform the direct sum along the 3rd index (auxiliary) via</p> <pre><code>M = oplus(Sz, Id, 3)\n</code></pre>  M\u00a0=\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Q:\u00a0\u00a03x\u00a0{\u00a02\u00a0x\u00a01\u00a0}\u00a0\u00a0abelian\u00a0U(1)\u00a0\u00a0operator,\u00a0\u00a0{\u00a0+--\u00a0}\u00a0\u00a0data:\u00a0\u00a03-D\u00a0double\u00a0(240)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0x\u00a02\u00a0x\u00a02\u00a0\u00a0@\u00a0norm\u00a0=\u00a01.581\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a01x1x2\u00a0\u00a0\u00a0\u00a0[\u00a0-1\u00a0;\u00a0-1\u00a0;\u00a0\u00a00\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016\u00a0b\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.\u00a0\u00a01x1x2\u00a0\u00a0\u00a0\u00a0[\u00a0\u00a01\u00a0;\u00a0\u00a01\u00a0;\u00a0\u00a00\u00a0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a016\u00a0b\u00a0  <p>We can check by looking at the data sectors of the output tensor M that the direct sum is performed correctly:</p> <pre><code>M.data{1}\n</code></pre>  ans(:,:,1)\u00a0=\u00a0\u00a0\u00a0-0.5000ans(:,:,2)\u00a0=\u00a0\u00a0\u00a0\u00a0\u00a01  <pre><code>M.data{2}\n</code></pre>  ans(:,:,1)\u00a0=\u00a0\u00a0\u00a0\u00a00.5000ans(:,:,2)\u00a0=\u00a0\u00a0\u00a0\u00a0\u00a01  <p>Finally, note that the direct sum can only be performed when the indices that are not involved come from exactly the same linear space. Otherwise, the operation may become invalid.</p>"},{"location":"tutorial/EigenDecomp/","title":"Eigen-decomposition","text":"<p>Let's construct the hopping term \\(\\sum_{\\sigma } {\\hat{f} }_{2\\sigma }^{\\dagger } {\\hat{f} }_{1\\sigma } +{\\hat{f} }_{1\\sigma }^{\\dagger } {\\hat{f} }_{2\\sigma }\\) acting on two spinful fermionic sites.</p> <pre><code>% for site s00\nF1 = F; F1.info.itags = { 's00', 's00*', 'op*'};\nE1 = I.E; E1.info.itags = { 's00', 's00*'};\n% for site s01\nF2 = F; F2.info.itags = { 's01', 's01*', 'op*'};\nE2 = I.E; E2.info.itags = { 's01', 's01*'};\nZ2 = Z; Z2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);\n\nH = contract(A, '!2*',{F1, '!1',{F2, '!2*',{Z2, '!1',A}}}) + ...\n    contract(A, '!2*',{F1, '!2*',{Z2, '!1',{F2, '!1',A}}}) + ...\n    getIdentity(A,2) * 1e-40\n</code></pre> <p>The first line of defining H means \\(\\sum_{\\sigma } {\\hat{f} }_{2\\sigma }^{\\dagger } {\\hat{f} }_{1\\sigma }\\), and the second line means its Hermitian conjugate. And in the third line, we added the identity multiplied by a small number, to let <code>H</code> have all the sectors (that amount to 16 dimensional space).</p> <pre><code>celldisp(H.data)\n</code></pre> ans{1} =  \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a00.0000   ans{3} =  \u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a00.0000   ans{4} =  \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0-1.0000 \u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a00.0000   ans{6} =  \u00a0\u00a0\u00a01.0000e-40 <p>The eigenvalues and eigenvectors of H can be obtained by eig which is the wrap-up of eigQS.</p> <pre><code>[V,D] = eig(H)\n</code></pre> V =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.  D =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (704 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06 x 10 =&gt; 10 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 F and D are QSpace objects. Each data of V is the unitary matrix whose columns are eigenvectors: <pre><code>celldisp(V.data)\n</code></pre> ans{1} =  \u00a0\u00a0\u00a01  ans{2} =  \u00a0\u00a0-0.7071\u00a0\u00a0\u00a0\u00a00.7071 \u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a00.7071   ans{3} =  \u00a0\u00a0\u00a0-0.5000\u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0\u00a0-0.5000 \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0-0.5000\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a0-0.5000   ans{4} =  \u00a0\u00a0\u00a01  ans{5} =  \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.7071 \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.7071   ans{6} =  \u00a0\u00a0\u00a01 <p>We can check the unitarity of V by</p> <pre><code>V2 = contract(V, '!2*',V);\nsameas(V2,getIdentity(A,2))\n</code></pre> ans =  logical \u00a0\u00a0\u00a01  <p>Each data of D is the row vector of eigenvalues:</p> <pre><code>celldisp(D.data)\n</code></pre> ans{1} = \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0-1.0000  ans{3} =  \u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000  ans{4} = \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0-1.0000  ans{6} = \u00a0\u00a0\u00a01.0000e-40 <p>(Quick exercise: Explain the eigenvalues.)</p> <p>To make D as an operator representing a diagonal matrix,</p> <pre><code>D2 = diag(D)\n</code></pre> V =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 <pre><code>celldisp(D2.data)\n</code></pre> ans{1} =  \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a01.0000   ans{3} =  \u00a0\u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a02.0000   ans{4} =  \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-1.0000   ans{6} =  \u00a0\u00a0\u00a01.0000e-40 <p>One may also directly use the original MEX function eigQS. <pre><code>[E,Ieig] = eigQS(H);\n</code></pre></p> <p>Note that the syntax is a bit different from the wrap-up eig. E is two-column matrix whose first column is the energy eigenvalues (sorted in ascending order) and second column indicates the multiplet dimensions (i.e., degeneracy due to non-Abelian symmetry) associated with the eigenvalues. When only the Abelian symmetries are used, E becomes a column vector, without having the second column for the multiplet dimensions.</p> <pre><code>E\n</code></pre> ans = 10x2  \u00a0\u00a0\u00a0\u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a03.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 <p>And Inrg is the struct that contains more result of the eigendecomposition, including the eigenvectors (.AK and .AT) and eigenvalues (.EK and .ET). <pre><code>Ieig\n</code></pre></p> ans = struct with fields:  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AK: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AD: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0EK: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ED: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DB: [6x2 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NK: 10 \u00a0\u00a0\u00a0Etrunc: 0 <p>Becasue of the MATLAB policy, the direct result of MEX functions should be of MATLAB built-in types, while the QSpace is the user-defined data type. Here .AK, .AT, .EK, and .ET are struct variables that are compatible with QSpace. So we wrap them up as QSpace objects:</p> <pre><code>Ieig.EK = QSpace(Ieig.EK);\nIeig.AK = QSpace(Ieig.AK);\nIeig.EK\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 <pre><code>Ieig.AK\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>We can set several options for eigQS, such as Nkeep (number of multiplets to be kept) and Etrunc (threshold energy such that the energy eigenvalues below the value are to be kept). For details, type: eigQS -?</p>"},{"location":"tutorial/Get2Know/","title":"Get to Know QSpace","text":"<p>Author: Seung-Sup Lee Re-organized by Changkai Zhang</p> <p>QSpace is a powerful tensor network library developed by Andreas Weichselbaum, a long-term colleague of our group. This library enables the generation and manipulation of tensors that respect general Abelian and non-Abelian symmetries. It consists of many MATLAB functions (.m), as well as MEX functions (.mexa64 or .mexamaci64) that are binary files written in C++. These MEX functions are used for computationally demanding jobs, such as contraction and eigendecomposition. Thus using the QSpace library can be more efficient, even without exploiting symmetries, than the bare MATLAB code!</p> <p>The Open Source QSpace project includes a standard and a community edition. The community edition is a tailored version of the standard QSpace tensor library which is part of our commitment to fostering an open, collaborative environment for scientific exploration and software development. The community edition is distinctively designed to cater to a vibrant community of developers, researchers, and academicians who are deeply invested in the advancement of tensor network algorithms for quantum lattice models.</p> <p>The goal of this tutorial is to provide the practical knowledge on using the QSpace library and understanding QSpace objects. For the details of physical and mathematical concepts (e.g., IROP, IREP), please refer to A. Weichselbaum, Ann. Phys. 327, 2972 (2012) and A. Weichselbaum, Phys. Rev. Research 2, 023385 (2020).</p>"},{"location":"tutorial/Isometries/","title":"Identity & Isometry","text":"<p>We can obtain identity operators and isometries by using getIdentity(which is the wrap-up of MEX function getIdentityQS). There are three contexts of using getIdentity.</p> <p>1. Obtain the identity operator for a given leg space.</p> <p>For example, the following provides the identity operator for the Hilbert space of the second leg of F. <pre><code>FE2 = getIdentity(F,2)\n</code></pre></p> FE2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>Note that FE2 is different from the identity operator I.E that is for the whole Hilbert space of a spinful fermionic site, since FE2 does not contain the subspace in which there is no particle (with quantum number [-1 0]).</p> <pre><code>I.E - FE2(F,2)\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2.22e-16\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. <p>2. Generate the isometry that combines the spaces of two legs.</p> <p>Let's create the isometry (so-called A tensors) which combines two local spaces (each of which spans for a spinful fermionic site) to span the product space. In this case, to distinguish different local spaces, it is advised to use itags.</p> <pre><code>E1 = I.E;\nE1.info.itags = { 's00', 's00*'};\nE2 = I.E;\nE2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2) \n</code></pre> A =  \u00a0\u00a0\u00a0\u00a0Q: 10x [2 2 1] having 'A,SU2',\u00a0\u00a0\u00a0A-matrix,\u00a0\u00a0\u00a0{ s00, s01, * }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (1200 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 x 10 =&gt; 4 x 4 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 0 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a01 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; -1 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.732\u00a0\u00a0\u00a0\u00a08. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a01 0 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 1 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>The corresponding diagram is:</p> <p> </p> <p>This isometry is left-normalized. (Quick exercise: check this!) Such isometries are the building blocks of the MPS.</p> <p>In the lecture course, the convention for ordering the legs of isometries is left-bottom-right, as A is so here. However, many functions and programs in and based on the QSpace library use different convention: left-right-bottom. The same reason, explained in the previous section on the convention differences, applies here as well. Typically the left and right legs have the largest dimensions, while the bottom leg acts on low-dimensional local space. So placing the left and right legs before the bottom leg is more practical.</p> <p>getIdentity also supports (i) setting the itag for a newly generated leg spanning the product space and (ii) permuting legs in a single line.</p> <pre><code>A = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);\n</code></pre> A =  \u00a0\u00a0\u00a0\u00a0Q: 10x [2 2 1] having 'A,SU2',\u00a0\u00a0\u00a0A-matrix,\u00a0\u00a0\u00a0{ s00, A01*, s01 }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (1200 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 x 10 =&gt; 4 x 4 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ; \u00a00 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ; -1 0 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ; \u00a01 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ; \u00a00 1 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 0 ; -1 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x3x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 2 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.732\u00a0\u00a0\u00a0\u00a08. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a01 1 ; \u00a01 0 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 1 ; \u00a00 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a02 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>Here the 5th input is the itag, and the 6th input is the permutation indices.</p> <p>3. Generate a \\(1j\\) symbol to invert the direction of the legs.</p> <p>As we have learned from the lecture, it is crucial to flip the leg directions to bring the MPS into different canonical forms (see the material for Tutorial T02a). While inverting leg directions was of mere bookkeeping purpose in the TN materials, it should be performed explicitly for the QSpace objects.</p> <p>For example, let's invert the third leg of particle annihilation operator.</p> <pre><code>F1 = F;\nF1.info.itags = { 's00', 's00*', 'op*'};\nF1\n</code></pre> F1 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00\\*, op\\* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 \u00a01 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 \u00a00 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <pre><code>I0 = getIdentity(F1,3, '-0')\n</code></pre> <p>Warning</p> <p>This behavior is different in QSpace v4.0+ and QSpace v3.2-. In versions before QSpace v3.2, the default itags are identical for both indices of the \\(1j\\) symbol. However, the two spaces that the indices belong to are mathematically dual to each other. Therefore, from QSpace v4.0+, a trailing prime will be automatically appended to the second itag. In cases where the \\(1j\\) symbol is used in pairs, e.g. invert an arrow before an SVD and invert it back afterwards, one does not need to take care of the trailing prime. While in other cases, the prime should be removed by hard-coding.</p> QSpace v4.0+QSpace v3.2- <p>I0 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ op, op' }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>I0 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ op, op }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>The generated operator I' is rank-2, and has all-in legs. By looking at the quantum numbers associated with the third leg of F1, we see that the first leg of I0 corresponds the third leg of F1. The tensor network diagram for I0 is:</p> <p> </p> <p>Here the left and right legs in solid lines are the first and second legs, respectively.</p> <p>In this diagram, we see an implicit leg drawn in dashed line, which does not appear in the display information above. This implicit leg carries all zero quantum numbers since the sum of the quantum numbers of incoming legs should be the same as the sum of those of outgoing legs (i.e., Kirchoff's law for quantum numbers). Note that the second quantum number is spin quantum number (multiplied by 2) associated with the SU(2) symmetry, and the spin quantum number for the implicit leg is zero (which means spin singlet). In other words, the Hilbert space for this implicit leg is vacuum; that's why the leg does not show up explicitly in the numerical object.</p> <p>In the space of explicit legs, the \\(1j\\) symbol behaves as unitary operation. So the tensor network state on which \\(1j\\) symbol is acted can differ from the original state. One exception is that the explicit leg to be flipped acts on one-dimensional Hilbert space, where the unitary operation reduces to a single prefactor. Therefore, in general, it is required to consider the pair of \\(1j\\) symbol and its conjugate. When a \\(1j\\) symbol is acted, then its conjugate should be introduced at some point. This notion of pair can be understood intuitively by considering implicit legs that need to be contracted at last:</p> <p> </p> <p>Let's return to the example of inverting the third leg of F1. We invert the leg by contracting the \\(1j\\) symbol.</p> <pre><code>F1I = contract(F1, '!1',I0, '!2')\n</code></pre> F1I =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00*, op }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 \u00a01 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 \u00a00 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>The resulting F1I is also an annihilation operator, but it has the inward third leg.</p> <p>For details, type: getIdentityQS -?</p>"},{"location":"tutorial/LocalOps/","title":"Generate Local Operators","text":"<p>The first step of using QSpace is to identify which symmetries in the system are to be exploited. Then we generate the tensors that respect such symmetries. The tensors for a local space (e.g., one lattice site) are generated by getLocalSpace. For example, we obtain the operators that act on a spin-1/2 site and respect SU(2) spin symmetry:</p> <pre><code>clear\n[S,I] = getLocalSpace('Spin', 1/2);\nS  % spin operator\n</code></pre> S = \u00a0\u00a0\u00a0Q:  1x [1 1 1] having 'SU2',\u00a0\u00a0\u00a0operator, \u00a0\u00a0\u00a0{ , * , * }   data:  3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 2 x 3  \u00a0\u00a0\u00a01.  1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| 2x2x3\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.225 <pre><code>I  % struct that contains various information\n</code></pre> I = struct with fields: \u00a0\u00a0\u00a0\u00a0Sloc: 0.5000 \u00a0\u00a0\u00a0\u00a0\u00a0SOP: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0sym: 'SpinS' \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0U: [2x2 double] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Is: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E: [1x1 QSpace] <pre><code>I.E  % Identity operator\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'SU2',\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414} <p>Meaning of the displayed information will be explained in the next section.</p> <p>On the other hand, the operators for one spinful fermionic site, which respect U(1) charge and SU(2) spin symmetries, are generated by:</p> <pre><code>[F,Z,S,I] = getLocalSpace('FermionS', 'Acharge,SU2spin','NC', 1);\n</code></pre> <p>Here 'FermionS' means spinful fermion, 'Acharge,SU2spin' means U(1) charge (A from Abelian) and SU(2) spin symmetries, and 'NC',1' means that there is only one channel (NC from number of channels).</p> <pre><code>F % particle annihilation operator\n</code></pre> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <pre><code>Z % fermionic sign operator\n</code></pre> Z =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0(1.414) \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 <pre><code>S % spin operator\n</code></pre> S =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0 operator, \u00a0\u00a0{  , * , * } \u00a0data: 3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 2 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ; 0 2  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.225 <pre><code>I.E % identity operator\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0(1.414) \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 <p>F and S are rank-3 tensors, since they change charge and spin quantum numbers. On the other hand, Zand I.E are rank-2 tensors, since they do not change quantum numbers; that is, they are scalars in terms of the Clebsch-Gordan coefficients.</p> <p>getLocalSpace can deal with general situations. For details, type in the MATLAB command window: 'help getLocalSpace'.</p>"},{"location":"tutorial/NormConv/","title":"Normalization Convention","text":"<p>The QSpace library has different conventions of normalizing the Clebsch-Gordan coefficients for rank-2 tensors (such as Z and I.E) and for higher-rank tensors (such as F and S).</p> <p>For rank-2 tensors, the Clebsch-Gordan coefficients are normalized so that the reduced matrix elements have immediately relevant values. The elements of the tensor D (obtained after eig) for the energy eigenvalues are indeed energy eigenvalues. <pre><code>celldisp(D.data)\n</code></pre></p> ans{1} = \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000  ans{3} =  \u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000  ans{4} = \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a01.0000  ans{6} = \u00a0\u00a0\u00a01.0000e-40 <p>Also each cell .data{..} of identity operator I.E contains the identity matrices themselves. <pre><code>celldisp(I.E.data)\n</code></pre></p> ans{1} = \u00a0\u00a0\u00a01.0000 <p>On the other hand, for higher-rank tensors, the Clebsch-Gordan coefficents are normalized so that the contraction of a tensor and its Hermitian conjugate becomes unity, when the reduced matrix elements are unity. For example, consider a rank-3 tensor which is the subspace projection of F, <pre><code>O1 = getsub(F,2)\n</code></pre></p> O1 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , *,  * }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 1 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <pre><code>O1.data{1} = 1; % make the reduced matrix to be trivial 1\n</code></pre> <p>The contraction of O1 and its Hermitian conjugate, with all the legs contracted, is equal to the squared norm of the Clebsch-Gordan coefficents, since the reduced matrix is set as trivial 1.</p> <pre><code>contract(O1, '1,2,3',O1, '1,2,3;*')\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>On the other hand, due to the different normalization convention of rank-2 tensors, the contraction of two identity operators, with all the legs contracted, becomes the Hilbert space dimension. <pre><code>contract(I.E, '1,2',I.E, '1,2;*')\n</code></pre></p> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02."},{"location":"tutorial/OuterMult/","title":"Outer Multiplicity","text":"<p>When non-Abelian symmetry is used, it is possible that there are multiple sectors with the same quantum numbers, while different sectors are indeed associated with different (orthogonal) Clebsch-Gordan coefficients. It is called outer multiplicity. One simple example is:</p> <pre><code>[S,I] = getLocalSpace( 'Spin',1/2);\nA1 = getIdentity(I.E,2,I.E,2);\nA2 = getIdentity(A1,3,I.E,2);\nA12 = contract(A1, '3',A2, '1')\n</code></pre> A12 =  \u00a0\u00a0\u00a0\u00a0Q: 3x [1 1 1 1] having 'SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , , , * }\u00a0\u00a0\u00a0 \u00a0data: 4-D double (352 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 x 3 =&gt; 2 x 2 x 2 x 8  \u00a0\u00a0\u00a0\u00a01. 1x1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a02. 1x1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a03. 1x1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x4 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 3 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. <p>The first and second sectors have the same quantum numbers! But, of course, they are orthogonal. Consider their parts:</p> <pre><code>A12a = getsub(A12,1);\nA12a.data{1} = 1;\nA12b = getsub(A12,2);\nA12b.data{1} = 1;\n</code></pre> <p>Here we replaced the reduced matrix elements (.data{..}) with ones, to focus on the Clebsch-Gordan coefficients. Then their overlap, i.e., contraction between A12a and the conjugate of A12b vanishes.</p> <pre><code>contract(A12a,'1234',A12b, '1234*');\n</code></pre> ans = (empty QSpace)  <p>On the other hand, three incoming legs (from the first to the third) look identical, so it seems that the tensor remains the same after permuting the incoming legs. But it's not! The overlap with A12a and the permutation of the first and third legs of A12a is not unity. It means that the Clebsch-Gordan coefficients can change by permuting legs.</p> <pre><code>contract(A12a,'1234',A12b, '3214*'); % note the 4th input\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.5 <p>Why? Let's draw the tensor network diagram for the first and second sectors of A12.</p> <p> </p> <p>Attached to the legs are spin quantum numbers. Fusing two \\(S=1/2\\) (two incoming legs of A1) lead to two values of spin \\(S=0\\oplus 1\\) (outgoing leg of A1). These two values can result in \\(S=1/2\\) (outgoing leg of A2) by being fused with one \\(S=1/2\\) (bottom incoming leg of A2). The outer multiplicity of A12 reflects this two different ways of having four legs of \\(S=1/2\\). In this diagram, it is clear to see that the left leg of A1 and the bottom leg of A2 are not equivalent.</p>"},{"location":"tutorial/QSpaceData/","title":"Access QSpace Data","text":"<p>The information of QSpace objects can be accessed in a similar way as for struct variables. The quantum numbers of F are accessed by: <pre><code>F.Q % cell array of quantum numbers\n</code></pre></p> ans = 1x3 cell  1 2 3 1 [-1,0;0,1] [0,1;1,0] [-1,1;-1...] <pre><code>F.Q{1} % first leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a01 <pre><code>F.Q{2} % second leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a00 <pre><code>F.Q{3} % third leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a01 <p>A m-th row of F.Q{n} indicates the quantum number of the m-th symmetry sector for the n-th leg space.</p> <p>The reduced matrix elements are accessed by: <pre><code>F.data % cell array of reduced matrix element data\n</code></pre></p> ans = 2x1 cell  1 1 -1.4142 2 -1.4142 <p><pre><code>celldisp(F.data) % display the contents of a cell array\n</code></pre> Of course, we can change the values of the data sector. For example, <pre><code>F2 = F;\nF2.data{1} = 10;\nF2\n</code></pre></p> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>Also we can set and edit the itags (index tags). The itags are saved as the cell array .info.itags. Each cell element is a char array, which should be consistent with the direction of each leg. When the itag of a leg ends with , it means that the leg is outward. Otherwise, the leg is inward. Since the original direction was in-out-out, the first itag should not include  and the second and third itags should end with *. <pre><code>F2.info.itags = {'s00','s00*','op*'}\n</code></pre> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ s00, s00* , op* } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>Here the name of the space, s00, for the first and second legs means that the legs act on the space of the local site s00. And the name op for the third leg means that it indicates the nature of the operator, not acting on the physical space.</p> <p>One can try to set the itags to be inconsistent with the original itags. Then the QSpace library detects the inconsistency in the data and gives error message.</p> <pre><code>try\n    F2.info.itags = = {'s00','s00'','op*'};\n    F2\ncatch e\n    getReport(e);\nend\n</code></pre> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2]\u00a0\u00a0 having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ s00, s00 , op* } ./clebsch.cc:3605\u00a0\u00a0 15:29:54\u00a0ERR init() got CGR QSet mismatch ./clebsch.cc:3605\u00a0\u00a015:29:54\u00a0ERR\u00a0U(1) (-1,0,-1) &lt;&gt; U(1)   <p>The itags are really useful when we treat many tensors at the same time. For example, when many tensors are contracted sequentially (as in TN/Tensor/updateLeft), tracking down the leg order at each contraction step is quite tedious job, and is often the source of bug, if one makes a mistake in counting the leg order. By using itags, however, the QSpace library performs the sanity check for the compatibility of legs, and enables the contraction multiple tensors/legs with simple syntax!</p> <p>We emphasize that one can directly edit only the reduced matrix elements (.data) and itags (.info.itags) of QSpace objects. Tinkering any other part of QSpace object may break the consistency of data; and the QSpace library detects such consistency, as you see from the above example of wrong itags.</p>"},{"location":"tutorial/QSpaceObj/","title":"Understand QSpace Objects","text":"<p>Let us now understand how to interpret the displayed information, with the example of identity operator I.E and particle annihilation operator <code>F</code>. <pre><code>I.E\n</code></pre></p> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 <p>The identity operator I.E shows that there are three symmetry sectors: [-1 0] is for empty state (no charge, no spin), [0 1] is for singly occupied doublets (one charge, total spin 1/2; doublet means for two states \\(S_z =\\pm 1/2\\)), and [1 0] is for doubly occupied state (two charges, total spin 0; the doubly occupied state for a single orbital should be spin singlet, due to Pauli exclusion principle).</p> <pre><code>F\n</code></pre> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>From top left to bottom right:</p> <ul> <li>Q: 2x [2 2 2] : first 2x means that there are two symmetry sectors. [2 2 2] means that there are three legs (so three 2's) and each leg has two quantum numbers (so 2 each). </li> <li>having 'A,SU2' : two quantum numbers are for U(1) (Abelian, so A) and SU(2) symmetries, respectively. </li> <li>operator: FF is an operator with three legs. </li> <li>{, * , * } : itag (index tag) for each leg. The itag indcates the name and the direction of legs. Here the names are not given (since it is just generated from getLocalSpace), while indicating the directions. Empty for the first leg means inward, and * for the second and third legs means outward. See the next sections for the detail of itags. </li> <li>data: 3-D double (240 bytes): the data sector (i.e. reduced matrix elements) are three-dimensional array (since FF is rank-3), and occupies 240 bytes. </li> <li>2 x 2 x 1 : Hilbert space dimension, in terms of symmetry multiplets. It means that there are 2, 2, and 1 multiplets for the first, second, and third legs, respectively. </li> <li>3 x 3 x 2 : Hilbert space dimension, in terms of bare states (not multiplets). It means that there are 3, 3, and 2 states for the first, second, and third legs, respectively. </li> <li>1. 1x1x1 | 1x2x2: The first symmetry sector (so 1.) has the reduced matrix elements as 1x1x1 array in the multiplet basis. And a single multiplet representing the sector has multiplet dimension 1x2x2, that is, the multiplet corresponds to one state for the first leg and two states for the second and third legs, respectively. </li> <li>[ -1 0 ; 0 1; -1 1 ] : Quantum numbers for each symmetry sector. Each chunk separated by ; indicates the quantum number for each leg. As we used 'Acharge,SU2spin' option for getLocalSpace, the first number for each chunk is the charge quantum number (number of charges with respect to half filling) and the second number is the spin quantum number (total spin multiplied by 2). So we see that, for this first symmetry sector, the first leg space has no charge (charge quantum number -1, since half filling has one charge), and no spin (spin quantum number 0). And the second leg space has one charge (charge quantum number 0) and total spin 1/2 (spin quantum number 1). Finally the quantum number [-1 1] of the third chunk shows how the operator FF changes quantum number; it decreases charge quantum number by 1 (since it is an annihilation operator) and it is indeed a spinor of total spin 1/2 (spin quantum number is the total spin multiplied by 2) </li> <li>-1.414 : It is the reduced matrix element for the first symmetry sector. </li> </ul>"},{"location":"tutorial/QSpace_intro/","title":"Get to Know QSpace","text":"<p>Author: Seung-Sup Lee</p> <p>QSpace is a powerful tensor network library developed by Andreas Weichselbaum, a long-term colleague of our group. This library enables the generation and manipulation of tensors that respect general Abelian and non-Abelian symmetries. It consists of many MATLAB functions (.m), as well as MEX functions (.mexa64 or .mexamaci64) that are binary files written in C++. These MEX functions are used for computationally demanding jobs, such as contraction and eigendecomposition. Thus using the QSpace library can be more efficient, even without exploiting symmetries, than the bare MATLAB code!</p> <p>The goal of this tutorial is to provide the practical knowledge on using the QSpace library and understanding QSpace objects. For the details of physical and mathematical concepts (e.g., IROP, IREP), please refer to A. Weichselbaum, Ann. Phys. 327, 2972 (2012) and A. Weichselbaum, Phys. Rev. Research 2, 023385 (2020).</p>"},{"location":"tutorial/QSpace_intro/#clebsch-gordan-coefficient-data","title":"Clebsch-Gordan coefficient data","text":"<p>The key idea of QSpace is to decompose the tensor into two parts, Clebsch-Gordan coefficients and reduced matrix elements, and to treat them separately. The reduced matrix elements may change depending on the system parameters, while the Clebsch-Gordan coefficients are generic. For example, two spin-1/2's should be always combined anti-symmetrically to make the spin singlet, independent of system parameters. So, once the coefficients are generated, they can be recycled for the next calculations.</p> <p>In this regard, the QSpace library generates Clebsch-Gordan coefficient data on the fly, e.g., when tensors are manipulated. The Clebsch-Gordan coefficients are tensors by themselves, and stored in a disk drive. The path to the directory in which the data is stored is saved as a MATLAB environment variable (not a shell variable) RC_STORE. To see the path, type in the MATLAB Command Window:</p> <pre><code>getenv('RC_STORE')\n</code></pre> <p>ans = '/Users/S.Lee/data/RCStore' </p> <p>startup.mwhich we provided automatically sets the path and creates the corresponding directory, if not exists.</p> <p>The Clebsch-Gordan data generated on the fly are indexed depending on their order of appearance. Therefore, it is possible that the same Clebsch-Gordan coefficients are indexed differently, or vice versa. So manipulating (e.g., contracting) one QSpace object generated from the calculation on one machine and another QSpace objected generated from the other calculation on the other machine can lead to the inconsistency of the Clebsch-Gordan coefficients. Therefore, it is advised to generate large enough set of the Clebsch-Gordan data and use the data set for different calculations. However, for the tutorial here, this is not important: The Clebsch-Gordan coefficients relevant to this tutorial can be generated from scratch with very small computational cost.</p>"},{"location":"tutorial/QSpace_intro/#generate-local-operators","title":"Generate local operators","text":"<p>The first step of using QSpace is to identify which symmetries in the system are to be exploited. Then we generate the tensors that respect such symmetries. The tensors for a local space (e.g., one lattice site) are generated by getLocalSpace. For example, we obtain the operators that act on a spin-1/2 site and respect SU(2) spin symmetry:</p> <pre><code>clear\n[S,I] = getLocalSpace('Spin', 1/2);\nS  % spin operator\n</code></pre> <p>S = \u00a0\u00a0\u00a0Q:  1x [1 1 1] having 'SU2',\u00a0\u00a0\u00a0operator, \u00a0\u00a0\u00a0{ , * , * }   data:  3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 2 x 3  \u00a0\u00a0\u00a01.  1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| 2x2x3\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.225 <pre><code>I  % struct that contains various information\n</code></pre></p> <p>I = struct with fields: \u00a0\u00a0\u00a0\u00a0Sloc: 0.5000 \u00a0\u00a0\u00a0\u00a0\u00a0SOP: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0sym: 'SpinS' \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0U: [2x2 double] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Is: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E: [1x1 QSpace]</p> <p><pre><code>I.E  % Identity operator\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'SU2',\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>Meaning of the displayed information will be explained in the next section.</p> <p>On the other hand, the operators for one spinful fermionic site, which respect U(1) charge and SU(2) spin symmetries, are generated by:</p> <pre><code>[F,Z,S,I] = getLocalSpace('FermionS', 'Acharge,SU2spin','NC', 1);\n</code></pre> <p>Here 'FermionS' means spinful fermion, 'Acharge,SU2spin' means U(1) charge (A from Abelian) and SU(2) spin symmetries, and 'NC',1' means that there is only one channel (NC from number of channels).</p> <p><pre><code>F % particle annihilation operator\n</code></pre> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p><pre><code>Z % fermionic sign operator\n</code></pre> Z =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0(1.414) \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01</p> <p><pre><code>S % spin operator\n</code></pre> S =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0 operator, \u00a0\u00a0{  , * , * } \u00a0data: 3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 2 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ; 0 2  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.225</p> <p><pre><code>I.E % identity operator\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0(1.414) \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01</p> <p>F and S are rank-3 tensors, since they change charge and spin quantum numbers. On the other hand, Zand I.E are rank-2 tensors, since they do not change quantum numbers; that is, they are scalars in terms of the Clebsch-Gordan coefficients.</p> <p>getLocalSpace can deal with general situations. For details, type in the MATLAB command window: 'help getLocalSpace'.</p>"},{"location":"tutorial/QSpace_intro/#differences-from-the-tn-tutorial-materials","title":"Differences from the TN tutorial materials","text":"<p>Careful readers might have realized that the syntax of getLocalSpace here is similar to that of TN/Tensor/getLocalSpace which has been used for the previous tutorials. Actually, the TN tutorial materials are designed to be consistent with the syntax convention of the QSpace library. Here by TN, I mean the tutorial materials that we have used so far during the course, whose computational routines are pure MATLAB .m files.</p> <p>There are, however, a few differences between the conventions of TN and QSpace that need to be kept in mind. </p> <p>1. The last output I of getLocalSpace in the TN material is the identity operator, while I from the QSpace function is the struct variable that contains the identity operator.</p> <p>2. The leg order convention is different. For the rank-2 tensors (e.g., identity I and fermion sign Z), the convention is the same as in the TN material.</p> <p> </p> <p>The numbers attached to the legs are the order of legs. The first (bottom) and second (top) legs are to be contracted with bra and ket states, respectively. On the other hand, the QSpace convention for the rank-3 tensors (e.g., fermion annihilation F and spin S) generated by getLocalSpace is different:</p> <p> </p> <p>Here the first and second legs have the same roles as for the rank-2 tensors, while the third leg indicates the nature of operator (e.g., spin-raising, annihilating particle of a specific spin at a specific channel). In the TN convention, the top leg is at the third place and the operator leg is at the second place.</p> <p>While the TN convention is better compatible with covariant formulation of tensors, the QSpace convention has practical advantage. Typically, the bottom and top legs of tensors can involve large dimensions. For example, consider a situation when we compute correlator of two operators acting on different sites in a one-dimensional system. We should contract the bra and ket tensors and the local operators iteratively, all the way from one site to the other. At each iteration, the dimensions of the bottom and top legs are bond dimensions, while the operator leg has small dimensions (e.g., 1 for a single spin-\\(z\\) operator and 3 for a full spin operator). Practically, it is better to place the legs of the largest dimensions to the front; then in most cases the tensors are matrices, not multi-dimensional arrays.</p> <p>3. The leg directions are incorporated in QSpace objects, while the leg directions are rather bookkeeping in the TN materials. The tensors in the TN materials are just matrices or multi-dimensional arrays that cannot bring the information of leg directions. On the other hand, since the legs of QSpace objects are associated with quantum numbers, the directions of legs (inward or outward) are crucial.</p>"},{"location":"tutorial/QSpace_intro/#understand-qspace-objects","title":"Understand QSpace objects","text":"<p>Let me explain how to interpret the displayed information, with the example of identity operator I.E and particle annihilation operator <code>F</code>. <pre><code>I.E\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01</p> <p>The identity operator I.E shows that there are three symmetry sectors: [-1 0] is for empty state (no charge, no spin), [0 1] is for singly occupied doublets (one charge, total spin 1/2; doublet means for two states \\(S_z =\\pm 1/2\\)), and [1 0] is for doubly occupied state (two charges, total spin 0; the doubly occupied state for a single orbital should be spin singlet, due to Pauli exclusion principle).</p> <p><pre><code>F\n</code></pre> F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>From top left to bottom right:</p> <ul> <li>Q: 2x [2 2 2] : first 2x means that there are two symmetry sectors. [2 2 2] means that there are three legs (so three 2's) and each leg has two quantum numbers (so 2 each). </li> <li>having 'A,SU2' : two quantum numbers are for U(1) (Abelian, so A) and SU(2) symmetries, respectively. </li> <li>operator: FF is an operator with three legs. </li> <li>{, * , * } : itag (index tag) for each leg. The itag indcates the name and the direction of legs. Here the names are not given (since it is just generated from getLocalSpace), while indicating the directions. Empty for the first leg means inward, and * for the second and third legs means outward. See the next sections for the detail of itags. </li> <li>data: 3-D double (240 bytes): the data sector (i.e. reduced matrix elements) are three-dimensional array (since FF is rank-3), and occupies 240 bytes. </li> <li>2 x 2 x 1 : Hilbert space dimension, in terms of symmetry multiplets. It means that there are 2, 2, and 1 multiplets for the first, second, and third legs, respectively. </li> <li>3 x 3 x 2 : Hilbert space dimension, in terms of bare states (not multiplets). It means that there are 3, 3, and 2 states for the first, second, and third legs, respectively. </li> <li>1. 1x1x1 | 1x2x2: The first symmetry sector (so 1.) has the reduced matrix elements as 1x1x1 array in the multiplet basis. And a single multiplet representing the sector has multiplet dimension 1x2x2, that is, the multiplet corresponds to one state for the first leg and two states for the second and third legs, respectively. </li> <li>[ -1 0 ; 0 1; -1 1 ] : Quantum numbers for each symmetry sector. Each chunk separated by ; indicates the quantum number for each leg. As we used 'Acharge,SU2spin' option for getLocalSpace, the first number for each chunk is the charge quantum number (number of charges with respect to half filling) and the second number is the spin quantum number (total spin multiplied by 2). So we see that, for this first symmetry sector, the first leg space has no charge (charge quantum number -1, since half filling has one charge), and no spin (spin quantum number 0). And the second leg space has one charge (charge quantum number 0) and total spin 1/2 (spin quantum number 1). Finally the quantum number [-1 1] of the third chunk shows how the operator FF changes quantum number; it decreases charge quantum number by 1 (since it is an annihilation operator) and it is indeed a spinor of total spin 1/2 (spin quantum number is the total spin multiplied by 2) </li> <li>-1.414 : It is the reduced matrix element for the first symmetry sector. </li> </ul>"},{"location":"tutorial/QSpace_intro/#access-data-in-qspace-objects","title":"Access data in QSpace objects","text":"<p>The information of QSpace objects can be accessed in a similar way as for struct variables. The quantum numbers of F are accessed by: <pre><code>F.Q % cell array of quantum numbers\n</code></pre></p> <p>ans = 1x3 cell  1 2 3 1 [-1,0;0,1] [0,1;1,0] [-1,1;-1...] <p></p> <p><pre><code>F.Q{1} % first leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a01 </p> <p><pre><code>F.Q{2} % second leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a00 <pre><code>F.Q{3} % third leg\n</code></pre> ans = 2x2  \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a0-1\u00a0\u00a0\u00a0\u00a0\u00a01 </p> <p>A m-th row of F.Q{n} indicates the quantum number of the m-th symmetry sector for the n-th leg space.</p> <p>The reduced matrix elements are accessed by: <pre><code>F.data % cell array of reduced matrix element data\n</code></pre></p> <p>ans = 2x1 cell  1 1 -1.4142 2 -1.4142 <p></p> <p><pre><code>celldisp(F.data) % display the contents of a cell array\n</code></pre> Of course, we can change the values of the data sector. For example, <pre><code>F2 = F;\nF2.data{1} = 10;\nF2\n</code></pre></p> <p>F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ , * , * } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>Also we can set and edit the itags (index tags). The itags are saved as the cell array .info.itags. Each cell element is a char array, which should be consistent with the direction of each leg. When the itag of a leg ends with , it means that the leg is outward. Otherwise, the leg is inward. Since the original direction was in-out-out, the first itag should not include  and the second and third itags should end with *. <p><pre><code>F2.info.itags = {'s00','s00*','op*'}\n</code></pre> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ s00, s00 , op } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>Here the name of the space, s00, for the first and second legs means that the legs act on the space of the local site s00. And the name op for the third leg means that it indicates the nature of the operator, not acting on the physical space.</p> <p>One can try to set the itags to be inconsistent with the original itags. Then the QSpace library detects the inconsistency in the data and gives error message.</p> <p><pre><code>try\n    F2.info.itags = = {'s00','s00'','op*'};\n    F2\ncatch e\n    getReport(e);\nend\n</code></pre> F2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2]\u00a0\u00a0 having 'A,SU2',\u00a0\u00a0\u00a0operator\u00a0\u00a0\u00a0{ s00, s00 , op* } ./clebsch.cc:3605\u00a0\u00a0 15:29:54\u00a0ERR init() got CGR QSet mismatch ./clebsch.cc:3605\u00a0\u00a015:29:54\u00a0ERR\u00a0U(1) (-1,0,-1) &lt;&gt; U(1)  </p> <p>The itags are really useful when we treat many tensors at the same time. For example, when many tensors are contracted sequentially (as in TN/Tensor/updateLeft), tracking down the leg order at each contraction step is quite tedious job, and is often the source of bug, if one makes a mistake in counting the leg order. By using itags, however, the QSpace library performs the sanity check for the compatibility of legs, and enables the contraction multiple tensors/legs with simple syntax!</p> <p>We emphasize that one can directly edit only the reduced matrix elements (.data) and itags (.info.itags) of QSpace objects. Tinkering any other part of QSpace object may break the consistency of data; and the QSpace library detects such consistency, as you see from the above example of wrong itags.</p>"},{"location":"tutorial/QSpace_intro/#basic-operations","title":"Basic operations","text":"<p>QSpace library provides an efficient way of manipulating the tensors, in a similar way as the standard numerical arrays of MATLAB.</p> <p>First, one can generate the array of empty QSpace objects, similarly as zeros. <pre><code>M = QSpace\n</code></pre> M = (empty QSpace)  <pre><code>M = QSpace(3,1)\n</code></pre> M = (empty QSpace) ... M(3) = (empty QSpace)  <pre><code>size(M)\n</code></pre> ans = 1x2 \u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a01 </p> <p>And we can add and subtract QSpace objects. <pre><code>Z\n</code></pre> Z =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. <pre><code>I.E\n</code></pre></p> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p> <pre><code>Z - I.E % minus\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <p>Multiply a number to QSpace object. <pre><code>Z*3 % multiply number\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0{ , * } \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ;\u00a0 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-3.\u00a0\u00a0{1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 1 0 ;\u00a0 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.</p> <p>Take complex conjugation. <pre><code>F\n</code></pre></p> <p>F =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ , *, *  } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; \u00a01 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414.</p> <p><pre><code>conj(F) % complex conjugation\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ *, ,  } \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414. \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414.</p> <pre><code>F1 = F;\nF1.data{1} = 1i;\nconj(F1)\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ *, ,  }\u00a0\u00a0\u00a0complex \u00a0data: 3-D double (232 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1i \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[\u00a0 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>We see that the complex conjugation of QSpace object flips all the leg directions (inward vs. outward) and takes the complex conjugate to the reduced matrix elements (numerical arrays in .data{..}).</p> <p>The permutation of the legs can be done by permute, which is the wrap-up routine for the binary MEX function permuteQS.</p> <pre><code>permute(F,[2 1 3]) % permute top and bottom legs \n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ * , ,* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p><pre><code>permute(F,'213') % equivalent expression to the above \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{ * , ,* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>Also the complex conjugation can be done together with permutation, by setting the option 'conj' in the syntax of permute. Then the Hermitian conjugate, which is the combination of the complex conjugate and transpose, to the particle annihilation operator F is obtained by:</p> <p><pre><code>permute(F, [2 1 3],'conj') % creation operator \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *, }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p><pre><code>permute(F,'213*') % equivalent expression to the above \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *, }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 \u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>That is, it becomes the particle creation operator. The tensor network diagram for this is:</p> <p> </p> <p>The Hermitian conjugation for rank-2 operator is:</p> <p><pre><code>permute(I.E,[2 1],'conj') \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.</p> <p>We see that the identity operator is Hermtian:</p> <p><pre><code>I.E - permute(I.E,[2 1],'conj') \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <p>Interestingly, the wrap-up function has the same name as the MATLAB bulit-in permute. Will it be a problem? Answer is no. MATLAB finds and executes a proper routine depending on the type of input variables. When it detects QSpace objects as input, it calls the routine QSpace/Class/@QSpace/permute which is the wrap-up of the MEX function QSpace/bin/permuteQS .</p> <p><pre><code>which permute(F) \n</code></pre> /Users/S.Lee/Documents/MATLAB/QSpace_v3/Class/@QSpace/permute.m \u00a0 % QSpace method</p> <p>On the other hand, if we give a numeric array, then MATLAB calls the built-in function.</p> <p><pre><code>M = [1,2;3,4];\nwhich permute(F) \n</code></pre> built-in (/Applications/MATLAB_R220a.app/toolbox/matlab/elmat/@double/permute) \u00a0 % double method</p> <p><pre><code>permute(M,[2 1]) % transpose \n</code></pre> ans =  2 x 2 \u00a0\u00a0\u00a0\u00a0\u00a01 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a0\u00a02 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a04 </p> <p>To see the documentations for MEX functions (which are binary files stored in QSpace/bin), type in the MATLAB Command Window:</p> <p>&gt;&gt;Name_of_MEX_function -?</p> <p>For example, for permuteQS, type:</p> <pre><code>permuteQS   -? \n</code></pre> <p>Usage: A = permuteQS(A, P [,'conj']) \u00a0\u00a0\u00a0\u00a0\u00a0permute input QSpace using given permutation P.  \u00a0\u00a0\u00a0\u00a0\u00a0Optional trailing 'conj' also applies (complex) conjugation \u00a0\u00a0\u00a0\u00a0\u00a0(note that this also affects real QSpaces in that qdir and \u00a0\u00a0\u00a0\u00a0\u00a0itags are altered!).  \u00a0\u00a0\u00a0\u00a0\u00a0For convenience, P[,'conj'] may also be represented as \u00a0\u00a0\u00a0\u00a0\u00a0single string, e.e. [2 1],'conj' is equivalent to '2,1;' \u00a0\u00a0\u00a0\u00a0\u00a0or '21' where the convention on string notation \u00a0\u00a0\u00a0\u00a0\u00a0follows that of contraction indices [ctrIdx]  \u00a0\u00a0\u00a0\u00a0\u00a0NB! [06/02/2019] the provided permutation can be shorter \u00a0\u00a0\u00a0\u00a0\u00a0than the rank of the QSpace; in this case it only affects the \u00a0\u00a0\u00a0\u00a0\u00a0leading range of indices, i.e., acts like an identity \u00a0\u00a0\u00a0\u00a0\u00a0on the remainder of indices.  AW (C) Aug 2006 ; May 2010 ; Oct 2014 </p>"},{"location":"tutorial/QSpace_intro/#select-subspace","title":"Select subspace","text":"<p>We can select part of symmetry sectors, by using getsub. <pre><code>I.E\n</code></pre></p> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <pre><code>getsub(I.E,2)  % select the second sector \n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{-1.414} <pre><code>getsub(I.E,[1 3])  % select the first and third sectors \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>To choose the sectors of specific quantum numbers, we can combine getsub, find, and ismember (the latter two are MATLAB built-ins.) <pre><code>getsub(I.E,find(ismember(I.E.Q{1},[0 1],'rows'))) % choose [0 1] sector \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>It can be done also with all and bsxfun. <pre><code>getsub(I.E,find(all(bsxfun(@eq,I.E.Q{1},[0 1]),2))) % the same \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p>"},{"location":"tutorial/QSpace_intro/#contraction","title":"Contraction","text":"<p>The contraction of tensors can be done by contract (which is the wrap-up of MEX function contractQS). By exploiting symmetries, the contraction of QSpace objects is done for every symmetry sectors. Only the sectors of two tensors, whose quantum numbers are identical, are to be contracted. And the QSpace library automatically and seamlessly treats the contraction of the Clebsch-Gordan coefficients; we users need to only care about reduced matrix elements.</p> <p>For example, the particle number operator \\(\\hat{n} =\\sum_{\\sigma } {\\hat{f} }_{\\sigma }^{\\dagger } {\\hat{f} }_{\\sigma }\\) can be obtained by:</p> <p><pre><code>NF = contract(F, '1,3;*',F, '1,3') \n</code></pre> NF =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p> <p>We see that the sector of quantum number [0 1]has one particle (see .data{1} is 1) and the sector of [1 0] has two (see .data{2} is 2).</p> <p>In the usage of contract, * at the end of the second input '1,3;*'means that the first input F is complex conjugated before contraction. And '1,3' in the second and fourth inputs mean that the first legs ('1' and '1' each) and the third legs ('3' and '3'each) are contracted, respectively. The tensor network diagram for this is:</p> <p> </p> <p>Here F* means the complex conjugate to F.</p> <p>By using itags, the contraction can be made simpler. For example, the number operator can be obtained by: <pre><code>F1 = F;\nF1.info.itags = { 's00', 's00*', 'op*'};\nNF = contract(F1,'!2*',F1) \n</code></pre> NF =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p> <p>In the usage of contract here, '*' at the end of the second input  '!2*' means that the first input F is complex conjugated, and '!2' in the second input means that all the legs of the first input except the second leg are contracted to the legs of the third input, as long as their itags match. Only the pair of outward leg (e.g., with itag 's00*') and inward leg (e.g., with itag 's00') of the same name can be contracted.** Here, the first legs and the third legs have compatible itags, so they are contracted.</p> <p>Also, the contract function supports multiple contractions in a single line syntax. For example, the squared number operator \\(\\sum_{\\sigma \\sigma^{\\prime } } {\\hat{f} }_{\\sigma }^{\\dagger } {\\hat{f} }_{\\sigma } {\\hat{f} }_{\\sigma^{\\prime } }^{\\dagger } {\\hat{f} }_{\\sigma^{\\prime } }\\) can be obtained by:</p> <pre><code>N2 = contract(F1, '!2*',{F1, '!1',{F1,  '!2*',F1}});\n</code></pre> <p>N2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.</p> <p>In such syntax, the contraction inside the inner-most parenthesis { } is performed first, and then the contraction for the next inner-most parenthesis is done, and so on. In the above example, the parenthesis are given so that the contraction is performed over two right-most tensors, and contract the left ones iteratively. For details, type:</p> <p>&gt;&gt; contractQS -?</p>"},{"location":"tutorial/QSpace_intro/#rank-2-tensors","title":"Rank-2 tensors","text":"<p>Rank-2 tensors are of the simplest type. (Quick exercise: Why not rank-1?) They are scalar in terms of Clebsch-Gordan coefficients and there is no (outer) multiplicity of symmetry sectors. And their reduced matrix elements form matrices.</p> <p>So the QSpace library enables to treat rank-2 QSpace objects, in a way that usual matrices are treated by MATLAB built-in functions.</p> <pre><code>Z.'  % transpose\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <pre><code>Z'  % Hermitian conjugate\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p><pre><code>Z' - Z  % Z is Hermitian\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <pre><code>Z * I.E  % matrix multiplication as contraction\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>As in the case of permute explained above, MATLAB can execute different functions depending on the type of inputs. That is, there are several QSpace functions that override the MATLAB built-in functions.</p> <p>This simplification also works for some rank-3 tensors (whose .info.otype is set as 'operator'').</p> <pre><code>F  % Hermitian conjugate, the result is particle creation operators\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *,  }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>However, it is advisable to use permute and  contract in general, to avoid any mistake.</p>"},{"location":"tutorial/QSpace_intro/#vacuum-space","title":"Vacuum space","text":"<p>The left end and the right end of the matrix product states (MPS) are dummy legs of dimension 1. These dummy legs are introduced to represent all the constituent tensors (so-called A and B tensors) as being rank-3. Thus the dummy legs point to the space which has nothing, i.e., vacuum. The vacuum space carries no quantum number at all, and it is different from the empty state which has specific quantum number. The vacuum space for given set of symmetries is obtained by using getvac:</p> <p><pre><code>getvac(I.E)\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 1 x 1  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 0 ; 0 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p>"},{"location":"tutorial/QSpace_intro/#generate-identity-operators-and-isometries","title":"Generate identity operators and isometries","text":"<p>We can obtain identity operators and isometries by using getIdentity(which is the wrap-up of MEX function getIdentityQS). There are three contexts of using getIdentity.</p> <p>1. Obtain the identity operator for a given leg space.</p> <p>For example, the following provides the identity operator for the Hilbert space of the second leg of F. <pre><code>FE2 = getIdentity(F,2)\n</code></pre></p> <p>FE2 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 3 x 3  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; 1 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>Note that FE2 is different from the identity operator I.E that is for the whole Hilbert space of a spinful fermionic site, since FE2 does not contain the subspace in which there is no particle (with quantum number [-1 0]).</p> <pre><code>I.E - FE2(F,2)\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2.22e-16\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.</p> <p>2. Generate the isometry that combines the spaces of two legs.</p> <p>Let's create the isometry (so-called A tensors) which combines two local spaces (each of which spans for a spinful fermionic site) to span the product space. In this case, to distinguish different local spaces, it is advised to use itags.</p> <pre><code>E1 = I.E;\nE1.info.itags = { 's00', 's00*'};\nE2 = I.E;\nE2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2) \n</code></pre> <p>A =  \u00a0\u00a0\u00a0\u00a0Q: 10x [2 2 1] having 'A,SU2',\u00a0\u00a0\u00a0A-matrix,\u00a0\u00a0\u00a0{ s00, s01, * }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (1200 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 x 10 =&gt; 4 x 4 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 0 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a01 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06. 1x1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; -1 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.732\u00a0\u00a0\u00a0\u00a08. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a01 0 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09. 1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 1 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. </p> <p>The corresponding diagram is:</p> <p> </p> <p>This isometry is left-normalized. (Quick exercise: check this!) Such isometries are the building blocks of the MPS.</p> <p>In the lecture course, the convention for ordering the legs of isometries is left-bottom-right, as A is so here. However, many functions and programs in and based on the QSpace library use different convention: left-right-bottom. The same reason, explained in the previous section on the convention differences, applies here as well. Typically the left and right legs have the largest dimensions, while the bottom leg acts on low-dimensional local space. So placing the left and right legs before the bottom leg is more practical.</p> <p>getIdentity also supports (i) setting the itag for a newly generated leg spanning the product space and (ii) permuting legs in a single line.</p> <pre><code>A = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);\n</code></pre> <p>A =  \u00a0\u00a0\u00a0\u00a0Q: 10x [2 2 1] having 'A,SU2',\u00a0\u00a0\u00a0A-matrix,\u00a0\u00a0\u00a0{ s00, A01*, s01 }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (1200 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 x 10 =&gt; 4 x 4 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ; \u00a00 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ; -1 0 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ; \u00a01 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ; \u00a00 1 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06. 1x3x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 0 ; -1 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x3x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 2 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.732\u00a0\u00a0\u00a0\u00a08. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a01 1 ; \u00a01 0 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09. 1x2x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 1 ; \u00a00 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a02 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. </p> <p>Here the 5th input is the itag, and the 6th input is the permutation indices.</p> <p>3. Generate a \\(1j\\) symbol to invert the direction of the legs.</p> <p>As we have learned from the lecture, it is crucial to flip the leg directions to bring the MPS into different canonical forms (see the material for Tutorial T02a). While inverting leg directions was of mere bookkeeping purpose in the TN materials, it should be performed explicitly for the QSpace objects.</p> <p>For example, let's invert the third leg of particle annihilation operator.</p> <pre><code>F1 = F;\nF1.info.itags = { 's00', 's00*', 'op*'};\nF1\n</code></pre> <p>F1 =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00*, op* }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 \u00a01 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 \u00a00 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <pre><code>I0 = getIdentity(F1,3, '-0')\n</code></pre> <p>Warning</p> <p>This behavior is different in QSpace v4.0+ and QSpace v3.2-. In versions before QSpace v3.2, the default itags are identical for both indices of the \\(1j\\) symbol. However, the two spaces that the indices belong to are mathematically dual to each other. Therefore, from QSpace v4.0+, a trailing prime will be automatically appended to the second itag. In cases where the \\(1j\\) symbol is used in pairs, e.g. invert an arrow before an SVD and invert it back afterwards, one does not need to take care of the trailing prime. While in other cases, the prime should be removed by hard-coding.</p> QSpace v4.0+QSpace v3.2- <p>I0 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ op, op' }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>I0 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ op, op }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>The generated operator I' is rank-2, and has all-in legs. By looking at the quantum numbers associated with the third leg of F1, we see that the first leg of I0 corresponds the third leg of F1. The tensor network diagram for I0 is:</p> <p> </p> <p>Here the left and right legs in solid lines are the first and second legs, respectively.</p> <p>In this diagram, we see an implicit leg drawn in dashed line, which does not appear in the display information above. This implicit leg carries all zero quantum numbers since the sum of the quantum numbers of incoming legs should be the same as the sum of those of outgoing legs (i.e., Kirchoff's law for quantum numbers). Note that the second quantum number is spin quantum number (multiplied by 2) associated with the SU(2) symmetry, and the spin quantum number for the implicit leg is zero (which means spin singlet). In other words, the Hilbert space for this implicit leg is vacuum; that's why the leg does not show up explicitly in the numerical object.</p> <p>In the space of explicit legs, the \\(1j\\) symbol behaves as unitary operation. So the tensor network state on which \\(1j\\) symbol is acted can differ from the original state. One exception is that the explicit leg to be flipped acts on one-dimensional Hilbert space, where the unitary operation reduces to a single prefactor. Therefore, in general, it is required to consider the pair of \\(1j\\) symbol and its conjugate. When a \\(1j\\) symbol is acted, then its conjugate should be introduced at some point. This notion of pair can be understood intuitively by considering implicit legs that need to be contracted at last:</p> <p> </p> <p>Let's return to the example of inverting the third leg of F1. We invert the leg by contracting the \\(1j\\) symbol.</p> <pre><code>F1I = contract(F1, '!1',I0, '!2')\n</code></pre> <p>F1I =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00*, op }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; 0 \u00a01 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; 1 \u00a00 ; 1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <p>The resulting F1I is also an annihilation operator, but it has the inward third leg.</p> <p>For details, type: getIdentityQS -?</p>"},{"location":"tutorial/QSpace_intro/#automatic-truncation-of-all-zero-sectors","title":"Automatic truncation of all-zero sectors","text":"<p>The contract (and some other functions) of the QSpace library may remove the sectors whose reduced matrix elements (elements of .data{..}) are all zeros. For example, consider the following case. <pre><code>[F,Z,S,I] = getLocalSpace( 'FermionS', 'Acharge', 'SU2spin', 'NC',1);\nM1 = I.E; M1.info.itags = { 's00', 's00*'};\nM2 = I.E; M2.info.itags = { 's01', 's01*'};\nA = getIdentity(M1,2,M2,2, 'A01*',[1 3 2]);\ncontract(A, '!2*',{M1, '!1',{M2, '!1',A}})\n</code></pre></p> <p>A =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>This is the normal contraction of the identity tensors. The result acts on 16-dimensional space of two spinful fermionic sites.</p> <p>What happens if we replace one sector of A with all-zero reduced matrix elements?</p> <p><pre><code>A.data{1} = zeros(size(A.data{1}));\ncontract(A, '!2*',{M1, '!1',{M2, '!1',A}});\n</code></pre> A =  \u00a0\u00a0\u00a0\u00a0Q: 5x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (672 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09 x 9 =&gt; 15 x 15  \u00a0\u00a0\u00a0\u00a01. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a04. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a05. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. </p> <p>Then we have the sector [-2 0] is missing, and the result acts on 15-dimensional space.</p> <p>It is an intended feature rather than a bug. When contract tensors over the tensor network, the all-zero sectors in the constituent tensors do not contribute to the result. So the truncation of such all-zero sectors yields better computational efficiency.</p> <p>However, when we consider the Hamiltonian in effective basis, the Hamiltonian may have the sectors of all zero matrix elements, and such sectors should be kept. All the energy eigenvalues, whether zero or finite, have meaning! For this, we should enforce to keep all-zero sectors. One trick is to add the identity operator, multiplied by very small number smaller than double precision (e.g., \\(10^{-30}\\)), to the Hamiltonian. Such small number should not change the physical results, but prevents unwanted truncation.</p>"},{"location":"tutorial/QSpace_intro/#eigendecomposition","title":"Eigendecomposition","text":"<p>Let's construct the hopping term \\(\\sum_{\\sigma } {\\hat{f} }_{2\\sigma }^{\\dagger } {\\hat{f} }_{1\\sigma } +{\\hat{f} }_{1\\sigma }^{\\dagger } {\\hat{f} }_{2\\sigma }\\) acting on two spinful fermionic sites.</p> <pre><code>% for site s00\nF1 = F; F1.info.itags = { 's00', 's00*', 'op*'};\nE1 = I.E; E1.info.itags = { 's00', 's00*'};\n% for site s01\nF2 = F; F2.info.itags = { 's01', 's01*', 'op*'};\nE2 = I.E; E2.info.itags = { 's01', 's01*'};\nZ2 = Z; Z2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2, 'A01*',[1 3 2]);\n\nH = contract(A, '!2*',{F1, '!1',{F2, '!2*',{Z2, '!1',A}}}) + ...\n    contract(A, '!2*',{F1, '!2*',{Z2, '!1',{F2, '!1',A}}}) + ...\n    getIdentity(A,2) * 1e-40\n</code></pre> <p>The first line of defining H means \\(\\sum_{\\sigma } {\\hat{f} }_{2\\sigma }^{\\dagger } {\\hat{f} }_{1\\sigma }\\), and the second line means its Hermitian conjugate. And in the third line, we added the identity multiplied by a small number, to let <code>H</code> have all the sectors (that amount to 16 dimensional space).</p> <pre><code>celldisp(H.data)\n</code></pre> <p>ans{1} =  \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a00.0000   ans{3} =  \u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-1.4142\u00a0\u00a0\u00a0\u00a0\u00a00.0000   ans{4} =  \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0-1.0000 \u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a00.0000   ans{6} =  \u00a0\u00a0\u00a01.0000e-40 </p> <p>The eigenvalues and eigenvectors of H can be obtained by eig which is the wrap-up of eigQS.</p> <pre><code>[V,D] = eig(H)\n</code></pre> <p>V =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.  D =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (704 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06 x 10 =&gt; 10 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a024 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 F and D are QSpace objects. Each data of V is the unitary matrix whose columns are eigenvectors: <pre><code>celldisp(V.data)\n</code></pre></p> <p>ans{1} =  \u00a0\u00a0\u00a01  ans{2} =  \u00a0\u00a0-0.7071\u00a0\u00a0\u00a0\u00a00.7071 \u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a00.7071   ans{3} =  \u00a0\u00a0\u00a0-0.5000\u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0\u00a0-0.5000 \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0-0.5000\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a0-0.5000   ans{4} =  \u00a0\u00a0\u00a01  ans{5} =  \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.7071 \u00a0\u00a0\u00a0-0.7071\u00a0\u00a0\u00a0-0.7071   ans{6} =  \u00a0\u00a0\u00a01 </p> <p>We can check the unitarity of V by</p> <pre><code>V2 = contract(V, '!2*',V);\nsameas(V2,getIdentity(A,2))\n</code></pre> <p>ans =  logical \u00a0\u00a0\u00a01 </p> <p>Each data of D is the row vector of eigenvalues:</p> <p><pre><code>celldisp(D.data)\n</code></pre> ans{1} = \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0-1.0000  ans{3} =  \u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000  ans{4} = \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0-1.0000  ans{6} = \u00a0\u00a0\u00a01.0000e-40 </p> <p>(Quick exercise: Explain the eigenvalues.)</p> <p>To make D as an operator representing a diagonal matrix,</p> <pre><code>D2 = diag(D)\n</code></pre> <p>V =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 </p> <pre><code>celldisp(D2.data)\n</code></pre> <p>ans{1} =  \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a01.0000   ans{3} =  \u00a0\u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a02.0000   ans{4} =  \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0-1.0000   ans{6} =  \u00a0\u00a0\u00a01.0000e-40 </p> <p>One may also directly use the original MEX function eigQS. <pre><code>[E,Ieig] = eigQS(H);\n</code></pre></p> <p>Note that the syntax is a bit different from the wrap-up eig. E is two-column matrix whose first column is the energy eigenvalues (sorted in ascending order) and second column indicates the multiplet dimensions (i.e., degeneracy due to non-Abelian symmetry) associated with the eigenvalues. When only the Abelian symmetries are used, E becomes a column vector, without having the second column for the multiplet dimensions.</p> <pre><code>E\n</code></pre> <p>ans = 10x2  \u00a0\u00a0\u00a0\u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0000\u00a0\u00a0\u00a0\u00a0\u00a03.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000 </p> <p>And Inrg is the struct that contains more result of the eigendecomposition, including the eigenvectors (.AK and .AT) and eigenvalues (.EK and .ET). <pre><code>Ieig\n</code></pre> ans = struct with fields:  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AK: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AD: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0EK: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ED: [1x1 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DB: [6x2 struct] \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NK: 10 \u00a0\u00a0\u00a0Etrunc: 0 </p> <p>Becasue of the MATLAB policy, the direct result of MEX functions should be of MATLAB built-in types, while the QSpace is the user-defined data type. Here .AK, .AT, .EK, and .ET are struct variables that are compatible with QSpace. So we wrap them up as QSpace objects:</p> <p><pre><code>Ieig.EK = QSpace(Ieig.EK);\nIeig.AK = QSpace(Ieig.AK);\nIeig.EK\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01e-40 <pre><code>Ieig.AK\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -2 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 1 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 0 ; \u00a00 0 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 2 ; \u00a00 2 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 1 ; \u00a01 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a02 0 ; \u00a02 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>We can set several options for eigQS, such as Nkeep (number of multiplets to be kept) and Etrunc (threshold energy such that the energy eigenvalues below the value are to be kept). For details, type: eigQS -?</p>"},{"location":"tutorial/QSpace_intro/#singular-value-decomposition","title":"Singular value decomposition","text":"<p>We can perform the singular value decomposition (SVD) of QSpace objects, by using MEX function svdQS. The first input to svdQSis a QSpace object whose legs are all in. Indeed, this notion of decomposing all-in tensor is consistent with the diagrammatic expresssion of the Schmidt decomposition.</p> <p>And the second input is the leg indices. The corresponding legs are to be the legs of the third output Vd for right singular vectors. When non-Abelian symmetry is used, it is allowed to choose only one or \\(r-1\\) indices, where \\(r\\) is the rank of the first input. To \"split off\" different number of legs (to be associated with Vd), we need to fuse the legs by using the isometry generated by getIdentity; then perform the SVD; then split the legs by appling the conjugate of the iseometry used to fuse the legs.</p> <p>For example, consider an isometry:</p> <pre><code>[S,I] = getLocalSpace( 'Spin',1/2);\nE1 = I.E; E1.info.itags = { 's00', 's00*'};\nE2 = I.E; E2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2,'A01*',[1 3 2]);\n</code></pre> <p>We need to flip the second leg to perform the SVD.</p> <pre><code>I0 = getIdentity(A,2, '-0');\nAI = contract(A, '!1',I0, '!2*',[1 3 2])\n</code></pre> <p>Then use the svdQS. <pre><code>[U,S,Vd] = svdQS(AI,1);\n</code></pre></p> <p>As mentioned above, the direct outputs from MEX functions are in the form of struct variables, not as QSpace objects. So we need to wrap them up. <pre><code>U = QSpace(U);\n</code></pre> U =  \u00a0\u00a0\u00a0\u00a0Q: 2x [1 1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00*, A01, s01 }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 2 x 1 =&gt; 2 x 4 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 0 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x3x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 2 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.225</p> <p><pre><code>S = QSpace(S)\n</code></pre> S =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0{1.414}</p> <p><pre><code>Vd = QSpace(Vd)\n</code></pre> Vd =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00*, s00 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}</p> <p>The first leg (incoming) of AI is associated with the second leg (incoming) of Vd. And the singular value tensor S is all-in.</p>"},{"location":"tutorial/QSpace_intro/#normalization-convention","title":"Normalization convention","text":"<p>The QSpace library has different conventions of normalizing the Clebsch-Gordan coefficients for rank-2 tensors (such as Z and I.E) and for higher-rank tensors (such as F and S).</p> <p>For rank-2 tensors, the Clebsch-Gordan coefficients are normalized so that the reduced matrix elements have immediately relevant values. The elements of the tensor D (obtained after eig) for the energy eigenvalues are indeed energy eigenvalues. <pre><code>celldisp(D.data)\n</code></pre></p> <p>ans{1} = \u00a0\u00a0\u00a01.0000e-40  ans{2} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a0\u00a01.0000  ans{3} =  \u00a0\u00a0-2.0000\u00a0\u00a0\u00a0\u00a0-0.0000\u00a0\u00a0\u00a0\u00a0\u00a02.0000  ans{4} = \u00a0\u00a0\u00a01.0000e-40  ans{5} =  \u00a0\u00a0-1.0000\u00a0\u00a0\u00a0\u00a01.0000  ans{6} = \u00a0\u00a0\u00a01.0000e-40  Also each cell .data{..} of identity operator I.E contains the identity matrices themselves. <pre><code>celldisp(I.E.data)\n</code></pre></p> <p>ans{1} = \u00a0\u00a0\u00a01.0000 </p> <p>On the other hand, for higher-rank tensors, the Clebsch-Gordan coefficents are normalized so that the contraction of a tensor and its Hermitian conjugate becomes unity, when the reduced matrix elements are unity. For example, consider a rank-3 tensor which is the subspace projection of F, <pre><code>O1 = getsub(F,2)\n</code></pre></p> <p>O1 =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , *,  * }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 =&gt; 2 x 1 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414</p> <pre><code>O1.data{1} = 1; % make the reduced matrix to be trivial 1\n</code></pre> <p>The contraction of O1 and its Hermitian conjugate, with all the legs contracted, is equal to the squared norm of the Clebsch-Gordan coefficents, since the reduced matrix is set as trivial 1.</p> <p><pre><code>contract(O1, '1,2,3',O1, '1,2,3;*')\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.</p> <p>On the other hand, due to the different normalization convention of rank-2 tensors, the contraction of two identity operators, with all the legs contracted, becomes the Hilbert space dimension. <pre><code>contract(I.E, '1,2',I.E, '1,2;*')\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.</p>"},{"location":"tutorial/QSpace_intro/#outer-multiplicity","title":"Outer multiplicity","text":"<p>When non-Abelian symmetry is used, it is possible that there are multiple sectors with the same quantum numbers, while different sectors are indeed associated with different (orthogonal) Clebsch-Gordan coefficients. It is called outer multiplicity. One simple example is:</p> <pre><code>[S,I] = getLocalSpace( 'Spin',1/2);\nA1 = getIdentity(I.E,2,I.E,2);\nA2 = getIdentity(A1,3,I.E,2);\nA12 = contract(A1, '3',A2, '1')\n</code></pre> <p>A12 =  \u00a0\u00a0\u00a0\u00a0Q: 3x [1 1 1 1] having 'SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ , , , * }\u00a0\u00a0\u00a0 \u00a0data: 4-D double (352 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 x 1 x 3 =&gt; 2 x 2 x 2 x 8  \u00a0\u00a0\u00a0\u00a01. 1x1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a02. 1x1x1x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 1 ]\u00a0\u00a016 B\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a03. 1x1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2x2x4 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ; 1 ; 3 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.  The first and second sectors have the same quantum numbers! But, of course, they are orthogonal. Consider their parts:</p> <pre><code>A12a = getsub(A12,1);\nA12a.data{1} = 1;\nA12b = getsub(A12,2);\nA12b.data{1} = 1;\n</code></pre> <p>Here we replaced the reduced matrix elements (.data{..}) with ones, to focus on the Clebsch-Gordan coefficients. Then their overlap, i.e., contraction between A12a and the conjugate of A12b vanishes.</p> <p><pre><code>contract(A12a,'1234',A12b, '1234*');\n</code></pre> ans = (empty QSpace) </p> <p>On the other hand, three incoming legs (from the first to the third) look identical, so it seems that the tensor remains the same after permuting the incoming legs. But it's not! The overlap with A12a and the permutation of the first and third legs of A12a is not unity. It means that the Clebsch-Gordan coefficients can change by permuting legs.</p> <pre><code>contract(A12a,'1234',A12b, '3214*'); % note the 4th input\n</code></pre> <p>ans =  \u00a0\u00a0\u00a0\u00a0Q: [] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0data: 0-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0[  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.5</p> <p>Why? Let's draw the tensor network diagram for the first and second sectors of A12.</p> <p> </p> <p>Attached to the legs are spin quantum numbers. Fusing two \\(S=1/2\\) (two incoming legs of A1) lead to two values of spin \\(S=0\\oplus 1\\) (outgoing leg of A1). These two values can result in \\(S=1/2\\) (outgoing leg of A2) by being fused with one \\(S=1/2\\) (bottom incoming leg of A2). The outer multiplicity of A12 reflects this two different ways of having four legs of \\(S=1/2\\). In this diagram, it is clear to see that the left leg of A1 and the bottom leg of A2 are not equivalent.</p> <p> </p>"},{"location":"tutorial/Rank2/","title":"Rank-2 Tensors","text":"<p>Rank-2 tensors are of the simplest type. (Quick exercise: Why not rank-1?) They are scalar in terms of Clebsch-Gordan coefficients and there is no (outer) multiplicity of symmetry sectors. And their reduced matrix elements form matrices.</p> <p>So the QSpace library enables to treat rank-2 QSpace objects, in a way that usual matrices are treated by MATLAB built-in functions.</p> <pre><code>Z.'  % transpose\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <pre><code>Z'  % Hermitian conjugate\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <pre><code>Z' - Z  % Z is Hermitian\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00. <pre><code>Z * I.E  % matrix multiplication as contraction\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ *,  }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>As in the case of permute explained above, MATLAB can execute different functions depending on the type of inputs. That is, there are several QSpace functions that override the MATLAB built-in functions.</p> <p>This simplification also works for some rank-3 tensors (whose .info.otype is set as 'operator'').</p> <pre><code>F  % Hermitian conjugate, the result is particle creation operators\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0operator,\u00a0\u00a0\u00a0{  , *,  }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 x 1 =&gt; 3 x 3 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; -1 0 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x2x2 \u00a0\u00a0\u00a0\u00a0\u00a0[ 1 0 ; \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414 <p>However, it is advisable to use permute and  contract in general, to avoid any mistake.</p>"},{"location":"tutorial/SingValDecomp/","title":"Singular Value Decomposition","text":"<p>We can perform the singular value decomposition (SVD) of QSpace objects, by using MEX function svdQS. The first input to svdQSis a QSpace object whose legs are all in. Indeed, this notion of decomposing all-in tensor is consistent with the diagrammatic expresssion of the Schmidt decomposition.</p> <p>And the second input is the leg indices. The corresponding legs are to be the legs of the third output Vd for right singular vectors. When non-Abelian symmetry is used, it is allowed to choose only one or \\(r-1\\) indices, where \\(r\\) is the rank of the first input. To \"split off\" different number of legs (to be associated with Vd), we need to fuse the legs by using the isometry generated by getIdentity; then perform the SVD; then split the legs by appling the conjugate of the iseometry used to fuse the legs.</p> <p>For example, consider an isometry:</p> <pre><code>[S,I] = getLocalSpace( 'Spin',1/2);\nE1 = I.E; E1.info.itags = { 's00', 's00*'};\nE2 = I.E; E2.info.itags = { 's01', 's01*'};\nA = getIdentity(E1,2,E2,2,'A01*',[1 3 2]);\n</code></pre> <p>We need to flip the second leg to perform the SVD.</p> <pre><code>I0 = getIdentity(A,2, '-0');\nAI = contract(A, '!1',I0, '!2*',[1 3 2])\n</code></pre> <p>Then use the svdQS. <pre><code>[U,S,Vd] = svdQS(AI,1);\n</code></pre></p> <p>As mentioned above, the direct outputs from MEX functions are in the form of struct variables, not as QSpace objects. So we need to wrap them up. <pre><code>U = QSpace(U);\n</code></pre></p> U =  \u00a0\u00a0\u00a0\u00a0Q: 2x [1 1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00*, A01, s01 }\u00a0\u00a0\u00a0 \u00a0data: 3-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 2 x 1 =&gt; 2 x 4 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x1x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 0 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.7071\u00a0\u00a0\u00a0\u00a02. 1x1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x3x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 2 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.225 <pre><code>S = QSpace(S)\n</code></pre> S =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00, s00 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-1.414\u00a0\u00a0{1.414} <pre><code>Vd = QSpace(Vd)\n</code></pre> Vd =  \u00a0\u00a0\u00a0\u00a0Q: 1x [1 1] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ s00*, s00 }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 1 ; 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414} <p>The first leg (incoming) of AI is associated with the second leg (incoming) of Vd. And the singular value tensor S is all-in.</p>"},{"location":"tutorial/Subspace/","title":"Access Subspaces","text":"<p>We can select part of symmetry sectors, by using getsub. <pre><code>I.E\n</code></pre></p> ans =  \u00a0\u00a0\u00a0\u00a0Q: 3x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (336 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03 x 3 =&gt; 4 x 4  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. \u00a0\u00a0\u00a0\u00a02. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{-1.414} \u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <pre><code>getsub(I.E,2)  % select the second sector \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{-1.414} <pre><code>getsub(I.E,[1 3])  % select the first and third sectors \n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 2x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (224 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 x 2 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a01 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>To choose the sectors of specific quantum numbers, we can combine getsub, find, and ismember (the latter two are MATLAB built-ins.) <pre><code>getsub(I.E,find(ismember(I.E.Q{1},[0 1],'rows'))) % choose [0 1] sector \n</code></pre></p> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414} <p>It can be done also with all and bsxfun. <pre><code>getsub(I.E,find(all(bsxfun(@eq,I.E.Q{1},[0 1]),2))) % the same \n</code></pre></p> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 2 x 2  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 1 ; 0 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.414}"},{"location":"tutorial/Vacuum/","title":"Vacuum Space","text":"<p>The left end and the right end of the matrix product states (MPS) are dummy legs of dimension 1. These dummy legs are introduced to represent all the constituent tensors (so-called A and B tensors) as being rank-3. Thus the dummy legs point to the space which has nothing, i.e., vacuum. The vacuum space carries no quantum number at all, and it is different from the empty state which has specific quantum number. The vacuum space for given set of symmetries is obtained by using getvac:</p> <pre><code>getvac(I.E)\n</code></pre> ans =  \u00a0\u00a0\u00a0\u00a0Q: 1x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0{ , * }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (112 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01 x 1 =&gt; 1 x 1  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ 0 0 ; 0 0  ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01."},{"location":"tutorial/ZeroTrunc/","title":"Truncation of Zeros","text":"<p>The contract (and some other functions) of the QSpace library may remove the sectors whose reduced matrix elements (elements of .data{..}) are all zeros. For example, consider the following case. <pre><code>[F,Z,S,I] = getLocalSpace( 'FermionS', 'Acharge', 'SU2spin', 'NC',1);\nM1 = I.E; M1.info.itags = { 's00', 's00*'};\nM2 = I.E; M2.info.itags = { 's01', 's01*'};\nA = getIdentity(M1,2,M2,2, 'A01*',[1 3 2]);\ncontract(A, '!2*',{M1, '!1',{M2, '!1',A}})\n</code></pre></p> A =  \u00a0\u00a0\u00a0\u00a0Q: 6x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (784 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010 x 10 =&gt; 16 x 16  \u00a0\u00a0\u00a0\u00a01. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a02. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a03. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a05. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a06. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a01 0 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>This is the normal contraction of the identity tensors. The result acts on 16-dimensional space of two spinful fermionic sites.</p> <p>What happens if we replace one sector of A with all-zero reduced matrix elements?</p> <pre><code>A.data{1} = zeros(size(A.data{1}));\ncontract(A, '!2*',{M1, '!1',{M2, '!1',A}});\n</code></pre> A =  \u00a0\u00a0\u00a0\u00a0Q: 5x [2 2] having 'A,SU2',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ A01, A01* }\u00a0\u00a0\u00a0 \u00a0data: 2-D double (672 bytes)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09 x 9 =&gt; 15 x 15  \u00a0\u00a0\u00a0\u00a01. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -2 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a02. 3x3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; -1 1 ]\u00a0\u00a072 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a03x3 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; -1 1 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.\u00a0\u00a0{1.732}\u00a0\u00a0\u00a0\u00a04. 2x2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a02x2 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ -1 0 ; \u00a00 0 ]\u00a0\u00a032 B\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.414}\u00a0\u00a0\u00a0\u00a05. 1x1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a01x1 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ \u00a00 1 ; \u00a00 0 ]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01. <p>Then we have the sector [-2 0] is missing, and the result acts on 15-dimensional space.</p> <p>It is an intended feature rather than a bug. When contract tensors over the tensor network, the all-zero sectors in the constituent tensors do not contribute to the result. So the truncation of such all-zero sectors yields better computational efficiency.</p> <p>However, when we consider the Hamiltonian in effective basis, the Hamiltonian may have the sectors of all zero matrix elements, and such sectors should be kept. All the energy eigenvalues, whether zero or finite, have meaning! For this, we should enforce to keep all-zero sectors. One trick is to add the identity operator, multiplied by very small number smaller than double precision (e.g., \\(10^{-30}\\)), to the Hamiltonian. Such small number should not change the physical results, but prevents unwanted truncation.</p>"},{"location":"tutorial/getLocalSpace/","title":"Starting Point: <code>getLocalSpace</code>","text":"<p>The <code>getLocalSpace</code> function in the QSpace library is the foundational step for generating tensors with symmetries, serving as the crucial starting point for any tensor algorithm within this framework. It's designed to construct local model state spaces, incorporating a variety of quantum operators like spin, annihilation, and charge parity. The function also supports a wide range of symmetries, including abelian and non-abelian groups like SU(2) and SU(N). This makes <code>getLocalSpace</code> a versatile tool for building tensor networks with different symmetries, crucial for quantum physics research.</p>"},{"location":"tutorial/getLocalSpace/#understanding-the-function-syntax","title":"Understanding the Function Syntax","text":"<ul> <li>General Form: <code>[FF,...,Iout]=getLocalSpace(model, ['sym1,sym2,...', varargin])</code></li> <li>Parameters Explained:<ul> <li><code>model</code>: This denotes the quantum model type. It could be fermions (spinful/spinless), spin operators, etc.</li> <li><code>sym1, sym2, ...</code>: These are symmetries applicable to the model. Examples include total charge, spin, and particle-hole symmetry.</li> <li><code>varargin</code>: Additional options for customizing the function's operation, like specifying the number of channels or enabling verbose mode for detailed output.</li> </ul> </li> </ul>"},{"location":"tutorial/getLocalSpace/#delving-into-supported-models-and-options","title":"Delving into Supported Models and Options","text":"<p>The <code>getLocalSpace</code> function in QSpace supports a diverse range of models, each tailored for specific quantum systems. This includes:</p> <ol> <li>Fermionic Systems: Both spinful and spinless fermions are supported, allowing for simulations of electrons with or without spin considerations.</li> <li>Pure Spin Models: These models focus solely on the spin aspect, crucial for studies in spin dynamics and spin-based quantum interactions.</li> <li>Various Quantum Groups: The function supports a variety of groups like SU(2), SU(N), SO(N), and Sp(2N), each offering different symmetry structures for the tensors.</li> </ol> <p>In terms of options, <code>getLocalSpace</code> provides flexibility through parameters like:</p> <ul> <li><code>NC</code> (number of channels): Defines the complexity of the system, particularly in fermionic models.</li> <li><code>-A</code> (abelian symmetry): Simplifies the model by using abelian symmetries, useful for certain theoretical studies.</li> <li><code>-v</code> (verbose mode): Offers detailed output for in-depth analysis and debugging.</li> </ul> <p>Each model and option in <code>getLocalSpace</code> is designed to give users precise control over their tensor network configurations, making it a versatile tool in quantum physics research.</p>"},{"location":"tutorial/getLocalSpace/#comprehensive-guide-to-symmetries","title":"Comprehensive Guide to Symmetries","text":"<ul> <li>Symmetry Types Explained:<ul> <li><code>Acharge</code>: Represents abelian total charge symmetry, used in charge-conserving quantum models.</li> <li><code>SU2charge</code>: Denotes SU(2) symmetry for total particle-hole systems, pivotal in complex quantum systems.</li> <li><code>Aspin</code>: Abelian total spin symmetry, applicable in spin-conserving models.</li> <li><code>SU2spin</code>: A non-abelian symmetry representing total spin, essential for studying spin interactions.</li> <li><code>SU2spinJ</code>: Combines orbital (L) and spin (S) symmetries, denoted as J=L+S.</li> <li><code>AspinJ</code>: A U(1) symmetry for total spin (J=L+S)_z.</li> <li><code>SUNchannel</code>: Represents SU(N) channel symmetry, crucial for studying systems with N-level quantum states.</li> <li><code>SONchannel</code>: SO(N) channel symmetry, applicable in certain types of quantum models.</li> <li><code>SpNchannel</code>: Sp(N) symmetry, used in particle/hole charge models with channel symmetry.</li> </ul> </li> <li>Application: Each symmetry type tailors the quantum model to specific physical properties and interactions.</li> </ul>"},{"location":"tutorial/getLocalSpace/#examples","title":"Examples","text":"<ol> <li> <p>Pure Spin Model (Spin-1 System):</p> <ul> <li><code>[S,IS]=getLocalSpace('Spin',1,'-v');</code></li> <li>Configures a single spin-1 site, useful for studying isolated spin dynamics.</li> </ul> </li> <li> <p>Spinless Fermions with SU(3) Channel Symmetry:</p> <ul> <li><code>[FF,Z,IS]=getLocalSpace('Fermion','SUNchannel','NC',3,'-v');</code></li> <li>Sets up three spinless fermion channels with SU(3) symmetry.</li> </ul> </li> <li> <p>Spinful Fermions with Abelian Charge and SU(2) Spin:</p> <ul> <li><code>[FF,Z,SS,IS]=getLocalSpace('FermionS','Acharge,SU2spin','NC',3,'-v');</code></li> <li>Constructs a system with three channels, each having an abelian charge and an SU(2) spin symmetry.</li> </ul> </li> <li> <p>Spinful Fermions with Particle-Hole Symmetry:</p> <ul> <li><code>[FF,Z,SS,IS]=getLocalSpace('FermionS','SU2charge(:),SU2spin','NC',3,'-v');</code></li> <li>Creates a spinful fermion model with individual SU(2) charge symmetry in each of three channels and an overall SU(2) spin symmetry.</li> </ul> </li> <li> <p>Spinful Fermions with SU(2) SpinJ Symmetry:</p> <ul> <li><code>[FF,Z,JJ,IS]=getLocalSpace('FermionS','Acharge,SU2spinJ','NC',3,'-v');</code></li> <li>This example configures spinful fermions with a combined orbital and spin symmetry (SU(2) SpinJ).</li> </ul> </li> </ol>"},{"location":"tutorial/getLocalSpace/#decoding-the-outputs","title":"Decoding the Outputs","text":"<ul> <li>Output Variables: <code>FF</code>, <code>Iout</code>, and others vary based on the selected model. They represent the quantum states and operators configured by <code>getLocalSpace</code>.</li> <li>Usage in Quantum Models: These outputs form the backbone of tensor network states, used in simulations and calculations in quantum physics.</li> </ul>"}]}